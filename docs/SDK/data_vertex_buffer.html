<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LightsprintSDK: Vertex buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LightsprintSDK<span id="projectnumber">&#160;2021.08.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('data_vertex_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Vertex buffer</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Vertex buffer is designed for storage of per-vertex data for single object.</p>
<h1><a class="anchor" id="d11"></a>
Suitable for</h1>
<table class="doxtable">
<tr>
<th></th><th>global or direct or indirect illumination </th><th>ambient occlusion </th><th>bent normals  </th></tr>
<tr>
<th>static objects </th><td>YES </td><td>YES </td><td>YES  </td></tr>
<tr>
<th>dynamic objects </th><td>NO  </td><td>YES </td><td>YES  </td></tr>
<tr>
<th>realtime calculated illumination </th><td>YES </td><td>NO  </td><td>NO   </td></tr>
<tr>
<th>precalculated illumination </th><td>YES </td><td>YES </td><td>YES  </td></tr>
</table>
<h1><a class="anchor" id="d12"></a>
Advantages</h1>
<ul>
<li>Compact representation. It requires only few bytes per vertex. Samples store illumination as 3 floats, but it can be switched to 4 bytes, arbitrary compression can be added.</li>
<li>Fast rendering. No sampler resources are consumed. It can be arbitrarily postprocessed in vertex shader. You can have multiple layers of precalculated indirect illumination and mix them at no cost in vertex shader according to changes in scene.</li>
<li>There is no need to change your lightning equation, simply use our ambient data instead of constant ambient.</li>
<li>If you don't precompute bent normals, ambient lighting values don't depend on view angle, so rendering is very fast.</li>
<li>If you do precompute bent normals, normal maps work great even in shadows, knowing direction of incoming indirect light.</li>
</ul>
<h1><a class="anchor" id="d13"></a>
Disadvantages</h1>
<ul>
<li>Details are missing in areas without vertices. For good results, you have to add vertices to places where you miss details.</li>
<li>Seams around T vertices and other degenerated geometries. You have to make your meshes clean, avoid degeneracies.</li>
<li>Long narrow triangles (needles) often create visible artifacts. This is often problem also for physical engine, so your 3d artisis probably know they should avoid needles.</li>
</ul>
<h1><a class="anchor" id="d15"></a>
Interface</h1>
<ul>
<li><a class="el" href="classrr_1_1_r_r_buffer.html" title="Buffer, array of elements.">RRBuffer</a></li>
</ul>
<h1><a class="anchor" id="d14"></a>
Instances</h1>
<ul>
<li>stored in: <a class="el" href="classrr_1_1_r_r_object_illumination.html#a442c7ba4cc2a834014edecfb1c49076a" title="Returns illumination buffer from given layer.">RRObjectIllumination::getLayer()</a></li>
<li>created by: <a class="el" href="classrr_1_1_r_r_solver.html#aaf0703d3ee895467659bbf3ebd9e198c" title="Allocates buffers for realtime GI illumination of objects in solver.">RRSolver::allocateBuffersForRealtimeGI()</a> or allocate and assign buffers yourself</li>
<li>updated by: <a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009" title="For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-verte...">RRSolver::updateLightmaps()</a> or <a class="el" href="classrr_1_1_r_r_solver.html#a4aaa9ea4b5f70eb96a3313a5bf1fd592" title="For single static object, calculates and updates lightmap and/or bent normals; in per-pixel or per-ve...">RRSolver::updateLightmap()</a>.</li>
</ul>
<h1><a class="anchor" id="d16"></a>
Rendering with</h1>
<ul>
<li>Stream data from vertex buffer into vertex shader, interpret them in shader appropriately as light level, ambient occlusion or bent normal.</li>
</ul>
<h1><a class="anchor" id="d17"></a>
Examples</h1>
<ul>
<li>Generic example: <br  />
 Creating vertex buffer. <div class="fragment"><div class="line">vertexBuffer = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#a3e3d651ad26701f619da5017646793c8">rr::RRBuffer::create</a>(<a class="code hl_enumvalue" href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286a9f4ce876631b0842ee682a8bc4be747f">rr::BT_VERTEX_BUFFER</a>,numVertices,1,1,<a class="code hl_enumvalue" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413a2464ce5c96d33ac7139bcffae31e715e">rr::BF_RGBF</a>,<span class="keyword">true</span>,<span class="keyword">nullptr</span>);</div>
<div class="ttc" id="aclassrr_1_1_r_r_buffer_html_a3e3d651ad26701f619da5017646793c8"><div class="ttname"><a href="classrr_1_1_r_r_buffer.html#a3e3d651ad26701f619da5017646793c8">rr::RRBuffer::create</a></div><div class="ttdeci">static RRBuffer * create(RRBufferType type, unsigned width, unsigned height, unsigned depth, RRBufferFormat format, bool scaled, const unsigned char *data)</div><div class="ttdoc">Creates buffer in system memory. See reset() for parameter details. Returns nullptr when parameters a...</div></div>
<div class="ttc" id="anamespacerr_html_a6d3b8b9b246e283277a19771ad7e3413a2464ce5c96d33ac7139bcffae31e715e"><div class="ttname"><a href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413a2464ce5c96d33ac7139bcffae31e715e">rr::BF_RGBF</a></div><div class="ttdeci">@ BF_RGBF</div><div class="ttdoc">Floating point RGB, 96bits per pixel. High precision, suitable for any data, but some old GPUs don't ...</div><div class="ttdef"><b>Definition</b> RRBuffer.h:94</div></div>
<div class="ttc" id="anamespacerr_html_a930c3549f9b4b1a207844b9e7d0fb286a9f4ce876631b0842ee682a8bc4be747f"><div class="ttname"><a href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286a9f4ce876631b0842ee682a8bc4be747f">rr::BT_VERTEX_BUFFER</a></div><div class="ttdeci">@ BT_VERTEX_BUFFER</div><div class="ttdoc">Vertex buffer, 1d array of width elements. Used for object's realtime indirect lighting,...</div><div class="ttdef"><b>Definition</b> RRBuffer.h:83</div></div>
</div><!-- fragment --></li>
<li>OpenGL example: <br  />
 Rendering with per vertex ambient. <div class="fragment"><div class="line"><a class="code hl_class" href="classrr_1_1_r_r_solver.html">rr::RRSolver</a>* dynamicSolver;</div>
<div class="line">GLuint program;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// set program created from shaders below</span></div>
<div class="line">glUseProgram(program);</div>
<div class="line"><span class="comment">// get vertex buffer with indirect illumination</span></div>
<div class="line"><a class="code hl_class" href="classrr_1_1_r_r_buffer.html">rr::RRBuffer</a>* vertexBuffer = <span class="keywordtype">object</span>-&gt;illumination.getLayer(0);</div>
<div class="line"><span class="comment">// enable stream with color values</span></div>
<div class="line">glEnableClientState(GL_COLOR_ARRAY);</div>
<div class="line"><span class="comment">// set pointer to color data for first vertex</span></div>
<div class="line">glColorPointer(3, GL_FLOAT, 0, vertexBuffer-&gt;<a class="code hl_function" href="classrr_1_1_r_r_buffer.html#aaa62f66d38ac68490fa2ee09847562cf">lock</a>(<a class="code hl_enumvalue" href="namespacerr.html#a9c825752da122dbe1cb0b8c7b0734a4ba5f853d7b3e6d44f5ab6702b92d669960">rr::BL_READ</a>));</div>
<div class="line"><span class="comment">// render primitives</span></div>
<div class="line">glDrawElements...</div>
<div class="line"><span class="comment">// cleanup</span></div>
<div class="line">vertexBuffer-&gt;unlock();</div>
<div class="line">glDisableClientState(GL_COLOR_ARRAY);</div>
<div class="ttc" id="aclassrr_1_1_r_r_buffer_html"><div class="ttname"><a href="classrr_1_1_r_r_buffer.html">rr::RRBuffer</a></div><div class="ttdoc">Buffer, array of elements.</div><div class="ttdef"><b>Definition</b> RRBuffer.h:168</div></div>
<div class="ttc" id="aclassrr_1_1_r_r_buffer_html_aaa62f66d38ac68490fa2ee09847562cf"><div class="ttname"><a href="classrr_1_1_r_r_buffer.html#aaa62f66d38ac68490fa2ee09847562cf">rr::RRBuffer::lock</a></div><div class="ttdeci">virtual unsigned char * lock(RRBufferLock lock)</div><div class="ttdoc">Locks the buffer for accessing array of all elements at once. Not mandatory, may return nullptr.</div></div>
<div class="ttc" id="aclassrr_1_1_r_r_solver_html"><div class="ttname"><a href="classrr_1_1_r_r_solver.html">rr::RRSolver</a></div><div class="ttdoc">Global illumination solver for interactive applications.</div><div class="ttdef"><b>Definition</b> RRSolver.h:58</div></div>
<div class="ttc" id="anamespacerr_html_a9c825752da122dbe1cb0b8c7b0734a4ba5f853d7b3e6d44f5ab6702b92d669960"><div class="ttname"><a href="namespacerr.html#a9c825752da122dbe1cb0b8c7b0734a4ba5f853d7b3e6d44f5ab6702b92d669960">rr::BL_READ</a></div><div class="ttdeci">@ BL_READ</div><div class="ttdoc">Lock for reading only.</div><div class="ttdef"><b>Definition</b> RRBuffer.h:107</div></div>
</div><!-- fragment --> Using ambient value in GLSL vertex shader: <div class="fragment"><div class="line">varying vec3 ambientLight;</div>
<div class="line"><span class="keywordtype">void</span> vertexShader()</div>
<div class="line">{</div>
<div class="line">        ...</div>
<div class="line">        ambientLight = gl_Color;</div>
<div class="line">}</div>
</div><!-- fragment --> Using ambient value in GLSL fragment shader: <div class="fragment"><div class="line">varying vec3 ambientLight;</div>
<div class="line"><span class="keywordtype">void</span> fragmentShader()</div>
<div class="line">{</div>
<div class="line">        ...</div>
<div class="line">        gl_FragColor = ... + materialColor * vec4(ambientLight.xyz,0.0);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Direct3D 9 example: <br  />
 Rendering with per vertex ambient. <div class="fragment"><div class="line">IDirect3DDevice9* device;</div>
<div class="line">IDirect3DPixelShader9* vertexShader;</div>
<div class="line">IDirect3DPixelShader9* pixelShader;</div>
<div class="line"><span class="comment">// adapt your vertex declaration, let your mesh read data from stream 0</span></div>
<div class="line"><span class="comment">// and add e.g. COLOR1 read from stream 1</span></div>
<div class="line">IDirect3DVertexDeclaration9* vertexDeclaration;</div>
<div class="line">device-&gt;CreateVertexDeclaration(description, &amp;vertexDeclaration);</div>
<div class="line">...</div>
<div class="line"><span class="comment">// create d3d vertex buffer and fill it with vertexBuffer-&gt;lock() data</span></div>
<div class="line">rr::RRBuffer* vertexBuffer = <span class="keywordtype">object</span>-&gt;illumination.getLayer(0);</div>
<div class="line">IDirect3DVertexBuffer9* d3dBuffer = ...;</div>
<div class="line"><span class="comment">// to prevent data duplication and copying, implement RRBuffer</span></div>
<div class="line"><span class="comment">//  that stores vertex data directly into d3d vertex buffer</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// set rendering pipeline to use shaders below</span></div>
<div class="line">device-&gt;SetPixelShader(vertexShader);</div>
<div class="line">device-&gt;SetPixelShader(pixelShader);</div>
<div class="line"><span class="comment">// activate previously created vertex declaration</span></div>
<div class="line">device-&gt;SetVertexDeclaration(vertexDeclaration);</div>
<div class="line"><span class="comment">// set pointer to your mesh (vertices, possibly normals etc.) in stream 0</span></div>
<div class="line">device-&gt;SetStreamSource(0, ...);</div>
<div class="line"><span class="comment">// set pointer to vertex illumination data in stream 1</span></div>
<div class="line">device-&gt;SetStreamSource(1, d3dBuffer, ...);</div>
<div class="line"><span class="comment">// render primitives</span></div>
<div class="line">device-&gt;DrawPrimitive...</div>
<div class="line"><span class="comment">// cleanup</span></div>
<div class="line">device-&gt;SetStreamSource(1, <span class="keyword">nullptr</span>, 0, 0);</div>
<div class="line">device-&gt;SetStreamSource(0, <span class="keyword">nullptr</span>, 0, 0);</div>
</div><!-- fragment --> Using ambient value in HLSL vertex shader: <div class="fragment"><div class="line"><span class="keywordtype">void</span> vertexShader(in float3 iAmbientLight: COLOR1,</div>
<div class="line">        ..., out float3 oAmbientLight: COLOR1)</div>
<div class="line">{</div>
<div class="line">        ...</div>
<div class="line">        oAmbientLight = iAmbientLight;</div>
<div class="line">}</div>
</div><!-- fragment --> Using ambient value in HLSL pixel shader: <div class="fragment"><div class="line"><span class="keywordtype">void</span> pixelShader(in float3 iAmbientLight: COLOR1,</div>
<div class="line">        ..., out float4 oColor: COLOR)</div>
<div class="line">{</div>
<div class="line">        ...</div>
<div class="line">        oColor = ... + materialColor * float4(iAmbientLight,0);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Alternatively, applying colors from vertex buffer could be done in fixed pipeline, without shaders, but it is beyond scope of this documentation.</li>
<li>See Direct3D, OpenGL or your engine documentation for more details on streaming per vertex data to vertex shader and rendering with ambient light, ambient occlusion or bent normals. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">index</a></li><li class="navelem"><a class="el" href="main_data_access.html">Calculation and outputs</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
