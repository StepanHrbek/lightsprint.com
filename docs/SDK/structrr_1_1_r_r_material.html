<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LightsprintSDK: rr::RRMaterial Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LightsprintSDK<span id="projectnumber">&#160;2021.08.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structrr_1_1_r_r_material.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structrr_1_1_r_r_material-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rr::RRMaterial Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;RRMaterial.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rr::RRMaterial:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structrr_1_1_r_r_material.png" usemap="#rr::RRMaterial_map" alt=""/>
  <map id="rr::RRMaterial_map" name="rr::RRMaterial_map">
<area href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html" title="When used as base class, object copying is not allowed." alt="rr::RRUniformlyAllocatedNonCopyable" shape="rect" coords="0,56,227,80"/>
<area href="classrr_1_1_r_r_uniformly_allocated.html" title="When used as base class, delete works correctly without regard who calls it." alt="rr::RRUniformlyAllocated" shape="rect" coords="0,0,227,24"/>
<area href="structrr_1_1_r_r_point_material.html" title="RRMaterial optimized for use in RRObject::getPointMaterial(), not for general use." alt="rr::RRPointMaterial" shape="rect" coords="0,168,227,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material_1_1_response.html">Response</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a019c36ffac127766dff920a9645dee37"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a019c36ffac127766dff920a9645dee37">UniformTextureAction</a> { <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a019c36ffac127766dff920a9645dee37afa6b50374026b9b5de20887c41b1f8c4">UTA_KEEP</a>
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a019c36ffac127766dff920a9645dee37a1be55975782b82e2a2313c9046ca636b">UTA_DELETE</a>
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a019c36ffac127766dff920a9645dee37a20d35e54ea8f7ad32470eb2518860742">UTA_NULL</a>
<br />
 }</td></tr>
<tr class="separator:a019c36ffac127766dff920a9645dee37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d06d97a2a6ca6ce60f84c927d884021"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021">SpecularModel</a> { <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021aab4706266a729d385f25e89b6bb91d95">PHONG</a> = 0
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021a64133b500d5aecf2dceb02255e6c981c">BLINN_PHONG</a> = 1
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021a48d56156d0fef77ae7c7df0759dfeac9">TORRANCE_SPARROW</a> = 2
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021a7d02228f46b14da5a7f89a1fa08a8a27">BLINN_TORRANCE_SPARROW</a> = 3
<br />
 }</td></tr>
<tr class="separator:a0d06d97a2a6ca6ce60f84c927d884021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bacb808ef8c3999719f9faa401f3645"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645">BrdfType</a> { <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645a4a87f94fb3294472b453335f9198d352">BRDF_NONE</a> = 0
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645aed01a760226c0b20c2a9e89ff327e725">BRDF_DIFFUSE</a> = 1
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645ac78aeea35d05cd47038897396fc9fa75">BRDF_SPECULAR</a> = 2
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645afc21aad4f0ccb5da21e90cbf53009a92">BRDF_TRANSMIT</a> = 4
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645a7f0f7c9e358bf4063cffb47a14de393f">BRDF_ALL</a> = 7
, <br />
&#160;&#160;<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645ac9adbc14f518bed94f25e76fc96efbce">NUM_BRDFS</a> = 3
<br />
 }</td></tr>
<tr class="separator:a0bacb808ef8c3999719f9faa401f3645"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a71b652ef78d2bfd1b57d4dddcaf7ee11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a71b652ef78d2bfd1b57d4dddcaf7ee11">RRMaterial</a> ()</td></tr>
<tr class="separator:a71b652ef78d2bfd1b57d4dddcaf7ee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748554f6119e030ee402e41bc8d0a953"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a748554f6119e030ee402e41bc8d0a953">copyFrom</a> (const <a class="el" href="structrr_1_1_r_r_material.html">RRMaterial</a> &amp;from)</td></tr>
<tr class="separator:a748554f6119e030ee402e41bc8d0a953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32d11781eaa2e199bf5ba85093ae336"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#ab32d11781eaa2e199bf5ba85093ae336">operator==</a> (const <a class="el" href="structrr_1_1_r_r_material.html">RRMaterial</a> &amp;a) const</td></tr>
<tr class="separator:ab32d11781eaa2e199bf5ba85093ae336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c44c8847b5703ccadeeb4b1b713cd0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a1c44c8847b5703ccadeeb4b1b713cd0d">reset</a> (bool twoSided)</td></tr>
<tr class="separator:a1c44c8847b5703ccadeeb4b1b713cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a483b5fae5b768b2a33916f13a64044"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a6a483b5fae5b768b2a33916f13a64044">updateColorsFromTextures</a> (const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace, <a class="el" href="structrr_1_1_r_r_material.html#a019c36ffac127766dff920a9645dee37">UniformTextureAction</a> uniformTextureAction, bool updateEvenFromStubs)</td></tr>
<tr class="separator:a6a483b5fae5b768b2a33916f13a64044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e8b003316560832adaaf3c5c24a5dd"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a27e8b003316560832adaaf3c5c24a5dd">createTexturesFromColors</a> ()</td></tr>
<tr class="separator:a27e8b003316560832adaaf3c5c24a5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96941a3e852a9a83f04e64273299f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#af96941a3e852a9a83f04e64273299f57">updateKeyingFromTransmittance</a> ()</td></tr>
<tr class="separator:af96941a3e852a9a83f04e64273299f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424d06cbb411650eec0692e03d4c9610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a424d06cbb411650eec0692e03d4c9610">updateSideBitsFromColors</a> ()</td></tr>
<tr class="separator:a424d06cbb411650eec0692e03d4c9610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a79045f5a86d8161fdb18cfd26ab29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a99a79045f5a86d8161fdb18cfd26ab29">updateBumpMapType</a> ()</td></tr>
<tr class="separator:a99a79045f5a86d8161fdb18cfd26ab29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d53e392adf51dd36b70c532b5df4198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a9d53e392adf51dd36b70c532b5df4198">validate</a> (<a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> redistributedPhotonsLimit=0.98f)</td></tr>
<tr class="separator:a9d53e392adf51dd36b70c532b5df4198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa330f3fce17cba4d35905a3de9f317ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#aa330f3fce17cba4d35905a3de9f317ec">convertFromLinear</a> (const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace)</td></tr>
<tr class="separator:aa330f3fce17cba4d35905a3de9f317ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d9bae2f80925327c2f4f1d4b9f88f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#ac6d9bae2f80925327c2f4f1d4b9f88f0">convertToLinear</a> (const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace)</td></tr>
<tr class="separator:ac6d9bae2f80925327c2f4f1d4b9f88f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675d999f72d2462ed5fa42a4ea93d1c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a675d999f72d2462ed5fa42a4ea93d1c2">needsBlending</a> () const</td></tr>
<tr class="separator:a675d999f72d2462ed5fa42a4ea93d1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42382174168f3669064bea10d7c2ed9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#af42382174168f3669064bea10d7c2ed9">~RRMaterial</a> ()</td></tr>
<tr class="separator:af42382174168f3669064bea10d7c2ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6f375cd54e5ca57305982835dda241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a5c6f375cd54e5ca57305982835dda241">getResponse</a> (<a class="el" href="structrr_1_1_r_r_material_1_1_response.html">Response</a> &amp;response, <a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645">BrdfType</a> type=<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645a7f0f7c9e358bf4063cffb47a14de393f">BRDF_ALL</a>) const</td></tr>
<tr class="separator:a5c6f375cd54e5ca57305982835dda241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962db9a5ad09406907f8fc1e47522d5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a962db9a5ad09406907f8fc1e47522d5b">sampleResponse</a> (<a class="el" href="structrr_1_1_r_r_material_1_1_response.html">Response</a> &amp;response, const <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;randomness, <a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645">BrdfType</a> type=<a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645a7f0f7c9e358bf4063cffb47a14de393f">BRDF_ALL</a>) const</td></tr>
<tr class="separator:a962db9a5ad09406907f8fc1e47522d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01de66f227b2d06e4f08dcffd7e55b5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a01de66f227b2d06e4f08dcffd7e55b5f">load</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;filename, <a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *textureLocator)</td></tr>
<tr class="separator:a01de66f227b2d06e4f08dcffd7e55b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37faea2f2b035ddd2c239a2e5294b0f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a37faea2f2b035ddd2c239a2e5294b0f8">save</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;filename) const</td></tr>
<tr class="separator:a37faea2f2b035ddd2c239a2e5294b0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrr_1_1_r_r_uniformly_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrr_1_1_r_r_uniformly_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated.html">rr::RRUniformlyAllocated</a></td></tr>
<tr class="memitem:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a073b837b152a4c54b8b581bd2e82ec08">operator new</a> (std::size_t n)</td></tr>
<tr class="separator:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a1f55fa066eee7b98a94c98fbecdbaeef">operator new[]</a> (std::size_t n)</td></tr>
<tr class="separator:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#ac0d7217fef84aacf42287c189423e15e">operator delete</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a42a7c29977989c72d78660bd487cc97e">operator delete[]</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac3e492bc10803354a683233d9beac134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_side_bits.html">RRSideBits</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#ac3e492bc10803354a683233d9beac134">sideBits</a> [2]</td></tr>
<tr class="separator:ac3e492bc10803354a683233d9beac134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65dbdcdcd13e0144786b0155a19e257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#af65dbdcdcd13e0144786b0155a19e257">diffuseReflectance</a></td></tr>
<tr class="separator:af65dbdcdcd13e0144786b0155a19e257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe268b97b9c20ea04a9e3dc32b0cf90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#affe268b97b9c20ea04a9e3dc32b0cf90">diffuseEmittance</a></td></tr>
<tr class="separator:affe268b97b9c20ea04a9e3dc32b0cf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7947eddba3141e8bba964120b788702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#af7947eddba3141e8bba964120b788702">specularReflectance</a></td></tr>
<tr class="separator:af7947eddba3141e8bba964120b788702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7395416c76de141f6f10463685aaec15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021">SpecularModel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a7395416c76de141f6f10463685aaec15">specularModel</a></td></tr>
<tr class="separator:a7395416c76de141f6f10463685aaec15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8eb43509946e07c2898a4a7dadcf6c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#aa8eb43509946e07c2898a4a7dadcf6c5">specularShininess</a></td></tr>
<tr class="separator:aa8eb43509946e07c2898a4a7dadcf6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92030797a57ede893acdf1c261a6d867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a92030797a57ede893acdf1c261a6d867">specularTransmittance</a></td></tr>
<tr class="separator:a92030797a57ede893acdf1c261a6d867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab055c59615597e919ba2e26b7fee6bcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#ab055c59615597e919ba2e26b7fee6bcb">specularTransmittanceInAlpha</a></td></tr>
<tr class="separator:ab055c59615597e919ba2e26b7fee6bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5800eb247a26767421bf8e96c3a4f789"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a5800eb247a26767421bf8e96c3a4f789">specularTransmittanceKeyed</a></td></tr>
<tr class="separator:a5800eb247a26767421bf8e96c3a4f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c2a1535710f848dc63d8cade108b36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#ac1c2a1535710f848dc63d8cade108b36">specularTransmittanceThreshold</a></td></tr>
<tr class="separator:ac1c2a1535710f848dc63d8cade108b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe54ee55c319115e6ee8b531d5b74db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a8fe54ee55c319115e6ee8b531d5b74db">specularTransmittanceMapInverted</a></td></tr>
<tr class="separator:a8fe54ee55c319115e6ee8b531d5b74db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522836289094cd08c538c96b6468d7ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a522836289094cd08c538c96b6468d7ea">specularTransmittanceBackground</a></td></tr>
<tr class="separator:a522836289094cd08c538c96b6468d7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37169500172587caf0e86fd99828704"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#ab37169500172587caf0e86fd99828704">refractionIndex</a></td></tr>
<tr class="separator:ab37169500172587caf0e86fd99828704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55051223906fd153b21876cbb9948973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a55051223906fd153b21876cbb9948973">bumpMap</a></td></tr>
<tr class="separator:a55051223906fd153b21876cbb9948973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f136370429f57ed85c280a767fd190"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#af0f136370429f57ed85c280a767fd190">bumpMapTypeHeight</a></td></tr>
<tr class="separator:af0f136370429f57ed85c280a767fd190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886b33be84a35b0bd5e127565a7920c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a886b33be84a35b0bd5e127565a7920c6">lightmap</a></td></tr>
<tr class="separator:a886b33be84a35b0bd5e127565a7920c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d0db9f896f211b2cc0e9bdecc95b27"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a61d0db9f896f211b2cc0e9bdecc95b27">minimalQualityForPointMaterials</a></td></tr>
<tr class="separator:a61d0db9f896f211b2cc0e9bdecc95b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174341e733dc3d4c1903bf53e340b1a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_string.html">RRString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a174341e733dc3d4c1903bf53e340b1a3">name</a></td></tr>
<tr class="separator:a174341e733dc3d4c1903bf53e340b1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21973fb2b69bb618fae28b979b466367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_material.html#a21973fb2b69bb618fae28b979b466367">preview</a></td></tr>
<tr class="separator:a21973fb2b69bb618fae28b979b466367"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html">rr::RRUniformlyAllocatedNonCopyable</a></td></tr>
<tr class="memitem:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a2fb6eae4adda7ad435a7aa482d1005cd">RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a7c05e32bc9c7a711d579fc328cb3392a">~RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Description of material properties of a surface. </p>
<p>It is a set of common material properties relevant for global illumination solver. It is not necessarily complete material description, custom renderers can use additional custom information stored elsewhere.</p>
<p>Textures are owned and deleted by material. To change texture on the fly, delete old one before assigning new one. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a019c36ffac127766dff920a9645dee37" name="a019c36ffac127766dff920a9645dee37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019c36ffac127766dff920a9645dee37">&#9670;&#160;</a></span>UniformTextureAction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structrr_1_1_r_r_material.html#a019c36ffac127766dff920a9645dee37">rr::RRMaterial::UniformTextureAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What to do with completely uniform textures (single color). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a019c36ffac127766dff920a9645dee37afa6b50374026b9b5de20887c41b1f8c4" name="a019c36ffac127766dff920a9645dee37afa6b50374026b9b5de20887c41b1f8c4"></a>UTA_KEEP&#160;</td><td class="fielddoc"><p>Keep uniform texture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a019c36ffac127766dff920a9645dee37a1be55975782b82e2a2313c9046ca636b" name="a019c36ffac127766dff920a9645dee37a1be55975782b82e2a2313c9046ca636b"></a>UTA_DELETE&#160;</td><td class="fielddoc"><p>Delete uniform texture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a019c36ffac127766dff920a9645dee37a20d35e54ea8f7ad32470eb2518860742" name="a019c36ffac127766dff920a9645dee37a20d35e54ea8f7ad32470eb2518860742"></a>UTA_NULL&#160;</td><td class="fielddoc"><p>nullptr pointer to uniform texture, but don't delete it. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0d06d97a2a6ca6ce60f84c927d884021" name="a0d06d97a2a6ca6ce60f84c927d884021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d06d97a2a6ca6ce60f84c927d884021">&#9670;&#160;</a></span>SpecularModel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021">rr::RRMaterial::SpecularModel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0d06d97a2a6ca6ce60f84c927d884021aab4706266a729d385f25e89b6bb91d95" name="a0d06d97a2a6ca6ce60f84c927d884021aab4706266a729d385f25e89b6bb91d95"></a>PHONG&#160;</td><td class="fielddoc"><p>as in <a href="http://en.wikipedia.org/wiki/Phong_shading">http://en.wikipedia.org/wiki/Phong_shading</a> (shininess in 1..inf) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d06d97a2a6ca6ce60f84c927d884021a64133b500d5aecf2dceb02255e6c981c" name="a0d06d97a2a6ca6ce60f84c927d884021a64133b500d5aecf2dceb02255e6c981c"></a>BLINN_PHONG&#160;</td><td class="fielddoc"><p>as in <a href="http://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model">http://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model</a> (shininess in 1..inf) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d06d97a2a6ca6ce60f84c927d884021a48d56156d0fef77ae7c7df0759dfeac9" name="a0d06d97a2a6ca6ce60f84c927d884021a48d56156d0fef77ae7c7df0759dfeac9"></a>TORRANCE_SPARROW&#160;</td><td class="fielddoc"><p>as in Zara J.: Pocitacova grafika (1992) (roughness in 0..1) </p>
</td></tr>
<tr><td class="fieldname"><a id="a0d06d97a2a6ca6ce60f84c927d884021a7d02228f46b14da5a7f89a1fa08a8a27" name="a0d06d97a2a6ca6ce60f84c927d884021a7d02228f46b14da5a7f89a1fa08a8a27"></a>BLINN_TORRANCE_SPARROW&#160;</td><td class="fielddoc"><p>as in <a href="http://www.siggraph.org/education/materials/HyperGraph/illumin/specular_highlights/blinn_model_for_specular_reflect_1.htm">http://www.siggraph.org/education/materials/HyperGraph/illumin/specular_highlights/blinn_model_for_specular_reflect_1.htm</a> (roughness in 0..1) </p>
</td></tr>
</table>

</div>
</div>
<a id="a0bacb808ef8c3999719f9faa401f3645" name="a0bacb808ef8c3999719f9faa401f3645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bacb808ef8c3999719f9faa401f3645">&#9670;&#160;</a></span>BrdfType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645">rr::RRMaterial::BrdfType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0bacb808ef8c3999719f9faa401f3645a4a87f94fb3294472b453335f9198d352" name="a0bacb808ef8c3999719f9faa401f3645a4a87f94fb3294472b453335f9198d352"></a>BRDF_NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0bacb808ef8c3999719f9faa401f3645aed01a760226c0b20c2a9e89ff327e725" name="a0bacb808ef8c3999719f9faa401f3645aed01a760226c0b20c2a9e89ff327e725"></a>BRDF_DIFFUSE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0bacb808ef8c3999719f9faa401f3645ac78aeea35d05cd47038897396fc9fa75" name="a0bacb808ef8c3999719f9faa401f3645ac78aeea35d05cd47038897396fc9fa75"></a>BRDF_SPECULAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0bacb808ef8c3999719f9faa401f3645afc21aad4f0ccb5da21e90cbf53009a92" name="a0bacb808ef8c3999719f9faa401f3645afc21aad4f0ccb5da21e90cbf53009a92"></a>BRDF_TRANSMIT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0bacb808ef8c3999719f9faa401f3645a7f0f7c9e358bf4063cffb47a14de393f" name="a0bacb808ef8c3999719f9faa401f3645a7f0f7c9e358bf4063cffb47a14de393f"></a>BRDF_ALL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0bacb808ef8c3999719f9faa401f3645ac9adbc14f518bed94f25e76fc96efbce" name="a0bacb808ef8c3999719f9faa401f3645ac9adbc14f518bed94f25e76fc96efbce"></a>NUM_BRDFS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a71b652ef78d2bfd1b57d4dddcaf7ee11" name="a71b652ef78d2bfd1b57d4dddcaf7ee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b652ef78d2bfd1b57d4dddcaf7ee11">&#9670;&#160;</a></span>RRMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rr::RRMaterial::RRMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor, initializes only pointers in material, call <a class="el" href="structrr_1_1_r_r_material.html#a1c44c8847b5703ccadeeb4b1b713cd0d" title="Resets material to fully diffuse gray (50% reflected, 50% absorbed).">reset()</a> to initialize the rest of data. </p>

</div>
</div>
<a id="af42382174168f3669064bea10d7c2ed9" name="af42382174168f3669064bea10d7c2ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42382174168f3669064bea10d7c2ed9">&#9670;&#160;</a></span>~RRMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rr::RRMaterial::~RRMaterial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes textures (yes, textures are owned by <a class="el" href="structrr_1_1_r_r_material.html" title="Description of material properties of a surface.">RRMaterial</a>). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a748554f6119e030ee402e41bc8d0a953" name="a748554f6119e030ee402e41bc8d0a953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748554f6119e030ee402e41bc8d0a953">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_material.html">RRMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies given material to this material. </p>
<p>Don't call it from multiple threads at the same time, it is thread unsafe under very rare circumstances (that's why we didn't make it "operator =", people expect safety in assignment). </p>

</div>
</div>
<a id="ab32d11781eaa2e199bf5ba85093ae336" name="ab32d11781eaa2e199bf5ba85093ae336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32d11781eaa2e199bf5ba85093ae336">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_material.html">RRMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if both materials look the same (and use the same textures). </p>

</div>
</div>
<a id="a1c44c8847b5703ccadeeb4b1b713cd0d" name="a1c44c8847b5703ccadeeb4b1b713cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c44c8847b5703ccadeeb4b1b713cd0d">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::reset </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twoSided</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets material to fully diffuse gray (50% reflected, 50% absorbed). </p>
<p>Also behaviour of both front and back side (sideBits) is reset to defaults.</p><ul>
<li>Back side of 1-sided material is not rendered and it does not emit or reflect light.</li>
<li>Back side of 1-sided material stops light: Imagine interior with 1-sided walls. Skylight should not get in through back sides od walls. Photons that hit back side are removed from simulation.</li>
<li>However, back side of 1-sided material allows transmittance and refraction: Imagine previous example with alpha-keyed window in 1-sided wall. Skylight should get through window in both directions. It gets through according to material transmittance and refraction index.</li>
<li>Back side of 1-sided material does not emit or reflect light.</li>
<li>Sides of 2-sided material behave nearly identically, only back side doesn't have diffuse reflection.</li>
</ul>
<p>Sidedness of the most common materials:</p><ul>
<li>glass sphere or any other closed object should be 1-sided, light refracts differently when front and back sides are hit</li>
<li>glass window should be made of single 2-sided face, we simulate multiple bounces between virtual front and back sides, light refracts identically from both sides</li>
</ul>
<p>Illumination produced by updateLightmap[s]() for faces with 2-sided material depends on solver. Realtime solvers sum illumination of both sides, offline solver outputs front side illumination. (Changing offline solver to work like realtime one would probably create more confusion than it would fix, it's not clear how directional lightmaps would look etc.) </p>

</div>
</div>
<a id="a6a483b5fae5b768b2a33916f13a64044" name="a6a483b5fae5b768b2a33916f13a64044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a483b5fae5b768b2a33916f13a64044">&#9670;&#160;</a></span>updateColorsFromTextures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::updateColorsFromTextures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_material.html#a019c36ffac127766dff920a9645dee37">UniformTextureAction</a>&#160;</td>
          <td class="paramname"><em>uniformTextureAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateEvenFromStubs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers information from textures, updates color for all Properties with texture. Updates also minimalQualityForPointMaterials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorSpace</td><td>Textures are expected in custom scale of this colorSpace. Average colors are computed in the same scale. Function would work even with colorSpace=nullptr, and it would be faster, but computed averages would be slightly incorrect, and minimalQualityForPointMaterials would be much lower, slowing down lightmap baking with unnecessary texture lookups. </td></tr>
    <tr><td class="paramname">uniformTextureAction</td><td>What to do with textures of constant color. Removing them may make rendering/calculations faster. </td></tr>
    <tr><td class="paramname">updateEvenFromStubs</td><td>True=updates color even if texture is a stub. Pass true if you don't know color; stub texture is also wrong, but at least they will match. Pass false if you know color and don't want it to be overwritten by stub. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27e8b003316560832adaaf3c5c24a5dd" name="a27e8b003316560832adaaf3c5c24a5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e8b003316560832adaaf3c5c24a5dd">&#9670;&#160;</a></span>createTexturesFromColors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRMaterial::createTexturesFromColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates stub 1x1 textures for properties without texture. </p>
<p>LightsprintCore fully supports materials without textures, and working with flat colors instead of textures is faster. But in case of need, this function would create 1x1 textures out of material colors. Don't call it unless you know what you are doing, risk of reduced performance. </p><dl class="section return"><dt>Returns</dt><dd>Number of textures created. </dd></dl>

</div>
</div>
<a id="af96941a3e852a9a83f04e64273299f57" name="af96941a3e852a9a83f04e64273299f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96941a3e852a9a83f04e64273299f57">&#9670;&#160;</a></span>updateKeyingFromTransmittance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::updateKeyingFromTransmittance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates specularTransmittanceKeyed. </p>
<p>Looks at specularTransmittance and tries to guess what user expects when realtime rendering, 1-bit keying or smooth blending. If you know what user prefers, set or clear specularTransmittanceKeyed yourself instead of calling this function. </p>

</div>
</div>
<a id="a424d06cbb411650eec0692e03d4c9610" name="a424d06cbb411650eec0692e03d4c9610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d06cbb411650eec0692e03d4c9610">&#9670;&#160;</a></span>updateSideBitsFromColors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::updateSideBitsFromColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates sideBits, clears bits with relevant color black. This may make rendering faster. </p>

</div>
</div>
<a id="a99a79045f5a86d8161fdb18cfd26ab29" name="a99a79045f5a86d8161fdb18cfd26ab29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a79045f5a86d8161fdb18cfd26ab29">&#9670;&#160;</a></span>updateBumpMapType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::updateBumpMapType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates bumpMapTypeHeight, tries to guess what type it is by looking at contents of bumpMap.texture. </p>

</div>
</div>
<a id="a9d53e392adf51dd36b70c532b5df4198" name="a9d53e392adf51dd36b70c532b5df4198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d53e392adf51dd36b70c532b5df4198">&#9670;&#160;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td>
          <td class="paramname"><em>redistributedPhotonsLimit</em> = <code>0.98f</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes material's colorLinear values to closest physically valid ones. Returns whether changes were made. </p>
<p>In physical scale, diffuse+specular+transmission must be below 1 (real world materials are below 0.98) and this function enforces it. We call it automatically from solver. In custom scale, real world materials have diffuse+specular+transmission higher (up to roughly 1.7), but we don't enforce this at all, color stays unchanged. </p>

</div>
</div>
<a id="aa330f3fce17cba4d35905a3de9f317ec" name="aa330f3fce17cba4d35905a3de9f317ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa330f3fce17cba4d35905a3de9f317ec">&#9670;&#160;</a></span>convertFromLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::convertFromLinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts material properties from physical to custom scale (colorLinear -&gt; color). </p>

</div>
</div>
<a id="ac6d9bae2f80925327c2f4f1d4b9f88f0" name="ac6d9bae2f80925327c2f4f1d4b9f88f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d9bae2f80925327c2f4f1d4b9f88f0">&#9670;&#160;</a></span>convertToLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::convertToLinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts material properties from custom to physical scale (color -&gt; colorLinear). </p>

</div>
</div>
<a id="a675d999f72d2462ed5fa42a4ea93d1c2" name="a675d999f72d2462ed5fa42a4ea93d1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675d999f72d2462ed5fa42a4ea93d1c2">&#9670;&#160;</a></span>needsBlending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::needsBlending </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if renderer needs blending to render the material. </p>

</div>
</div>
<a id="a5c6f375cd54e5ca57305982835dda241" name="a5c6f375cd54e5ca57305982835dda241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6f375cd54e5ca57305982835dda241">&#9670;&#160;</a></span>getResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::getResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_material_1_1_response.html">Response</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645">BrdfType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645a7f0f7c9e358bf4063cffb47a14de393f">BRDF_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates color of light exiting surface in response to incoming white light (dirIn, dirNormal, dirOut -&gt; colorOut) </p>

</div>
</div>
<a id="a962db9a5ad09406907f8fc1e47522d5b" name="a962db9a5ad09406907f8fc1e47522d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962db9a5ad09406907f8fc1e47522d5b">&#9670;&#160;</a></span>sampleResponse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRMaterial::sampleResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_material_1_1_response.html">Response</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>randomness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645">BrdfType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="structrr_1_1_r_r_material.html#a0bacb808ef8c3999719f9faa401f3645a7f0f7c9e358bf4063cffb47a14de393f">BRDF_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates direction and color of light exiting surface in response to incoming white light (dirNormal, dirOut -&gt; dirIn, colorOut, pdf, brdfType. </p>

</div>
</div>
<a id="a01de66f227b2d06e4f08dcffd7e55b5f" name="a01de66f227b2d06e4f08dcffd7e55b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01de66f227b2d06e4f08dcffd7e55b5f">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *&#160;</td>
          <td class="paramname"><em>textureLocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads first material from file, returns true on success. </p>

</div>
</div>
<a id="a37faea2f2b035ddd2c239a2e5294b0f8" name="a37faea2f2b035ddd2c239a2e5294b0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37faea2f2b035ddd2c239a2e5294b0f8">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves material to file, returns true on success. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac3e492bc10803354a683233d9beac134" name="ac3e492bc10803354a683233d9beac134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e492bc10803354a683233d9beac134">&#9670;&#160;</a></span>sideBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_side_bits.html">RRSideBits</a> rr::RRMaterial::sideBits[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines material behaviour for front (sideBits[0]) and back (sideBits[1]) side. </p>

</div>
</div>
<a id="af65dbdcdcd13e0144786b0155a19e257" name="af65dbdcdcd13e0144786b0155a19e257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65dbdcdcd13e0144786b0155a19e257">&#9670;&#160;</a></span>diffuseReflectance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a> rr::RRMaterial::diffuseReflectance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fraction of energy that is reflected in <a href="http://en.wikipedia.org/wiki/Diffuse_reflection">diffuse reflection</a> (each channel separately). </p>

</div>
</div>
<a id="affe268b97b9c20ea04a9e3dc32b0cf90" name="affe268b97b9c20ea04a9e3dc32b0cf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe268b97b9c20ea04a9e3dc32b0cf90">&#9670;&#160;</a></span>diffuseEmittance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a> rr::RRMaterial::diffuseEmittance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Radiant emittance in watts per square meter (each channel separately). (Adapters usually create materials in sRGB scale, so that this is screen color.) </p>

</div>
</div>
<a id="af7947eddba3141e8bba964120b788702" name="af7947eddba3141e8bba964120b788702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7947eddba3141e8bba964120b788702">&#9670;&#160;</a></span>specularReflectance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a> rr::RRMaterial::specularReflectance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fraction of energy that is reflected in <a href="http://en.wikipedia.org/wiki/Specular_reflection">specular reflection</a> (each channel separately). </p>
<p>When texture is set, its color is used as a specular reflectance color, and its alpha is used to modulate material's specularShininess/roughness. For alpha=1 there is no change in shininess/roughness. As alpha goes down to 0, shininess/roughness also goes down to its minimal value (1 or 0). Whether it is rough or shiny depends on specularModel. So in case of need, you can invert effect of alpha channel by changing specularModel. </p>

</div>
</div>
<a id="a7395416c76de141f6f10463685aaec15" name="a7395416c76de141f6f10463685aaec15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7395416c76de141f6f10463685aaec15">&#9670;&#160;</a></span>specularModel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_material.html#a0d06d97a2a6ca6ce60f84c927d884021">SpecularModel</a> rr::RRMaterial::specularModel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects what model / distribution function to use for specular reflectance. </p>

</div>
</div>
<a id="aa8eb43509946e07c2898a4a7dadcf6c5" name="aa8eb43509946e07c2898a4a7dadcf6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8eb43509946e07c2898a4a7dadcf6c5">&#9670;&#160;</a></span>specularShininess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> rr::RRMaterial::specularShininess</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpreted as shininess (0..inf) or roughness (0..1), according to specularModel. </p>

</div>
</div>
<a id="a92030797a57ede893acdf1c261a6d867" name="a92030797a57ede893acdf1c261a6d867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92030797a57ede893acdf1c261a6d867">&#9670;&#160;</a></span>specularTransmittance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a> rr::RRMaterial::specularTransmittance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fraction of energy that continues through surface (with direction possibly changed by refraction). </p>
<p>Whether light gets through translucent object, e.g. sphere, it depends on material sphere is made of</p><ul>
<li>standard 2sided material -&gt; ray gets through interacting with both front and back faces, creating correct caustics</li>
<li>standard 1sided material -&gt; ray is deleted when it hits back side of 1sided face</li>
<li>1sided material with sideBits[1].catchFrom=1 -&gt; ray gets through, interacting with front face, skipping back face, creating incorrect caustics</li>
</ul>
<p>Note that higher transmittance does not decrease reflectance and emittance, they are independent properties. There's single exception to this rule: [#39] when reading transmittance from texture, diffuseReflectance is reduced on the fly (multiplied by 1-specularTransmittance), because existing datasets expect it. So e.g. billboard cloud material has cloud shape controlled only by transparency texture, diffuse color can be uniform white.</p>
<p>Material with transparency stored in alpha of diffuse texture is initialized like </p><div class="fragment"><div class="line"><a class="code hl_variable" href="structrr_1_1_r_r_material.html#af65dbdcdcd13e0144786b0155a19e257">diffuseReflectance</a>.<a class="code hl_variable" href="structrr_1_1_r_r_material_1_1_property.html#a9aa48f559c4abe542f18397e509cd05a">texture</a> = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">RRBuffer::load</a>(foo);</div>
<div class="line"><a class="code hl_variable" href="structrr_1_1_r_r_material.html#a92030797a57ede893acdf1c261a6d867">specularTransmittance</a>.<a class="code hl_variable" href="structrr_1_1_r_r_material_1_1_property.html#a9aa48f559c4abe542f18397e509cd05a">texture</a> = <a class="code hl_variable" href="structrr_1_1_r_r_material.html#af65dbdcdcd13e0144786b0155a19e257">diffuseReflectance</a>.<a class="code hl_variable" href="structrr_1_1_r_r_material_1_1_property.html#a9aa48f559c4abe542f18397e509cd05a">texture</a>-&gt;<a class="code hl_function" href="classrr_1_1_r_r_buffer.html#a519e9eb6cd97c5ed9e47c23e6568ae05">createReference</a>();</div>
<div class="line"><a class="code hl_variable" href="structrr_1_1_r_r_material.html#ab055c59615597e919ba2e26b7fee6bcb">specularTransmittanceInAlpha</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="aclassrr_1_1_r_r_buffer_html_a519e9eb6cd97c5ed9e47c23e6568ae05"><div class="ttname"><a href="classrr_1_1_r_r_buffer.html#a519e9eb6cd97c5ed9e47c23e6568ae05">rr::RRBuffer::createReference</a></div><div class="ttdeci">virtual RRBuffer * createReference()=0</div><div class="ttdoc">Creates reference to the same buffer. Both buffer and reference must be deleted (in any order).</div></div>
<div class="ttc" id="aclassrr_1_1_r_r_buffer_html_abaf747f374a421d9f44b33aed8d201f1"><div class="ttname"><a href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">rr::RRBuffer::load</a></div><div class="ttdeci">static RRBuffer * load(const RRString &amp;filename, const char *cubeSideName[6]=nullptr, const RRFileLocator *fileLocator=nullptr)</div><div class="ttdoc">Loads buffer from disk to system memory.</div></div>
<div class="ttc" id="astructrr_1_1_r_r_material_1_1_property_html_a9aa48f559c4abe542f18397e509cd05a"><div class="ttname"><a href="structrr_1_1_r_r_material_1_1_property.html#a9aa48f559c4abe542f18397e509cd05a">rr::RRMaterial::Property::texture</a></div><div class="ttdeci">RRBuffer * texture</div><div class="ttdoc">Material property expressed as a texture or video.</div><div class="ttdef"><b>Definition</b> RRMaterial.h:108</div></div>
<div class="ttc" id="astructrr_1_1_r_r_material_html_a92030797a57ede893acdf1c261a6d867"><div class="ttname"><a href="structrr_1_1_r_r_material.html#a92030797a57ede893acdf1c261a6d867">rr::RRMaterial::specularTransmittance</a></div><div class="ttdeci">Property specularTransmittance</div><div class="ttdoc">Fraction of energy that continues through surface (with direction possibly changed by refraction).</div><div class="ttdef"><b>Definition</b> RRMaterial.h:253</div></div>
<div class="ttc" id="astructrr_1_1_r_r_material_html_ab055c59615597e919ba2e26b7fee6bcb"><div class="ttname"><a href="structrr_1_1_r_r_material.html#ab055c59615597e919ba2e26b7fee6bcb">rr::RRMaterial::specularTransmittanceInAlpha</a></div><div class="ttdeci">bool specularTransmittanceInAlpha</div><div class="ttdoc">Whether specular transmittance is in specularTransmittance.texture's Alpha (0=transparent) or in RGB ...</div><div class="ttdef"><b>Definition</b> RRMaterial.h:255</div></div>
<div class="ttc" id="astructrr_1_1_r_r_material_html_af65dbdcdcd13e0144786b0155a19e257"><div class="ttname"><a href="structrr_1_1_r_r_material.html#af65dbdcdcd13e0144786b0155a19e257">rr::RRMaterial::diffuseReflectance</a></div><div class="ttdeci">Property diffuseReflectance</div><div class="ttdoc">Fraction of energy that is reflected in diffuse reflection (each channel separately).</div><div class="ttdef"><b>Definition</b> RRMaterial.h:216</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab055c59615597e919ba2e26b7fee6bcb" name="ab055c59615597e919ba2e26b7fee6bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab055c59615597e919ba2e26b7fee6bcb">&#9670;&#160;</a></span>specularTransmittanceInAlpha</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::specularTransmittanceInAlpha</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether specular transmittance is in specularTransmittance.texture's Alpha (0=transparent) or in RGB (1,1,1=transparent). It is irrelevant when specularTransmittance.texture==nullptr. </p>

</div>
</div>
<a id="a5800eb247a26767421bf8e96c3a4f789" name="a5800eb247a26767421bf8e96c3a4f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5800eb247a26767421bf8e96c3a4f789">&#9670;&#160;</a></span>specularTransmittanceKeyed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::specularTransmittanceKeyed</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether 1-bit alpha keying is used instead of smooth alpha blending in realtime render. 1-bit alpha keying is faster but removes semi-translucency. Smooth alpha blend renders semi-translucency, but artifacts appear on meshes where semi-translucent faces overlap. </p>

</div>
</div>
<a id="ac1c2a1535710f848dc63d8cade108b36" name="ac1c2a1535710f848dc63d8cade108b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c2a1535710f848dc63d8cade108b36">&#9670;&#160;</a></span>specularTransmittanceThreshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> rr::RRMaterial::specularTransmittanceThreshold</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If specularTransmittanceKeyed, transmittance in 0..1 range is tested against this threshold. Values above threshold are rounded to 1 (transparent), values below threshold are rounded to 0 (opaque). </p>

</div>
</div>
<a id="a8fe54ee55c319115e6ee8b531d5b74db" name="a8fe54ee55c319115e6ee8b531d5b74db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe54ee55c319115e6ee8b531d5b74db">&#9670;&#160;</a></span>specularTransmittanceMapInverted</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::specularTransmittanceMapInverted</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether specular transmittance map is inverted. True = values read from map should be inverted before use. This inversion is implemented in getPointMaterial() and in shaders. </p>

</div>
</div>
<a id="a522836289094cd08c538c96b6468d7ea" name="a522836289094cd08c538c96b6468d7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a522836289094cd08c538c96b6468d7ea">&#9670;&#160;</a></span>specularTransmittanceBackground</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::specularTransmittanceBackground</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set, pathtracer renders material with color of environment, so it becomes kind of invisible, yet still receiving illumination and shadows. It's typically used on a plane under pathtraced car, surrounded only by environment map; results look like car casting shadows on environment. </p>

</div>
</div>
<a id="ab37169500172587caf0e86fd99828704" name="ab37169500172587caf0e86fd99828704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37169500172587caf0e86fd99828704">&#9670;&#160;</a></span>refractionIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> rr::RRMaterial::refractionIndex</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For 1-sided faces, it is refractive index of matter behind surface divided by refractive index of matter in front of surface (1-sided surfaces are treated as volume boundaries, this index tells what happens when light leaves matter in front of boundary and enters matter behind). For 2-sided faces, it is refractive index of matter inside thin layer divided by refractive index of matter around (2-sided surfaces are treated as thin layers made of different matter, renderer accounts for multiple front/back interreflection). Real world surfaces have index from 0.25 to 4. <a href="http://en.wikipedia.org/wiki/List_of_indices_of_refraction">Examples.</a> </p>

</div>
</div>
<a id="a55051223906fd153b21876cbb9948973" name="a55051223906fd153b21876cbb9948973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55051223906fd153b21876cbb9948973">&#9670;&#160;</a></span>bumpMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a> rr::RRMaterial::bumpMap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional bump map modulates surface normals. </p>
<p>RGB maps are interpreted as normal maps, grayscale maps (or the same map as diffuseReflectance.texture, or c@pture) as heightmaps. bumpMap.color.x is used as a multiplier of normal steepness, y multiplies height in parallax mapping, defaults are 1, negative values are legal. </p>

</div>
</div>
<a id="af0f136370429f57ed85c280a767fd190" name="af0f136370429f57ed85c280a767fd190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f136370429f57ed85c280a767fd190">&#9670;&#160;</a></span>bumpMapTypeHeight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRMaterial::bumpMapTypeHeight</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True = bump map is height/displacement map, false = bump map is normal map. </p>

</div>
</div>
<a id="a886b33be84a35b0bd5e127565a7920c6" name="a886b33be84a35b0bd5e127565a7920c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886b33be84a35b0bd5e127565a7920c6">&#9670;&#160;</a></span>lightmap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrr_1_1_r_r_material_1_1_property.html">Property</a> rr::RRMaterial::lightmap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional lightmaps/ambient maps. </p>
<p>lightmap.texcoord</p><ul>
<li>Texcoord channel with unwrap for lightmaps/ambient maps. To be used in <a class="el" href="classrr_1_1_r_r_mesh.html#acdf8219ae3df7e34f39f5827134697ea" title="Writes t-th triangle&#39;s uv mapping to out.">RRMesh::getTriangleMapping()</a>.</li>
<li>Note that for proper lighting, unwrap must have all coordinates in &lt;0..1&gt; range and triangles must not overlap. Unwrap can be imported or automatically generated by <a class="el" href="classrr_1_1_r_r_objects.html#a1995f293b3e08eaaa283765d37ecd03f" title="Rebuilds unwrap in all meshes of RRMeshArrays type.">RRObjects::buildUnwrap()</a>.</li>
</ul>
<p>lightmap.color</p><ul>
<li>Not used. Keep it set to 0.5.</li>
</ul>
<p>lightmap.texture</p><ul>
<li>Secondary location, it is usually nullptr, because we store lightmaps and ambient maps in separated layers in <a class="el" href="classrr_1_1_r_r_object_illumination.html" title="Data structure with object&#39;s illumination and more.">RRObjectIllumination</a>. However, some fileformats store them in ambient or lightmap slot in material. We use lightmap.texture only for smoother import from / export to such fileformats. After import, we move lightmaps from <a class="el" href="structrr_1_1_r_r_material.html" title="Description of material properties of a surface.">RRMaterial</a> to lightmap layer in <a class="el" href="classrr_1_1_r_r_object_illumination.html" title="Data structure with object&#39;s illumination and more.">RRObjectIllumination</a>. </li>
</ul>

</div>
</div>
<a id="a61d0db9f896f211b2cc0e9bdecc95b27" name="a61d0db9f896f211b2cc0e9bdecc95b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d0db9f896f211b2cc0e9bdecc95b27">&#9670;&#160;</a></span>minimalQualityForPointMaterials</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRMaterial::minimalQualityForPointMaterials</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hint/optimization for offline solver, material tells solver to use <a class="el" href="classrr_1_1_r_r_object.html#a6574562e2be602cc78b7be5ce6d2e6dc" title="Returns material description for point on object&#39;s surface, fills colorLinear with values read from t...">RRObject::getPointMaterial()</a> if desired lighting quality is equal or higher than this number. Inited to UINT_MAX (=never use point materials), automatically adjusted by <a class="el" href="structrr_1_1_r_r_material.html#a6a483b5fae5b768b2a33916f13a64044" title="Gathers information from textures, updates color for all Properties with texture. Updates also minima...">updateColorsFromTextures()</a>.</p>
<p>Warning: If you don't call <a class="el" href="structrr_1_1_r_r_material.html#a6a483b5fae5b768b2a33916f13a64044" title="Gathers information from textures, updates color for all Properties with texture. Updates also minima...">updateColorsFromTextures()</a>, make sure you adjust minimalQualityForPointMaterials on per-material basis. Keeping UINT_MAX would make keyed objects cast solid shadows to lightmaps. Setting always 0 would make lightmap build very slow.</p>
<p>Not used by realtime solver; you don't have to update it each time your realtime app changes texture. </p>

</div>
</div>
<a id="a174341e733dc3d4c1903bf53e340b1a3" name="a174341e733dc3d4c1903bf53e340b1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174341e733dc3d4c1903bf53e340b1a3">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_string.html">RRString</a> rr::RRMaterial::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional name of material. </p>
<p>If name starts with "water" and static normal map is set, realtime renderer animates mapping to simulate flow of waves. </p>

</div>
</div>
<a id="a21973fb2b69bb618fae28b979b466367" name="a21973fb2b69bb618fae28b979b466367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21973fb2b69bb618fae28b979b466367">&#9670;&#160;</a></span>preview</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a>* rr::RRMaterial::preview</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional image of material, for use e.g. by material library. It is owned by material, deleted in dtor. Not saved to .rrmaterial. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerr.html">rr</a></li><li class="navelem"><a class="el" href="structrr_1_1_r_r_material.html">RRMaterial</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
