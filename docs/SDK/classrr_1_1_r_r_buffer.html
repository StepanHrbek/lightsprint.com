<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LightsprintSDK: rr::RRBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LightsprintSDK<span id="projectnumber">&#160;2021.08.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrr_1_1_r_r_buffer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classrr_1_1_r_r_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rr::RRBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;RRBuffer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rr::RRBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrr_1_1_r_r_buffer.png" usemap="#rr::RRBuffer_map" alt=""/>
  <map id="rr::RRBuffer_map" name="rr::RRBuffer_map">
<area href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html" title="When used as base class, object copying is not allowed." alt="rr::RRUniformlyAllocatedNonCopyable" shape="rect" coords="0,56,227,80"/>
<area href="classrr_1_1_r_r_uniformly_allocated.html" title="When used as base class, delete works correctly without regard who calls it." alt="rr::RRUniformlyAllocated" shape="rect" coords="0,0,227,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_buffer_1_1_save_parameters.html">SaveParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae41a837feedc24b2eb9e9de0e0243655"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ae41a837feedc24b2eb9e9de0e0243655">Loader</a>(const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;<a class="el" href="classrr_1_1_r_r_buffer.html#af3387402c95ad7e36fc7eb35308ae3bd">filename</a>, const char *cubeSideName[6])</td></tr>
<tr class="separator:ae41a837feedc24b2eb9e9de0e0243655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe8b3f09548f638401b3a3442a5fd94"><td class="memItemLeft" align="right" valign="top">typedef bool()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#affe8b3f09548f638401b3a3442a5fd94">Saver</a>(<a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *buffer, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;filenameMask, const char *cubeSideName[6], const <a class="el" href="structrr_1_1_r_r_buffer_1_1_save_parameters.html">SaveParameters</a> *parameters)</td></tr>
<tr class="separator:affe8b3f09548f638401b3a3442a5fd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68ad47b71caf044ad51e0253226d1f3a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a68ad47b71caf044ad51e0253226d1f3a">reset</a> (<a class="el" href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286">RRBufferType</a> type, unsigned width, unsigned height, unsigned depth, <a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a> format, bool scaled, const unsigned char *data)=0</td></tr>
<tr class="separator:a68ad47b71caf044ad51e0253226d1f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad2c459d326158fe67262f2c339fc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a4bad2c459d326158fe67262f2c339fc5">setElement</a> (unsigned index, const <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;element, const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace)</td></tr>
<tr class="separator:a4bad2c459d326158fe67262f2c339fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc8345c84b4ca16df6e5d67b013f3a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286">RRBufferType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#aefc8345c84b4ca16df6e5d67b013f3a4">getType</a> () const =0</td></tr>
<tr class="separator:aefc8345c84b4ca16df6e5d67b013f3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d72ee78b712936868997bfd1c560bf"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#aa0d72ee78b712936868997bfd1c560bf">getWidth</a> () const =0</td></tr>
<tr class="separator:aa0d72ee78b712936868997bfd1c560bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae963d72b9c822332ce4225f57d4e62d3"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ae963d72b9c822332ce4225f57d4e62d3">getHeight</a> () const =0</td></tr>
<tr class="separator:ae963d72b9c822332ce4225f57d4e62d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be7fc0bd10c2c421800c05cfe21c907"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a1be7fc0bd10c2c421800c05cfe21c907">getDepth</a> () const =0</td></tr>
<tr class="separator:a1be7fc0bd10c2c421800c05cfe21c907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5263a007fcf8e8005088710dc825da66"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a5263a007fcf8e8005088710dc825da66">getNumElements</a> () const</td></tr>
<tr class="separator:a5263a007fcf8e8005088710dc825da66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48641ba47695da1e4f251b125323ab99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a48641ba47695da1e4f251b125323ab99">getFormat</a> () const =0</td></tr>
<tr class="separator:a48641ba47695da1e4f251b125323ab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06c280769d1d2d3972dafa4a52fd15e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ab06c280769d1d2d3972dafa4a52fd15e">getScaled</a> () const =0</td></tr>
<tr class="separator:ab06c280769d1d2d3972dafa4a52fd15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1e45e1cfb8c207b1cc897007a0c05c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a8d1e45e1cfb8c207b1cc897007a0c05c">getBufferBytes</a> () const</td></tr>
<tr class="separator:a8d1e45e1cfb8c207b1cc897007a0c05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e7eaa7224549b026c3bf9ea2b8feeb"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ad6e7eaa7224549b026c3bf9ea2b8feeb">getElementBits</a> () const</td></tr>
<tr class="separator:ad6e7eaa7224549b026c3bf9ea2b8feeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aec3ccb6d188679e1520da54bd50ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ac1aec3ccb6d188679e1520da54bd50ec">getElement</a> (unsigned index, const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace) const</td></tr>
<tr class="separator:ac1aec3ccb6d188679e1520da54bd50ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6e28b1ee3f0efeee0e70408a6db758"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a2d6e28b1ee3f0efeee0e70408a6db758">getElementAtPosition</a> (const <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;position, const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace, bool interpolated) const</td></tr>
<tr class="separator:a2d6e28b1ee3f0efeee0e70408a6db758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5959e60fd3fbb74726c78d34ce38a9b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a5959e60fd3fbb74726c78d34ce38a9b9">getElementAtDirection</a> (const <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;direction, const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace) const</td></tr>
<tr class="separator:a5959e60fd3fbb74726c78d34ce38a9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa62f66d38ac68490fa2ee09847562cf"><td class="memItemLeft" align="right" valign="top">virtual unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#aaa62f66d38ac68490fa2ee09847562cf">lock</a> (<a class="el" href="namespacerr.html#a9c825752da122dbe1cb0b8c7b0734a4b">RRBufferLock</a> lock)</td></tr>
<tr class="separator:aaa62f66d38ac68490fa2ee09847562cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bda3456f80fa506e81de5da0aa4686b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a9bda3456f80fa506e81de5da0aa4686b">unlock</a> ()</td></tr>
<tr class="separator:a9bda3456f80fa506e81de5da0aa4686b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f95450f68468f4dbc7a4a52b15a03d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a68f95450f68468f4dbc7a4a52b15a03d">update</a> ()</td></tr>
<tr class="separator:a68f95450f68468f4dbc7a4a52b15a03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364554765fdf63c89f79e4288df4106"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ae364554765fdf63c89f79e4288df4106">play</a> ()</td></tr>
<tr class="separator:ae364554765fdf63c89f79e4288df4106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace10501187a4c9a4427effa3a089234c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ace10501187a4c9a4427effa3a089234c">stop</a> ()</td></tr>
<tr class="separator:ace10501187a4c9a4427effa3a089234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654f288149676fec913e924a90e32429"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a654f288149676fec913e924a90e32429">pause</a> ()</td></tr>
<tr class="separator:a654f288149676fec913e924a90e32429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83252ab8a42ef9b001d189387405833"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ac83252ab8a42ef9b001d189387405833">seek</a> (float secondsFromStart)</td></tr>
<tr class="separator:ac83252ab8a42ef9b001d189387405833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a402c4397926530d3321bc3e9b51a78"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a1a402c4397926530d3321bc3e9b51a78">getDuration</a> () const</td></tr>
<tr class="separator:a1a402c4397926530d3321bc3e9b51a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af619ae8a5e0a864d068ec470b161a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a4af619ae8a5e0a864d068ec470b161a0">RRBuffer</a> ()</td></tr>
<tr class="separator:a4af619ae8a5e0a864d068ec470b161a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9d7ea0dd1d49f10d54baea0adff8bb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#aab9d7ea0dd1d49f10d54baea0adff8bb">~RRBuffer</a> ()</td></tr>
<tr class="separator:aab9d7ea0dd1d49f10d54baea0adff8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a9e566f3379d03922b049e2455ae6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a012a9e566f3379d03922b049e2455ae6">isStub</a> ()</td></tr>
<tr class="separator:a012a9e566f3379d03922b049e2455ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519e9eb6cd97c5ed9e47c23e6568ae05"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a519e9eb6cd97c5ed9e47c23e6568ae05">createReference</a> ()=0</td></tr>
<tr class="separator:a519e9eb6cd97c5ed9e47c23e6568ae05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2afc9f5686a9e3c7561ad38cfe2ee5"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a3d2afc9f5686a9e3c7561ad38cfe2ee5">getReferenceCount</a> ()=0</td></tr>
<tr class="separator:a3d2afc9f5686a9e3c7561ad38cfe2ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823f05919132803eff44b0d1a4a90358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a823f05919132803eff44b0d1a4a90358">createCopy</a> ()</td></tr>
<tr class="separator:a823f05919132803eff44b0d1a4a90358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabe5ccd2c8c759e331a42dc9612aa10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#aeabe5ccd2c8c759e331a42dc9612aa10">createCopy</a> (<a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a> format, bool scaled, const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace) const</td></tr>
<tr class="separator:aeabe5ccd2c8c759e331a42dc9612aa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c7d8c26930571bdf82d785e2180007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a24c7d8c26930571bdf82d785e2180007">copyElementsTo</a> (<a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *destination, const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace) const</td></tr>
<tr class="separator:a24c7d8c26930571bdf82d785e2180007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af684d7f3f6a7868f0f83b77c55771789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#af684d7f3f6a7868f0f83b77c55771789">createEquirectangular</a> ()</td></tr>
<tr class="separator:af684d7f3f6a7868f0f83b77c55771789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80368d95b5968cab97edac824a1b2752"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a80368d95b5968cab97edac824a1b2752">reload</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;<a class="el" href="classrr_1_1_r_r_buffer.html#af3387402c95ad7e36fc7eb35308ae3bd">filename</a>, const char *cubeSideName[6], const <a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *fileLocator)</td></tr>
<tr class="separator:a80368d95b5968cab97edac824a1b2752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef633298f526aa5c400c323bdba9e05b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#aef633298f526aa5c400c323bdba9e05b">save</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;filenameMask, const char *cubeSideName[6]=nullptr, const <a class="el" href="structrr_1_1_r_r_buffer_1_1_save_parameters.html">SaveParameters</a> *saveParameters=nullptr)</td></tr>
<tr class="separator:aef633298f526aa5c400c323bdba9e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e73e6b54639577d0184f9f1a31d2a72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a4e73e6b54639577d0184f9f1a31d2a72">setFormat</a> (<a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a> newFormat)</td></tr>
<tr class="separator:a4e73e6b54639577d0184f9f1a31d2a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad693e7bdc351fb8fb2332eb597878681"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ad693e7bdc351fb8fb2332eb597878681">setFormatFloats</a> ()</td></tr>
<tr class="separator:ad693e7bdc351fb8fb2332eb597878681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272ff9338e1156f6d534ff86f8bc05b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a272ff9338e1156f6d534ff86f8bc05b5">clear</a> (<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> clearColor=<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>(0))</td></tr>
<tr class="separator:a272ff9338e1156f6d534ff86f8bc05b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef1c2b06693f9716a018f994e7f01c4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#aeef1c2b06693f9716a018f994e7f01c4">invert</a> ()</td></tr>
<tr class="separator:aeef1c2b06693f9716a018f994e7f01c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b7be5cb492c4fa649f7af351b134f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a08b7be5cb492c4fa649f7af351b134f6">multiplyAdd</a> (<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> multiplier, <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> addend)</td></tr>
<tr class="separator:a08b7be5cb492c4fa649f7af351b134f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2649c5f3b47010fda9a93200a5b9ee27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a2649c5f3b47010fda9a93200a5b9ee27">flip</a> (bool flipX, bool flipY, bool flipZ)</td></tr>
<tr class="separator:a2649c5f3b47010fda9a93200a5b9ee27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981b3c615f9a2952ee8e279275e57dab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a981b3c615f9a2952ee8e279275e57dab">rotate</a> (int degrees, unsigned depthLayer=0)</td></tr>
<tr class="separator:a981b3c615f9a2952ee8e279275e57dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4808a9a1510c02030d43b2f88eac30"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a3d4808a9a1510c02030d43b2f88eac30">brightnessGamma</a> (<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> brightness, <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> gamma)</td></tr>
<tr class="separator:a3d4808a9a1510c02030d43b2f88eac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2c8282b3ac02f9d9dc4d9c5df2d9cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ada2c8282b3ac02f9d9dc4d9c5df2d9cb">getMinMax</a> (<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> *mini, <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> *maxi)</td></tr>
<tr class="separator:ada2c8282b3ac02f9d9dc4d9c5df2d9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b011e04088bdbacf855fc5dd6be946"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a27b011e04088bdbacf855fc5dd6be946">lightmapSmooth</a> (float sigma, bool wrap, const class <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *object)</td></tr>
<tr class="separator:a27b011e04088bdbacf855fc5dd6be946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa72eaa672fe981a6067f3ced9f2925b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#afa72eaa672fe981a6067f3ced9f2925b">lightmapGrowForBilinearInterpolation</a> (bool wrap)</td></tr>
<tr class="separator:afa72eaa672fe981a6067f3ced9f2925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dcdb6c4a1a70f6d936115e271fb22e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a05dcdb6c4a1a70f6d936115e271fb22e">lightmapGrow</a> (unsigned distance, bool wrap, bool &amp;aborting)</td></tr>
<tr class="separator:a05dcdb6c4a1a70f6d936115e271fb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075999b0c27d73a53cbdbc96fd9000f3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a075999b0c27d73a53cbdbc96fd9000f3">lightmapFillBackground</a> (<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> backgroundColor)</td></tr>
<tr class="separator:a075999b0c27d73a53cbdbc96fd9000f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrr_1_1_r_r_uniformly_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrr_1_1_r_r_uniformly_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated.html">rr::RRUniformlyAllocated</a></td></tr>
<tr class="memitem:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a073b837b152a4c54b8b581bd2e82ec08">operator new</a> (std::size_t n)</td></tr>
<tr class="separator:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a1f55fa066eee7b98a94c98fbecdbaeef">operator new[]</a> (std::size_t n)</td></tr>
<tr class="separator:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#ac0d7217fef84aacf42287c189423e15e">operator delete</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a42a7c29977989c72d78660bd487cc97e">operator delete[]</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3e3d651ad26701f619da5017646793c8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a3e3d651ad26701f619da5017646793c8">create</a> (<a class="el" href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286">RRBufferType</a> type, unsigned width, unsigned height, unsigned depth, <a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a> format, bool scaled, const unsigned char *data)</td></tr>
<tr class="separator:a3e3d651ad26701f619da5017646793c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825eea66120b2627c4e77af967cfeb08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a825eea66120b2627c4e77af967cfeb08">createSky</a> (const <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;upper=<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>(1), const <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;lower=<a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>(1), bool scaled=true)</td></tr>
<tr class="separator:a825eea66120b2627c4e77af967cfeb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d37f93f2c5195534a675bca771a7fa6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a4d37f93f2c5195534a675bca771a7fa6">createEnvironmentBlend</a> (<a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *environment0, <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *environment1, <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> angleRad0, <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> angleRad1, <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> blendFactor)</td></tr>
<tr class="separator:a4d37f93f2c5195534a675bca771a7fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf747f374a421d9f44b33aed8d201f1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">load</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;<a class="el" href="classrr_1_1_r_r_buffer.html#af3387402c95ad7e36fc7eb35308ae3bd">filename</a>, const char *cubeSideName[6]=nullptr, const <a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *fileLocator=nullptr)</td></tr>
<tr class="separator:abaf747f374a421d9f44b33aed8d201f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331f938c90e3cc35bd99c20f109ead5a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a331f938c90e3cc35bd99c20f109ead5a">loadCube</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;<a class="el" href="classrr_1_1_r_r_buffer.html#af3387402c95ad7e36fc7eb35308ae3bd">filename</a>, const <a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *fileLocator=nullptr)</td></tr>
<tr class="separator:a331f938c90e3cc35bd99c20f109ead5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04797b91affe1d32861bbe782dad4173"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a04797b91affe1d32861bbe782dad4173">registerLoader</a> (const char *extensions, <a class="el" href="classrr_1_1_r_r_buffer.html#ae41a837feedc24b2eb9e9de0e0243655">Loader</a> *loader)</td></tr>
<tr class="separator:a04797b91affe1d32861bbe782dad4173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233d79caea9581fe933c01846715510b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a233d79caea9581fe933c01846715510b">registerSaver</a> (const char *extensions, <a class="el" href="classrr_1_1_r_r_buffer.html#affe8b3f09548f638401b3a3442a5fd94">Saver</a> *saver)</td></tr>
<tr class="separator:a233d79caea9581fe933c01846715510b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96317b76fbd7c8dcd312729e48f50a63"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a96317b76fbd7c8dcd312729e48f50a63">getSupportedLoaderExtensions</a> ()</td></tr>
<tr class="separator:a96317b76fbd7c8dcd312729e48f50a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a14a2b79146595275e7f362efb1e1b2"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a1a14a2b79146595275e7f362efb1e1b2">getSupportedSaverExtensions</a> ()</td></tr>
<tr class="separator:a1a14a2b79146595275e7f362efb1e1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af3387402c95ad7e36fc7eb35308ae3bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_string.html">RRString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#af3387402c95ad7e36fc7eb35308ae3bd">filename</a></td></tr>
<tr class="separator:af3387402c95ad7e36fc7eb35308ae3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab902a36bd1549c099002c35ed9d108be"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#ab902a36bd1549c099002c35ed9d108be">version</a></td></tr>
<tr class="separator:ab902a36bd1549c099002c35ed9d108be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0d5382afd2e785964961c44a65d8a1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a4b0d5382afd2e785964961c44a65d8a1">customData</a></td></tr>
<tr class="separator:a4b0d5382afd2e785964961c44a65d8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6385adeacc29bdb79b3ad1087a27ee95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_buffer.html#a6385adeacc29bdb79b3ad1087a27ee95">deleteFromCache</a> ()</td></tr>
<tr class="separator:a6385adeacc29bdb79b3ad1087a27ee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html">rr::RRUniformlyAllocatedNonCopyable</a></td></tr>
<tr class="memitem:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a2fb6eae4adda7ad435a7aa482d1005cd">RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a7c05e32bc9c7a711d579fc328cb3392a">~RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Buffer, array of elements. </p>
<h1><a class="anchor" id="buf_types"></a>
Buffer types</h1>
<ul>
<li>1-dimensional buffers are used for vertex buffers.</li>
<li>2-dimensional buffers are used for 2d textures and videos.</li>
<li>3-dimensional buffers are used for cube textures.</li>
</ul>
<h1><a class="anchor" id="buf_dx_gl"></a>
Using buffers in OpenGL/DirectX</h1>
<p>Two approaches exist for using buffers in DirectX/OpenGL renderer</p><ol type="1">
<li>Use existing <a class="el" href="classrr_1_1_r_r_buffer.html" title="Buffer, array of elements.">RRBuffer</a> that stores data in system memory. Each time buffer version changes, copy data from buffer to DirectX/OpenGL texture. <a class="el" href="namespacerr__gl.html#a3519646a7143ca3ecccf5e365260b390" title="Converts rr::RRBuffer to Texture so it can be immediately used as a texture in OpenGL.">rr_gl::getTexture()</a> implements this behaviour, it is flexible and fast.</li>
<li>Subclass <a class="el" href="classrr_1_1_r_r_buffer.html" title="Buffer, array of elements.">RRBuffer</a>, make it store data directly in DirectX/OpenGL texture. It is less flexible, but it saves system memory and it could be faster if used with care. For an example of <a class="el" href="classrr_1_1_r_r_buffer.html" title="Buffer, array of elements.">RRBuffer</a> subclass, see e.g. RRBufferDirectShow implemented in LightsprintIO.</li>
</ol>
<h1><a class="anchor" id="buf_update"></a>
How solvers update buffers</h1>
<p>When implementing custom <a class="el" href="classrr_1_1_r_r_buffer.html" title="Buffer, array of elements.">RRBuffer</a> subclass, it may help to know how solvers update buffers</p><ul>
<li>vertex buffers are updated by lock(BL_DISCARD_AND_WRITE), with fallback to <a class="el" href="classrr_1_1_r_r_buffer.html#a4bad2c459d326158fe67262f2c339fc5" title="Sets single element in buffer. Value is converted to current buffer format.">setElement()</a> if <a class="el" href="classrr_1_1_r_r_buffer.html#aaa62f66d38ac68490fa2ee09847562cf" title="Locks the buffer for accessing array of all elements at once. Not mandatory, may return nullptr.">lock()</a> fails</li>
<li>cube maps are updated by lock(BL_DISCARD_AND_WRITE), with fallback to <a class="el" href="classrr_1_1_r_r_buffer.html#a4bad2c459d326158fe67262f2c339fc5" title="Sets single element in buffer. Value is converted to current buffer format.">setElement()</a> if <a class="el" href="classrr_1_1_r_r_buffer.html#aaa62f66d38ac68490fa2ee09847562cf" title="Locks the buffer for accessing array of all elements at once. Not mandatory, may return nullptr.">lock()</a> fails</li>
<li>lightmaps are updated by <a class="el" href="classrr_1_1_r_r_buffer.html#a4bad2c459d326158fe67262f2c339fc5" title="Sets single element in buffer. Value is converted to current buffer format.">setElement()</a></li>
<li><a class="el" href="classrr_1_1_r_r_buffer.html#a68ad47b71caf044ad51e0253226d1f3a" title="Sets size and contents of buffer.">reset()</a> is never called, so your type, size, format and scale are preserved</li>
</ul>
<h1><a class="anchor" id="buf_sharing"></a>
How buffers are cached/shared</h1>
<p>Buffers loaded from disk may be shared to save memory and time. Sharing is automatic, you mostly don't have to care about it, but it's still good to know the rules, they are shown by example: </p><div class="fragment"><div class="line">a = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">RRBuffer::load</a>(<span class="stringliteral">&quot;foo/bar.avi&quot;</span>);  <span class="comment">// a loaded from disk</span></div>
<div class="line">b = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">RRBuffer::load</a>(<span class="stringliteral">&quot;foo/bar.avi&quot;</span>);  <span class="comment">// b found in cache, b==a</span></div>
<div class="line">c = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">RRBuffer::load</a>(<span class="stringliteral">&quot;foo\\bar.avi&quot;</span>); <span class="comment">// c loaded from disk, because filename differs</span></div>
<div class="line">a-&gt;setElement(0,<a class="code hl_struct" href="structrr_1_1_r_r_vec4.html">RRVec4</a>(0));         <span class="comment">// modifies content of a==b</span></div>
<div class="line">d = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">RRBuffer::load</a>(<span class="stringliteral">&quot;foo/bar.avi&quot;</span>);  <span class="comment">// d loaded from disk, a==b removed from cache, because content differs</span></div>
<div class="line"><span class="keyword">delete</span> a;                           <span class="comment">// no memory freed, it&#39;s still in use by b</span></div>
<div class="line"><span class="keyword">delete</span> b;                           <span class="comment">// memory freed</span></div>
<div class="line"><span class="keyword">delete</span> d;                           <span class="comment">// no memory freed, d stays in cache</span></div>
<div class="line">e = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">RRBuffer::load</a>(<span class="stringliteral">&quot;foo/bar.avi&quot;</span>);  <span class="comment">// e found in cache, e==d</span></div>
<div class="line">e-&gt;play();                          <span class="comment">// starts playing image to buffer, audio to speakers</span></div>
<div class="line"><span class="comment">//e-&gt;stop();                        // here we forget to stop</span></div>
<div class="line"><span class="keyword">delete</span> e;                           <span class="comment">// no memory freed, e stays in cache, still playing to speakers</span></div>
<div class="line"><span class="comment">// someone overwrites foo/bar.avi</span></div>
<div class="line">f = <a class="code hl_function" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">RRBuffer::load</a>(<span class="stringliteral">&quot;foo/bar.avi&quot;</span>);  <span class="comment">// f loaded from disk, e deleted from cache, memory freed, stops playing, because file&#39;s write time did change</span></div>
<div class="line">                                    <span class="comment">// (note that file&#39;s write time is not tracked for cubemaps stored in 6 files, they are assumed to never change on disk, let us know if it is a problem)</span></div>
<div class="ttc" id="aclassrr_1_1_r_r_buffer_html_abaf747f374a421d9f44b33aed8d201f1"><div class="ttname"><a href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1">rr::RRBuffer::load</a></div><div class="ttdeci">static RRBuffer * load(const RRString &amp;filename, const char *cubeSideName[6]=nullptr, const RRFileLocator *fileLocator=nullptr)</div><div class="ttdoc">Loads buffer from disk to system memory.</div></div>
<div class="ttc" id="astructrr_1_1_r_r_vec4_html"><div class="ttname"><a href="structrr_1_1_r_r_vec4.html">rr::RRVec4</a></div><div class="ttdoc">Vector of 4 real numbers. Operators use all 4 components.</div><div class="ttdef"><b>Definition</b> RRMath.h:208</div></div>
</div><!-- fragment --><h1><a class="anchor" id="buf_capture"></a>
Live video capture</h1>
<p>LightsprintIO implements support for live video capture into 2d buffer. With LightsprintIO callbacks registered, live video capture is started by opening imaginary file "c\@pture". </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae41a837feedc24b2eb9e9de0e0243655" name="ae41a837feedc24b2eb9e9de0e0243655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41a837feedc24b2eb9e9de0e0243655">&#9670;&#160;</a></span>Loader</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *() rr::RRBuffer::Loader(const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;<a class="el" href="classrr_1_1_r_r_buffer.html#af3387402c95ad7e36fc7eb35308ae3bd">filename</a>, const char *cubeSideName[6])</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of user defined function that loads content from file into new buffer. </p>

</div>
</div>
<a id="affe8b3f09548f638401b3a3442a5fd94" name="affe8b3f09548f638401b3a3442a5fd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe8b3f09548f638401b3a3442a5fd94">&#9670;&#160;</a></span>Saver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool() rr::RRBuffer::Saver(<a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *buffer, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;filenameMask, const char *cubeSideName[6], const <a class="el" href="structrr_1_1_r_r_buffer_1_1_save_parameters.html">SaveParameters</a> *parameters)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of user defined function that saves buffer contents to file. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4af619ae8a5e0a864d068ec470b161a0" name="a4af619ae8a5e0a864d068ec470b161a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af619ae8a5e0a864d068ec470b161a0">&#9670;&#160;</a></span>RRBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rr::RRBuffer::RRBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab9d7ea0dd1d49f10d54baea0adff8bb" name="aab9d7ea0dd1d49f10d54baea0adff8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9d7ea0dd1d49f10d54baea0adff8bb">&#9670;&#160;</a></span>~RRBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rr::RRBuffer::~RRBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a68ad47b71caf044ad51e0253226d1f3a" name="a68ad47b71caf044ad51e0253226d1f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ad47b71caf044ad51e0253226d1f3a">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286">RRBufferType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets size and contents of buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Requested type of buffer. </td></tr>
    <tr><td class="paramname">width</td><td>Requested width of buffer. Set to number of vertices for BT_VERTEX_BUFFER. </td></tr>
    <tr><td class="paramname">height</td><td>Requested height of buffer. Set 1 for BT_VERTEX_BUFFER. Set equal to width for BT_CUBE_TEXTURE. </td></tr>
    <tr><td class="paramname">depth</td><td>Requested depth of buffer. Set 1 for BT_VERTEX_BUFFER and BT_2D_TEXTURE. Set 6 for BT_CUBE_TEXTURE. </td></tr>
    <tr><td class="paramname">format</td><td>Format of data. Implementation is not required to support all data formats. <br  />
 For linear colors, it's recommended to use floating point format to avoid clamping. For sRGB colors, more compact 8bit format is usually sufficient, although it clamps values to 0..1 range. </td></tr>
    <tr><td class="paramname">scaled</td><td>True for buffer data in custom color space (usually screen colors, sRGB), false for linear colors. When buffer is updated or rendered later, this setting is respected. <br  />
<br  />
 In greater detail: GI is internally calculated in linear colors, while displays work in sRGB, so data must be converted at some point in pipeline. True = data are scaled by <a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009" title="For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-verte...">RRSolver::updateLightmaps()</a>, increasing CPU load; positive sideeffect is that scaled data are suitable even for smaller RGB/RGBA buffers. False = data should be scaled later, for example in shader, thus increasing GPU load. In both cases, scaling to sRGB is simple x=pow(x,0.45) operation. If you precompute lightmaps once and render them many times, you can save time by setting true, data are scaled once. In case of realtime GI where lightmaps are computed once and rendered once, you should save time by setting false and scaling data in renderer/shader (GPU is usually faster). </td></tr>
    <tr><td class="paramname">data</td><td>Data to be copied into texture. When set to nullptr, contents of texture stays uninitialized. Format of data is specified by format, interpretation of data is partially specified by scaled. Special value RR_GHOST_BUFFER creates buffer without any memory allocated for elements (it's good when buffer is needed, but its contents is never accessed, e.g. when creating uninitialized texture in <a class="el" href="classrr__gl_1_1_texture.html" title="Texture is simple OpenGL wrapper around rr::RRBuffer.">rr_gl::Texture</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, false on failure (invalid parameters). </dd></dl>

</div>
</div>
<a id="a4bad2c459d326158fe67262f2c339fc5" name="a4bad2c459d326158fe67262f2c339fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bad2c459d326158fe67262f2c339fc5">&#9670;&#160;</a></span>setElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::setElement </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets single element in buffer. Value is converted to current buffer format. </p>
<p>Index is index into array of all elements, x+y*width+z*width*height. <br  />
 Not mandatory, implementation may be empty. </p>

</div>
</div>
<a id="aefc8345c84b4ca16df6e5d67b013f3a4" name="aefc8345c84b4ca16df6e5d67b013f3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc8345c84b4ca16df6e5d67b013f3a4">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286">RRBufferType</a> rr::RRBuffer::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Type of buffer, e.g. BT_VERTEX_BUFFER. </dd></dl>

</div>
</div>
<a id="aa0d72ee78b712936868997bfd1c560bf" name="aa0d72ee78b712936868997bfd1c560bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d72ee78b712936868997bfd1c560bf">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRBuffer::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Width of buffer: number of vertices for vertex buffer, width in pixels for texture. </dd></dl>

</div>
</div>
<a id="ae963d72b9c822332ce4225f57d4e62d3" name="ae963d72b9c822332ce4225f57d4e62d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae963d72b9c822332ce4225f57d4e62d3">&#9670;&#160;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRBuffer::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Height of buffer: 1 for vertex buffer, height in pixels for texture. </dd></dl>

</div>
</div>
<a id="a1be7fc0bd10c2c421800c05cfe21c907" name="a1be7fc0bd10c2c421800c05cfe21c907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be7fc0bd10c2c421800c05cfe21c907">&#9670;&#160;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRBuffer::getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Depth of buffer: 1 for vertex buffer, 1 for 2d texture, 6 for cube texture. </dd></dl>

</div>
</div>
<a id="a5263a007fcf8e8005088710dc825da66" name="a5263a007fcf8e8005088710dc825da66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5263a007fcf8e8005088710dc825da66">&#9670;&#160;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRBuffer::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Width*height*depth. </dd></dl>

</div>
</div>
<a id="a48641ba47695da1e4f251b125323ab99" name="a48641ba47695da1e4f251b125323ab99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48641ba47695da1e4f251b125323ab99">&#9670;&#160;</a></span>getFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a> rr::RRBuffer::getFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Format of buffer, e.g. BF_RGBF. </dd></dl>

</div>
</div>
<a id="ab06c280769d1d2d3972dafa4a52fd15e" name="ab06c280769d1d2d3972dafa4a52fd15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06c280769d1d2d3972dafa4a52fd15e">&#9670;&#160;</a></span>getScaled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::getScaled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True for buffer in custom color space (usually sRGB), false for linear colors. </dd></dl>

</div>
</div>
<a id="a8d1e45e1cfb8c207b1cc897007a0c05c" name="a8d1e45e1cfb8c207b1cc897007a0c05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1e45e1cfb8c207b1cc897007a0c05c">&#9670;&#160;</a></span>getBufferBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t rr::RRBuffer::getBufferBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Size of buffer in bytes, pure buffer size without several fixed bytes of class size. In case of video, size of one uncompressed frame is calculated. In case of RR_GHOST_BUFFER, 0 is returned as no memory is allocated. </dd></dl>

</div>
</div>
<a id="ad6e7eaa7224549b026c3bf9ea2b8feeb" name="ad6e7eaa7224549b026c3bf9ea2b8feeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e7eaa7224549b026c3bf9ea2b8feeb">&#9670;&#160;</a></span>getElementBits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRBuffer::getElementBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Number of bits in one element, e.g. 96 for BF_RGBF, implementation defined for BF_DEPTH. </dd></dl>

</div>
</div>
<a id="ac1aec3ccb6d188679e1520da54bd50ec" name="ac1aec3ccb6d188679e1520da54bd50ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aec3ccb6d188679e1520da54bd50ec">&#9670;&#160;</a></span>getElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> rr::RRBuffer::getElement </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value addressed by given integer coordinate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index is index into array of all elements, x+y*width+z*width*height. Out of range indices are reported as error. </td></tr>
    <tr><td class="paramname">colorSpace</td><td>If nullptr, color is returned in native color space. With colorSpace set, RGB is returned in linear space, alpha in native space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d6e28b1ee3f0efeee0e70408a6db758" name="a2d6e28b1ee3f0efeee0e70408a6db758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6e28b1ee3f0efeee0e70408a6db758">&#9670;&#160;</a></span>getElementAtPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> rr::RRBuffer::getElementAtPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns value addressed by given float coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Coordinates are array indices in 0..1 range covering whole buffer. Out of range indices are wrapped to 0..1. </td></tr>
    <tr><td class="paramname">colorSpace</td><td>If nullptr, color is returned in native color space. With colorSpace set, RGB is returned in linear space, alpha in native space. </td></tr>
    <tr><td class="paramname">interpolated</td><td>Switches from nearest element selection to linear interpolation of 4 elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5959e60fd3fbb74726c78d34ce38a9b9" name="a5959e60fd3fbb74726c78d34ce38a9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5959e60fd3fbb74726c78d34ce38a9b9">&#9670;&#160;</a></span>getElementAtDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> rr::RRBuffer::getElementAtDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns environment sample addressed by given direction (not necessarily normalized). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>Direction from center in which we look for element. 2d texture is interpreted as 360*180 degree panorama. Cube texture is interpreted as standard cube. </td></tr>
    <tr><td class="paramname">colorSpace</td><td>If nullptr, color is returned in native color space. With colorSpace set, RGB is returned in linear space, alpha in native space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa62f66d38ac68490fa2ee09847562cf" name="aaa62f66d38ac68490fa2ee09847562cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa62f66d38ac68490fa2ee09847562cf">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned char * rr::RRBuffer::lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a9c825752da122dbe1cb0b8c7b0734a4b">RRBufferLock</a>&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the buffer for accessing array of all elements at once. Not mandatory, may return nullptr. </p>
<p>Behaviour of lock is not defined when buffer is already locked. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to array of all width*height*depth elements, in format specified by <a class="el" href="classrr_1_1_r_r_buffer.html#a48641ba47695da1e4f251b125323ab99">getFormat()</a>. </dd></dl>

</div>
</div>
<a id="a9bda3456f80fa506e81de5da0aa4686b" name="a9bda3456f80fa506e81de5da0aa4686b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bda3456f80fa506e81de5da0aa4686b">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks previously locked buffer. </p>

</div>
</div>
<a id="a68f95450f68468f4dbc7a4a52b15a03d" name="a68f95450f68468f4dbc7a4a52b15a03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f95450f68468f4dbc7a4a52b15a03d">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For video/capture/animated buffers, returns true if buffer content was updated and version changed. </p>

</div>
</div>
<a id="ae364554765fdf63c89f79e4288df4106" name="ae364554765fdf63c89f79e4288df4106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae364554765fdf63c89f79e4288df4106">&#9670;&#160;</a></span>play()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::play </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For video buffers, starts playing buffer. To update content of playing buffer, call <a class="el" href="classrr_1_1_r_r_buffer.html#a68f95450f68468f4dbc7a4a52b15a03d" title="For video/capture/animated buffers, returns true if buffer content was updated and version changed.">update()</a>. </p>

</div>
</div>
<a id="ace10501187a4c9a4427effa3a089234c" name="ace10501187a4c9a4427effa3a089234c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace10501187a4c9a4427effa3a089234c">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For video buffers, stops playing buffer and rewinds to the beginning. </p>

</div>
</div>
<a id="a654f288149676fec913e924a90e32429" name="a654f288149676fec913e924a90e32429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654f288149676fec913e924a90e32429">&#9670;&#160;</a></span>pause()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For video buffers, pauses playing buffer. </p>

</div>
</div>
<a id="ac83252ab8a42ef9b001d189387405833" name="ac83252ab8a42ef9b001d189387405833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83252ab8a42ef9b001d189387405833">&#9670;&#160;</a></span>seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::seek </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>secondsFromStart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For video buffers, seeks to given number of seconds from start. </p>

</div>
</div>
<a id="a1a402c4397926530d3321bc3e9b51a78" name="a1a402c4397926530d3321bc3e9b51a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a402c4397926530d3321bc3e9b51a78">&#9670;&#160;</a></span>getDuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual float rr::RRBuffer::getDuration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Duration of dynamic content (video) in seconds, 0 for static content (image, vertex colors), -1 for unlimited dynamic content (video capture). </dd></dl>

</div>
</div>
<a id="a012a9e566f3379d03922b049e2455ae6" name="a012a9e566f3379d03922b049e2455ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012a9e566f3379d03922b049e2455ae6">&#9670;&#160;</a></span>isStub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::isStub </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if buffer is a stub. When asked to, <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">RRBuffer::load()</a> returns stubs instead of nullptr for missing textures. </p>
<p>Stubs are designed to work like other buffers, ideally you won't need this function. We need it only</p><ul>
<li>to not overwrite valid material color by stub color (in <a class="el" href="structrr_1_1_r_r_material.html#a6a483b5fae5b768b2a33916f13a64044" title="Gathers information from textures, updates color for all Properties with texture. Updates also minima...">RRMaterial::updateColorsFromTextures()</a>)</li>
<li>to not expand stub filename to full path (in <a class="el" href="classrr_1_1_r_r_scene.html#a96528108537ab8cdccc0be9b8c827a6a" title="Saves 3d scene to file.">RRScene::save</a>("foo.rr3")) </li>
</ul>

</div>
</div>
<a id="a3e3d651ad26701f619da5017646793c8" name="a3e3d651ad26701f619da5017646793c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3d651ad26701f619da5017646793c8">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a930c3549f9b4b1a207844b9e7d0fb286">RRBufferType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates buffer in system memory. See <a class="el" href="classrr_1_1_r_r_buffer.html#a68ad47b71caf044ad51e0253226d1f3a" title="Sets size and contents of buffer.">reset()</a> for parameter details. Returns nullptr when parameters are invalid or allocation fails. </p>

</div>
</div>
<a id="a519e9eb6cd97c5ed9e47c23e6568ae05" name="a519e9eb6cd97c5ed9e47c23e6568ae05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519e9eb6cd97c5ed9e47c23e6568ae05">&#9670;&#160;</a></span>createReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::createReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates reference to the same buffer. Both buffer and reference must be deleted (in any order). </p>
<p>It is not thread safe, must not be called concurrently for one buffer. It may be called concurrently for different buffers. </p>

</div>
</div>
<a id="a3d2afc9f5686a9e3c7561ad38cfe2ee5" name="a3d2afc9f5686a9e3c7561ad38cfe2ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2afc9f5686a9e3c7561ad38cfe2ee5">&#9670;&#160;</a></span>getReferenceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRBuffer::getReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of references to this instance, for debugging only. </p>

</div>
</div>
<a id="a823f05919132803eff44b0d1a4a90358" name="a823f05919132803eff44b0d1a4a90358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823f05919132803eff44b0d1a4a90358">&#9670;&#160;</a></span>createCopy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::createCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates copy of buffer. Copy is located in system memory and is completely separated, both buffers may contain different data. Copy of video contains single frame. </p>

</div>
</div>
<a id="aeabe5ccd2c8c759e331a42dc9612aa10" name="aeabe5ccd2c8c759e331a42dc9612aa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabe5ccd2c8c759e331a42dc9612aa10">&#9670;&#160;</a></span>createCopy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::createCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24c7d8c26930571bdf82d785e2180007" name="a24c7d8c26930571bdf82d785e2180007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c7d8c26930571bdf82d785e2180007">&#9670;&#160;</a></span>copyElementsTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRBuffer::copyElementsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies contents of buffer. Destination buffer format and scale are preserved, data are converted as necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination buffer. Must have the same width, height, depth, may differ in format, scale. </td></tr>
    <tr><td class="paramname">colorSpace</td><td>Color space used if one buffer is linear. nullptr for no color space conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success. </dd></dl>

</div>
</div>
<a id="a825eea66120b2627c4e77af967cfeb08" name="a825eea66120b2627c4e77af967cfeb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825eea66120b2627c4e77af967cfeb08">&#9670;&#160;</a></span>createSky()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::createSky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>upper</em> = <code><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>lower</em> = <code><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>(1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scaled</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates cube texture with specified colors of upper and lower hemisphere. </p>
<p>Set scaled true for colors in custom color space (usually sRGB), false for linear colors. By default, white cube for ambient occlusion is created. </p>

</div>
</div>
<a id="af684d7f3f6a7868f0f83b77c55771789" name="af684d7f3f6a7868f0f83b77c55771789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af684d7f3f6a7868f0f83b77c55771789">&#9670;&#160;</a></span>createEquirectangular()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::createEquirectangular </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates equirectangular 360 degree panorama (2d texture) from texture loaded with <a class="el" href="classrr_1_1_r_r_buffer.html#a331f938c90e3cc35bd99c20f109ead5a" title="Loads texture from 1 or 6 files to system memory, converting it to cubemap if possible.">loadCube()</a>. </p>
<p>When called on cubemap, it creates new 2d texture with the same number of pixels. When called on 2d texture, it already is equirectangular, so it returns new reference to the same texture. When called on other buffer type (vertex buffer), it returns nullptr.</p>
<p>In other words, this function returns environment rendered with equirectangular camera. For rendering with other camera types, you can use <a class="el" href="classrr_1_1_r_r_solver.html#ad935aad59faca59309309b18a7d7c306" title="Renders scene image into given frame, using pathtracer.">RRSolver::pathTraceFrame()</a>. </p>

</div>
</div>
<a id="a4d37f93f2c5195534a675bca771a7fa6" name="a4d37f93f2c5195534a675bca771a7fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d37f93f2c5195534a675bca771a7fa6">&#9670;&#160;</a></span>createEnvironmentBlend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::createEnvironmentBlend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>environment0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>environment1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td>
          <td class="paramname"><em>angleRad0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td>
          <td class="paramname"><em>angleRad1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td>
          <td class="paramname"><em>blendFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates blend of two rotated environments (2d or cubemaps), as in <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a>'s environment. </p>
<p>Parameters are identical to <a class="el" href="classrr_1_1_r_r_solver.html#a978f6d521e8d357966816ea72156022d" title="Sets environment around scene.">RRSolver::setEnvironment()</a> and <a class="el" href="classrr_1_1_r_r_solver.html#a4e5b7e01b0b3ee24bc7ddd323d616507" title="Sets environment blend factor, specifies how two environments are blended together.">RRSolver::setEnvironmentBlendFactor()</a>. Created buffer is suitable only for pathtracing and for <a class="el" href="classrr_1_1_r_r_buffer.html#af684d7f3f6a7868f0f83b77c55771789" title="Creates equirectangular 360 degree panorama (2d texture) from texture loaded with loadCube().">createEquirectangular()</a>, because it has only <a class="el" href="classrr_1_1_r_r_buffer.html#a5959e60fd3fbb74726c78d34ce38a9b9" title="Returns environment sample addressed by given direction (not necessarily normalized).">getElementAtDirection()</a> and some basic getWidth/Height() implemented, other functions are not available. It is cheap to create, as it doesn't copy any data, it accesses original buffers when needed. </p>

</div>
</div>
<a id="abaf747f374a421d9f44b33aed8d201f1" name="abaf747f374a421d9f44b33aed8d201f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf747f374a421d9f44b33aed8d201f1">&#9670;&#160;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cubeSideName</em>[6] = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *&#160;</td>
          <td class="paramname"><em>fileLocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads buffer from disk to system memory. </p>
<p>Examples:</p><ul>
<li>load("path/lightmap.png") - loads 2d texture (jpg, gif, dds etc)</li>
<li>load("path/lightmap.rrbuffer") - loads e.g. vertex buffer</li>
<li>load("path/cube_%%s.png", {"bk","ft","dn","up","rt","lf"}) - loads cubemap from 6 files</li>
<li>load("path/cube.hdr", non-nullptr) - loads cubemap from 1 file, expects cross-shaped image with aspect 3:4 or 4:3</li>
<li>load("path/cube.hdr", nullptr) - loads the same file as 2d texture</li>
<li>load("path/video.avi") - initializes video streamed to 2d texture, streaming is started by <a class="el" href="classrr_1_1_r_r_buffer.html#ae364554765fdf63c89f79e4288df4106" title="For video buffers, starts playing buffer. To update content of playing buffer, call update().">play()</a></li>
<li>load("c@pture") - initializes live video capture to 2d texture, capturing is started by <a class="el" href="classrr_1_1_r_r_buffer.html#ae364554765fdf63c89f79e4288df4106" title="For video buffers, starts playing buffer. To update content of playing buffer, call update().">play()</a> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Filename of 2d image or vertexbuffer or cubemap or mask of 6 images (sides of cubemap) to be loaded from disk. All common file formats are supported. Proprietary .vbu format is used for vertex buffers. </td></tr>
    <tr><td class="paramname">cubeSideName</td><td>Array of six unique names of cube sides in following order: x+ side, x- side, y+ side, y- side, z+ side, z- side. <br  />
 Examples: {"0","1","2","3","4","5"}, {"bk","ft","dn","up","rt","lf"}. <br  />
 Must be nullptr for vertex buffers and 2d textures, non-nullptr for cubemaps (even cubemaps in 1 file). </td></tr>
    <tr><td class="paramname">fileLocator</td><td>nullptr = load will be attempted only from filename. Non-nullptr = load will be attempted from paths offered by fileLocator. When load fails, fileLocator is asked whether stub buffer with original filename should be created, see RRFileLocator::setAttempt(RRFileLocator::ATTEMPT_STUB,...). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns newly created buffer. In case of failure, nullptr is returned and details logged via <a class="el" href="classrr_1_1_r_r_reporter.html" title="Reporting messages.">RRReporter</a>. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Image load/save is implemented outside LightsprintCore. Make samples/Import/ImportFreeImage.cpp part of your project to enable save/load or use <a class="el" href="classrr_1_1_r_r_buffer.html#a04797b91affe1d32861bbe782dad4173" title="Hooks external code that handles loading content from files into new buffers.">registerLoader()</a> to assign custom code. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a331f938c90e3cc35bd99c20f109ead5a" name="a331f938c90e3cc35bd99c20f109ead5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331f938c90e3cc35bd99c20f109ead5a">&#9670;&#160;</a></span>loadCube()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRBuffer::loadCube </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *&#160;</td>
          <td class="paramname"><em>fileLocator</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads texture from 1 or 6 files to system memory, converting it to cubemap if possible. </p>
<p>This is convenience function working with incomplete information, it attempts to guess whether you want to load texture from 1 file or from 6 files. It calls <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">load()</a> with guessed parameters. If you know exactly what to load, call <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">load()</a> yourself and avoid any guesswork. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>It could be one of<ul>
<li>one of 6 images that make cube map; they are loaded into cubemap</li>
<li>cross shaped 4:3 or 3:4 image; is loaded into cubemap</li>
<li>any other 2d image; is loaded into 2d map It should be full filename, e.g. cube_ft.jpg rather than cube_%s.jpg. </li>
</ul>
</td></tr>
    <tr><td class="paramname">fileLocator</td><td>nullptr = load will be attempted only from filename. Non-nullptr = load will be attempted from paths offered by fileLocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80368d95b5968cab97edac824a1b2752" name="a80368d95b5968cab97edac824a1b2752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80368d95b5968cab97edac824a1b2752">&#9670;&#160;</a></span>reload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::reload </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cubeSideName</em>[6], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_file_locator.html">RRFileLocator</a> *&#160;</td>
          <td class="paramname"><em>fileLocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">load()</a>, but loads from disk into existing buffer. </p>
<p>Default implementation uses buffer's <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">load()</a> and <a class="el" href="classrr_1_1_r_r_buffer.html#a68ad47b71caf044ad51e0253226d1f3a" title="Sets size and contents of buffer.">reset()</a> to load and copy single static frame, it does not work for videos. </p>

</div>
</div>
<a id="aef633298f526aa5c400c323bdba9e05b" name="aef633298f526aa5c400c323bdba9e05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef633298f526aa5c400c323bdba9e05b">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRBuffer::save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filenameMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cubeSideName</em>[6] = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_buffer_1_1_save_parameters.html">SaveParameters</a> *&#160;</td>
          <td class="paramname"><em>saveParameters</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves buffer to disk. </p>
<p>It is not "const" function because it changes <a class="el" href="classrr_1_1_r_r_buffer.html#af3387402c95ad7e36fc7eb35308ae3bd" title="Optional filename, automatically set when load/save succeeds.">RRBuffer::filename</a> to given filename. Save parameters are similar to load, see <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">load()</a> for examples. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filenameMask</td><td>Filename of 1 image/vertexbuffer or mask of 6 images (sides of cubemap) to be saved to disk. All common file formats are supported. Proprietary .vbu format is used for vertex buffers (it consists of 2 bytes RRBufferFormat, 2 bytes bool scaled, 4 bytes num_vertices, data from buffer). </td></tr>
    <tr><td class="paramname">cubeSideName</td><td>When cubemap is saved, array of six unique names of cube sides in following order: x+ side, x- side, y+ side, y- side, z+ side, z- side. Examples: {"0","1","2","3","4","5"}, {"bk","ft","dn","up","rt","lf"}. </td></tr>
    <tr><td class="paramname">saveParameters</td><td>Rarely used additional parameters, keep nullptr for defaults. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on successful save of complete buffer. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Image load/save is implemented outside LightsprintCore. Make samples/Import/ImportFreeImage.cpp part of your project to enable save/load or use <a class="el" href="classrr_1_1_r_r_buffer.html#a04797b91affe1d32861bbe782dad4173" title="Hooks external code that handles loading content from files into new buffers.">registerLoader()</a> to assign custom code. </dd></dl>

</div>
</div>
<a id="a04797b91affe1d32861bbe782dad4173" name="a04797b91affe1d32861bbe782dad4173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04797b91affe1d32861bbe782dad4173">&#9670;&#160;</a></span>registerLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rr::RRBuffer::registerLoader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html#ae41a837feedc24b2eb9e9de0e0243655">Loader</a> *&#160;</td>
          <td class="paramname"><em>loader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hooks external code that handles loading content from files into new buffers. </p>
<p>Usually called from <a class="el" href="namespacerr__io.html#ac58cf19a99df1b94dfd405336a2ca1e5" title="Registers callbacks for loading and saving scenes, textures and videos in ~75 fileformats (Supported ...">rr_io::registerIO()</a>. Initial state is no code hooked, attempts to load buffer are ignored, <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">load()</a> returns nullptr. </p>

</div>
</div>
<a id="a233d79caea9581fe933c01846715510b" name="a233d79caea9581fe933c01846715510b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233d79caea9581fe933c01846715510b">&#9670;&#160;</a></span>registerSaver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rr::RRBuffer::registerSaver </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html#affe8b3f09548f638401b3a3442a5fd94">Saver</a> *&#160;</td>
          <td class="paramname"><em>saver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hooks external code that handles saving images to disk. </p>
<p>Usually called from <a class="el" href="namespacerr__io.html#ac58cf19a99df1b94dfd405336a2ca1e5" title="Registers callbacks for loading and saving scenes, textures and videos in ~75 fileformats (Supported ...">rr_io::registerIO()</a>. Initial state is no code hooked, attempts to save buffer are ignored, <a class="el" href="classrr_1_1_r_r_buffer.html#aef633298f526aa5c400c323bdba9e05b" title="Saves buffer to disk.">save()</a> returns false. </p>

</div>
</div>
<a id="a96317b76fbd7c8dcd312729e48f50a63" name="a96317b76fbd7c8dcd312729e48f50a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96317b76fbd7c8dcd312729e48f50a63">&#9670;&#160;</a></span>getSupportedLoaderExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * rr::RRBuffer::getSupportedLoaderExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns list of supported loader extensions in "*.jpg;*.png" format. </p>
<p>All extensions of registered loaders are returned in one static string, don't free() it. nullptr is returned if no loaders were registered. </p>

</div>
</div>
<a id="a1a14a2b79146595275e7f362efb1e1b2" name="a1a14a2b79146595275e7f362efb1e1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a14a2b79146595275e7f362efb1e1b2">&#9670;&#160;</a></span>getSupportedSaverExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char * rr::RRBuffer::getSupportedSaverExtensions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns list of supported saver extensions in "*.jpg;*.png" format. </p>
<p>All extensions of registered savers are returned in one static string, don't free() it. nullptr is returned if no savers were registered. </p>

</div>
</div>
<a id="a4e73e6b54639577d0184f9f1a31d2a72" name="a4e73e6b54639577d0184f9f1a31d2a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e73e6b54639577d0184f9f1a31d2a72">&#9670;&#160;</a></span>setFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::setFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a6d3b8b9b246e283277a19771ad7e3413">RRBufferFormat</a>&#160;</td>
          <td class="paramname"><em>newFormat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes buffer format. </p>

</div>
</div>
<a id="ad693e7bdc351fb8fb2332eb597878681" name="ad693e7bdc351fb8fb2332eb597878681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad693e7bdc351fb8fb2332eb597878681">&#9670;&#160;</a></span>setFormatFloats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::setFormatFloats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes buffer format to floats, RGB to RGBF, RGBA to RGBAF. </p>

</div>
</div>
<a id="a272ff9338e1156f6d534ff86f8bc05b5" name="a272ff9338e1156f6d534ff86f8bc05b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272ff9338e1156f6d534ff86f8bc05b5">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td>
          <td class="paramname"><em>clearColor</em> = <code><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>(0)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears buffer to clearColor. </p>

</div>
</div>
<a id="aeef1c2b06693f9716a018f994e7f01c4" name="aeef1c2b06693f9716a018f994e7f01c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef1c2b06693f9716a018f994e7f01c4">&#9670;&#160;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes all colors in buffer to 1-color. </p>
<p>Preserves buffer format. This operation is lossless for all formats. </p>

</div>
</div>
<a id="a08b7be5cb492c4fa649f7af351b134f6" name="a08b7be5cb492c4fa649f7af351b134f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b7be5cb492c4fa649f7af351b134f6">&#9670;&#160;</a></span>multiplyAdd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::multiplyAdd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td>
          <td class="paramname"><em>multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td>
          <td class="paramname"><em>addend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes all colors in buffer to color*multiplier+addend. </p>
<p>Preserves buffer format. This operation may be lossy for byte formats (clamped to 0..1 range), use <a class="el" href="classrr_1_1_r_r_buffer.html#ad693e7bdc351fb8fb2332eb597878681" title="Changes buffer format to floats, RGB to RGBF, RGBA to RGBAF.">setFormatFloats()</a> for higher precision. </p>

</div>
</div>
<a id="a2649c5f3b47010fda9a93200a5b9ee27" name="a2649c5f3b47010fda9a93200a5b9ee27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2649c5f3b47010fda9a93200a5b9ee27">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::flip </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipZ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips buffer in x, y and/or z dimension. </p>

</div>
</div>
<a id="a981b3c615f9a2952ee8e279275e57dab" name="a981b3c615f9a2952ee8e279275e57dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981b3c615f9a2952ee8e279275e57dab">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::rotate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>depthLayer</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates single 2d layer of buffer in multiples of 90 degrees. </p>
<p>In case of cubemap, dapthLayer selects side. Contents of buffer is undefined after +90/-90 degree rotation if width!=height. </p>

</div>
</div>
<a id="a3d4808a9a1510c02030d43b2f88eac30" name="a3d4808a9a1510c02030d43b2f88eac30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4808a9a1510c02030d43b2f88eac30">&#9670;&#160;</a></span>brightnessGamma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::brightnessGamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td>
          <td class="paramname"><em>brightness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes all colors in buffer to pow(color*brightness,gamma). </p>
<p>Preserves buffer format. This operation may be lossy for byte formats (clamped to 0..1 range), use <a class="el" href="classrr_1_1_r_r_buffer.html#ad693e7bdc351fb8fb2332eb597878681" title="Changes buffer format to floats, RGB to RGBF, RGBA to RGBAF.">setFormatFloats()</a> for higher precision. </p>

</div>
</div>
<a id="ada2c8282b3ac02f9d9dc4d9c5df2d9cb" name="ada2c8282b3ac02f9d9dc4d9c5df2d9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2c8282b3ac02f9d9dc4d9c5df2d9cb">&#9670;&#160;</a></span>getMinMax()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRBuffer::getMinMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> *&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> *&#160;</td>
          <td class="paramname"><em>maxi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills mini and maxi with extreme values found in buffer. </p>

</div>
</div>
<a id="a27b011e04088bdbacf855fc5dd6be946" name="a27b011e04088bdbacf855fc5dd6be946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b011e04088bdbacf855fc5dd6be946">&#9670;&#160;</a></span>lightmapSmooth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::lightmapSmooth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies gaussian blur to lightmap, even across seams in unwrap. </p>
<p>Reads and preserves connectivity information stored by lightmap baker to alpha channel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigma</td><td>Amount of smoothing, reasonable values are around 1. </td></tr>
    <tr><td class="paramname">wrap</td><td>True = smooth through lightmap boundaries. </td></tr>
    <tr><td class="paramname">object</td><td>Object this lightmap is for, used only for smoothing across unwrap seams. When nullptr, separated unwrap regions are smoothed separately, unwrap seams stay visible in lightmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, may fail when allocation fails or buffer is not 2d texture. </dd></dl>

</div>
</div>
<a id="afa72eaa672fe981a6067f3ced9f2925b" name="afa72eaa672fe981a6067f3ced9f2925b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa72eaa672fe981a6067f3ced9f2925b">&#9670;&#160;</a></span>lightmapGrowForBilinearInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::lightmapGrowForBilinearInterpolation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills in unused lightmap texels relevant when bilinearly interpolating lightmap. </p>
<p>Reads connectivity information stored by lightmap baker to alpha channel. Sets alpha in newly colored texels to 0.001f. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrap</td><td>True = grow through lightmap boundaries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False when lightmap is empty (all texels have alpha&lt;0.002) or not 2d texture. </dd></dl>

</div>
</div>
<a id="a05dcdb6c4a1a70f6d936115e271fb22e" name="a05dcdb6c4a1a70f6d936115e271fb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dcdb6c4a1a70f6d936115e271fb22e">&#9670;&#160;</a></span>lightmapGrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::lightmapGrow </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>aborting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills in unused lightmap texels in proximity of used ones, may help when mipmapping or compressing lightmap. </p>
<p>Expects used texels to have alpha&gt;0. Sets alpha in newly colored texels to 0.001f. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">distance</td><td>Distance in pixels, how deep into unused regions to grow used colors. </td></tr>
    <tr><td class="paramname">wrap</td><td>True = grow through lightmap boundaries. </td></tr>
    <tr><td class="paramname">aborting</td><td>Can be set asynchronously to abort work in progress. When aborted, results are identical to call with lower distance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, may fail when allocation fails or buffer is not 2d texture. </dd></dl>

</div>
</div>
<a id="a075999b0c27d73a53cbdbc96fd9000f3" name="a075999b0c27d73a53cbdbc96fd9000f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075999b0c27d73a53cbdbc96fd9000f3">&#9670;&#160;</a></span>lightmapFillBackground()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRBuffer::lightmapFillBackground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a>&#160;</td>
          <td class="paramname"><em>backgroundColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills unused texels in lightmap by backgroundColor. </p>
<p>Expects used texels to have alpha&gt;0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backgroundColor</td><td>Color (and alpha) to set to all unused texels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True on success, may fail when buffer is not 2d texture. </dd></dl>

</div>
</div>
<a id="a6385adeacc29bdb79b3ad1087a27ee95" name="a6385adeacc29bdb79b3ad1087a27ee95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6385adeacc29bdb79b3ad1087a27ee95">&#9670;&#160;</a></span>deleteFromCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRBuffer::deleteFromCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes last reference to buffer from cache. </p>
<p>To be called from delete operator of all <a class="el" href="classrr_1_1_r_r_buffer.html" title="Buffer, array of elements.">RRBuffer</a> implementations when refCount is 1. Without this function, deleted images would stay in cache and next load from the same filename would be super fast. This is however rarely needed, freeing memory is more important, so we explicitly delete buffer from cache. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3387402c95ad7e36fc7eb35308ae3bd" name="af3387402c95ad7e36fc7eb35308ae3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3387402c95ad7e36fc7eb35308ae3bd">&#9670;&#160;</a></span>filename</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_string.html">RRString</a> rr::RRBuffer::filename</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional filename, automatically set when load/save succeeds. </p>
<p>When <a class="el" href="classrr_1_1_r_r_file_locator.html" title="Provides possible file locations when exact location is not known.">RRFileLocator</a> is in use and it locates requested file in different place, this is the name of file actually opened. When <a class="el" href="classrr_1_1_r_r_file_locator.html" title="Provides possible file locations when exact location is not known.">RRFileLocator</a> fails to locate requested file, but it generates or loads stub image, this is name of file requested. Path can be relative or absolute, anything supported by operating system, we don't restrict its format. </p>

</div>
</div>
<a id="ab902a36bd1549c099002c35ed9d108be" name="ab902a36bd1549c099002c35ed9d108be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab902a36bd1549c099002c35ed9d108be">&#9670;&#160;</a></span>version</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRBuffer::version</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of data in buffer, modified each time buffer content changes. </p>

</div>
</div>
<a id="a4b0d5382afd2e785964961c44a65d8a1" name="a4b0d5382afd2e785964961c44a65d8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0d5382afd2e785964961c44a65d8a1">&#9670;&#160;</a></span>customData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rr::RRBuffer::customData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For your private use, not accessed by LightsprintCore. Initialized to nullptr. </p>
<p>If you use LightsprintGL, you should not modify it, it is set to Texture*. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerr.html">rr</a></li><li class="navelem"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
