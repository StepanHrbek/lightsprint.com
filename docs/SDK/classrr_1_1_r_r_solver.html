<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LightsprintSDK: rr::RRSolver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LightsprintSDK<span id="projectnumber">&#160;2021.08.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrr_1_1_r_r_solver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classrr_1_1_r_r_solver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rr::RRSolver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;RRSolver.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rr::RRSolver:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrr_1_1_r_r_solver.png" usemap="#rr::RRSolver_map" alt=""/>
  <map id="rr::RRSolver_map" name="rr::RRSolver_map">
<area href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html" title="When used as base class, object copying is not allowed." alt="rr::RRUniformlyAllocatedNonCopyable" shape="rect" coords="0,56,227,80"/>
<area href="classrr_1_1_r_r_uniformly_allocated.html" title="When used as base class, delete works correctly without regard who calls it." alt="rr::RRUniformlyAllocated" shape="rect" coords="0,0,227,24"/>
<area href="classrr__gl_1_1_r_r_solver_g_l.html" title="Implementation of rr::RRSolver generic GPU operations using OpenGL 2.0." alt="rr_gl::RRSolverGL" shape="rect" coords="0,168,227,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_solver_1_1_calculate_parameters.html">CalculateParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_solver_1_1_filtering_parameters.html">FilteringParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_solver_1_1_multipliers.html">Multipliers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_solver_1_1_path_tracing_parameters.html">PathTracingParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_solver_1_1_smoothing_parameters.html">SmoothingParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_solver_1_1_update_parameters.html">UpdateParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a26a8982640b26261d1c061a072b4536a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536a">InternalSolverType</a> { <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536aae6f8d03db92d29334ed7628e4d5e5bcf">NONE</a>
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536aa1e1da7e24d239d03457b266f149d9644">ARCHITECT</a>
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536aa9d7657452fe1122d3c397b0ebd1fa12b">FIREBALL</a>
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536aadcd36f053d3d7e961b8c8dab26f14a05">BOTH</a>
<br />
 }</td></tr>
<tr class="separator:a26a8982640b26261d1c061a072b4536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac74be5ed8e45d4c32d1d965744102e81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ac74be5ed8e45d4c32d1d965744102e81">RRSolver</a> ()</td></tr>
<tr class="separator:ac74be5ed8e45d4c32d1d965744102e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aff709c1764c22dd942c726f595d80"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#aa0aff709c1764c22dd942c726f595d80">~RRSolver</a> ()</td></tr>
<tr class="separator:aa0aff709c1764c22dd942c726f595d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f84d6f426c94293f5a44c63632e22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#af31f84d6f426c94293f5a44c63632e22">setColorSpace</a> (const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace)</td></tr>
<tr class="separator:af31f84d6f426c94293f5a44c63632e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0feb0e28ac3715d7bb175a57508680da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a0feb0e28ac3715d7bb175a57508680da">getColorSpace</a> () const</td></tr>
<tr class="separator:a0feb0e28ac3715d7bb175a57508680da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978f6d521e8d357966816ea72156022d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a978f6d521e8d357966816ea72156022d">setEnvironment</a> (<a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *environment0, <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *environment1=nullptr, <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> angleRad0=0, <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> angleRad1=0)</td></tr>
<tr class="separator:a978f6d521e8d357966816ea72156022d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af227409f6a04bd904ab235f5fa627d97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#af227409f6a04bd904ab235f5fa627d97">getEnvironment</a> (unsigned environmentIndex=0, <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> *angleRad=nullptr) const</td></tr>
<tr class="separator:af227409f6a04bd904ab235f5fa627d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5b7e01b0b3ee24bc7ddd323d616507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a4e5b7e01b0b3ee24bc7ddd323d616507">setEnvironmentBlendFactor</a> (float blendFactor)</td></tr>
<tr class="separator:a4e5b7e01b0b3ee24bc7ddd323d616507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5a73117a3b551ea719ee0964c1f42a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a7d5a73117a3b551ea719ee0964c1f42a">getEnvironmentBlendFactor</a> () const</td></tr>
<tr class="separator:a7d5a73117a3b551ea719ee0964c1f42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bfd7935c0e55b684828bfb0f5d9bf8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a86bfd7935c0e55b684828bfb0f5d9bf8">setLights</a> (const <a class="el" href="classrr_1_1_r_r_lights.html">RRLights</a> &amp;lights)</td></tr>
<tr class="separator:a86bfd7935c0e55b684828bfb0f5d9bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25f95e453d679035273cc378d8b8aed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_lights.html">RRLights</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#aa25f95e453d679035273cc378d8b8aed">getLights</a> () const</td></tr>
<tr class="separator:aa25f95e453d679035273cc378d8b8aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3769d618693b82f168fe3cb8f91b78c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8">setDirectIllumination</a> (const unsigned *perTriangleIrradianceRGBA)</td></tr>
<tr class="separator:a3769d618693b82f168fe3cb8f91b78c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62684fa032b79bee381927b7d5834e5b"><td class="memItemLeft" align="right" valign="top">const unsigned *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a62684fa032b79bee381927b7d5834e5b">getDirectIllumination</a> ()</td></tr>
<tr class="separator:a62684fa032b79bee381927b7d5834e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4310e713dc21242394e3601303ee8ae9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9">setStaticObjects</a> (const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp;objects, const <a class="el" href="structrr_1_1_r_r_solver_1_1_smoothing_parameters.html">SmoothingParameters</a> *smoothing, const char *cacheLocation=nullptr, <a class="el" href="classrr_1_1_r_r_collider.html#aa5ca8d65491dac68cffc34afcd3dcb0f">RRCollider::IntersectTechnique</a> intersectTechnique=<a class="el" href="classrr_1_1_r_r_collider.html#aa5ca8d65491dac68cffc34afcd3dcb0fa5644e4efdb73c3e73bde75c9b1cc7cab">RRCollider::IT_BVH_FAST</a>, <a class="el" href="classrr_1_1_r_r_solver.html">RRSolver</a> *copyFrom=nullptr)</td></tr>
<tr class="separator:a4310e713dc21242394e3601303ee8ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf411cdda000cf5d3fc2c1eebacfa754"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754">getStaticObjects</a> () const</td></tr>
<tr class="separator:acf411cdda000cf5d3fc2c1eebacfa754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c672d0e33e98ded005555f735495e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a82c672d0e33e98ded005555f735495e1">setDynamicObjects</a> (const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp;objects)</td></tr>
<tr class="separator:a82c672d0e33e98ded005555f735495e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55d0db85edda9c25444598a1a892136"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ad55d0db85edda9c25444598a1a892136">getDynamicObjects</a> () const</td></tr>
<tr class="separator:ad55d0db85edda9c25444598a1a892136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af541f652f8386e0f939b2afaa41604a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#af541f652f8386e0f939b2afaa41604a1">getObjects</a> () const</td></tr>
<tr class="separator:af541f652f8386e0f939b2afaa41604a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c49e407ca61d7387f8699edef892db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a8c49e407ca61d7387f8699edef892db9">getObject</a> (unsigned index) const</td></tr>
<tr class="separator:a8c49e407ca61d7387f8699edef892db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecb9d07b25f43603aa5184896c756fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_collider.html">RRCollider</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a8ecb9d07b25f43603aa5184896c756fa">getCollider</a> () const</td></tr>
<tr class="separator:a8ecb9d07b25f43603aa5184896c756fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af550c02b32fff5b482ec3191315c3e40"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#af550c02b32fff5b482ec3191315c3e40">getAABB</a> (<a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *_mini, <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *_maxi, <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *_center) const</td></tr>
<tr class="separator:af550c02b32fff5b482ec3191315c3e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73feb78b078b1e760d48841e8d268a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ae73feb78b078b1e760d48841e8d268a3">processBuffers</a> (const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; *layers, std::function&lt; void(<a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *)&gt; func) const</td></tr>
<tr class="separator:ae73feb78b078b1e760d48841e8d268a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b762b6fab0980d9c976108a339ea398"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398">calculate</a> (const <a class="el" href="structrr_1_1_r_r_solver_1_1_calculate_parameters.html">CalculateParameters</a> *params=nullptr)</td></tr>
<tr class="separator:a1b762b6fab0980d9c976108a339ea398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa3e175d154100f2b8aa3ac2d7c2a55"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a8fa3e175d154100f2b8aa3ac2d7c2a55">getSolutionVersion</a> () const</td></tr>
<tr class="separator:a8fa3e175d154100f2b8aa3ac2d7c2a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaa9ea4b5f70eb96a3313a5bf1fd592"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a4aaa9ea4b5f70eb96a3313a5bf1fd592">updateLightmap</a> (int objectNumber, <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *lightmap, <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *directionalLightmap[3], <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *bentNormals, const <a class="el" href="structrr_1_1_r_r_solver_1_1_update_parameters.html">UpdateParameters</a> *params, const <a class="el" href="structrr_1_1_r_r_solver_1_1_filtering_parameters.html">FilteringParameters</a> *filtering=nullptr)</td></tr>
<tr class="separator:a4aaa9ea4b5f70eb96a3313a5bf1fd592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123529338f03195a6233b53e5100a009"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009">updateLightmaps</a> (int layerLightmap, int layerDirectionalLightmap, int layerBentNormals, const <a class="el" href="structrr_1_1_r_r_solver_1_1_update_parameters.html">UpdateParameters</a> *params, const <a class="el" href="structrr_1_1_r_r_solver_1_1_filtering_parameters.html">FilteringParameters</a> *filtering)</td></tr>
<tr class="separator:a123529338f03195a6233b53e5100a009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430bb0184e06c57877d821ea26e02bf3"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a430bb0184e06c57877d821ea26e02bf3">updateEnvironmentMap</a> (<a class="el" href="classrr_1_1_r_r_object_illumination.html">RRObjectIllumination</a> *illumination, unsigned layerEnvironment, unsigned layerLightmap, unsigned layerAmbientMap)</td></tr>
<tr class="separator:a430bb0184e06c57877d821ea26e02bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cccd12911c638248f22b8143f805d56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a2cccd12911c638248f22b8143f805d56">getTriangleMeasure</a> (unsigned triangle, unsigned vertex, <a class="el" href="structrr_1_1_r_r_radiometric_measure.html">RRRadiometricMeasure</a> measure, <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;out) const</td></tr>
<tr class="separator:a2cccd12911c638248f22b8143f805d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa969ac391ce322c93a282b960a02a3b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#aa969ac391ce322c93a282b960a02a3b7">reportMaterialChange</a> (bool dirtyShadows, bool dirtyGI)</td></tr>
<tr class="separator:aa969ac391ce322c93a282b960a02a3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19431779f0500c3a9ba52a134a406b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ac19431779f0500c3a9ba52a134a406b1">reportDirectIlluminationChange</a> (int lightIndex, bool dirtyShadows, bool dirtyGI, bool dirtyRange)</td></tr>
<tr class="separator:ac19431779f0500c3a9ba52a134a406b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2922658d0d2630440bf0f84f29edb645"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a2922658d0d2630440bf0f84f29edb645">reportInteraction</a> ()</td></tr>
<tr class="separator:a2922658d0d2630440bf0f84f29edb645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ce6646e5934547e22aea4e5ea4d98d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a42ce6646e5934547e22aea4e5ea4d98d">buildFireball</a> (unsigned avgRaysPerTriangle, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;filename)</td></tr>
<tr class="separator:a42ce6646e5934547e22aea4e5ea4d98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed01d3ecb9260b56278dda32097bff9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a5ed01d3ecb9260b56278dda32097bff9">loadFireball</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;filename, bool onlyPerfectMatch)</td></tr>
<tr class="separator:a5ed01d3ecb9260b56278dda32097bff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5426f4aac440ff01111af954f97c88b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a5426f4aac440ff01111af954f97c88b0">leaveFireball</a> ()</td></tr>
<tr class="separator:a5426f4aac440ff01111af954f97c88b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9cb70c8d406e62f7f508ad15d3204a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536a">InternalSolverType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#aab9cb70c8d406e62f7f508ad15d3204a">getInternalSolverType</a> () const</td></tr>
<tr class="separator:aab9cb70c8d406e62f7f508ad15d3204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eecb326fcb191ad6274bcafef8d14c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a3eecb326fcb191ad6274bcafef8d14c2">checkConsistency</a> ()</td></tr>
<tr class="separator:a3eecb326fcb191ad6274bcafef8d14c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92b97bd386ca7f2f7ae0b16c98feecc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ae92b97bd386ca7f2f7ae0b16c98feecc">containsLightSource</a> () const</td></tr>
<tr class="separator:ae92b97bd386ca7f2f7ae0b16c98feecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76c4e9351f293d3e9b16dc26ee1565f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#af76c4e9351f293d3e9b16dc26ee1565f">containsRealtimeGILightSource</a> () const</td></tr>
<tr class="separator:af76c4e9351f293d3e9b16dc26ee1565f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0703d3ee895467659bbf3ebd9e198c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#aaf0703d3ee895467659bbf3ebd9e198c">allocateBuffersForRealtimeGI</a> (int layerLightmap, int layerEnvironment, unsigned diffuseEnvMapSize=4, unsigned specularEnvMapSize=16, unsigned refractEnvMapSize=16, bool allocateNewBuffers=true, bool changeExistingBuffers=true, float specularThreshold=0.2f, float depthThreshold=0.1f) const</td></tr>
<tr class="separator:aaf0703d3ee895467659bbf3ebd9e198c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39fe361d8f1bef589f6af6d59827e9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ad39fe361d8f1bef589f6af6d59827e9a">getMultiObject</a> () const</td></tr>
<tr class="separator:ad39fe361d8f1bef589f6af6d59827e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad935aad59faca59309309b18a7d7c306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ad935aad59faca59309309b18a7d7c306">pathTraceFrame</a> (const <a class="el" href="classrr_1_1_r_r_camera.html">RRCamera</a> &amp;camera, <a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *frame, unsigned accumulate, const <a class="el" href="structrr_1_1_r_r_solver_1_1_path_tracing_parameters.html">PathTracingParameters</a> &amp;parameters)</td></tr>
<tr class="separator:ad935aad59faca59309309b18a7d7c306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrr_1_1_r_r_uniformly_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrr_1_1_r_r_uniformly_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated.html">rr::RRUniformlyAllocated</a></td></tr>
<tr class="memitem:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a073b837b152a4c54b8b581bd2e82ec08">operator new</a> (std::size_t n)</td></tr>
<tr class="separator:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a1f55fa066eee7b98a94c98fbecdbaeef">operator new[]</a> (std::size_t n)</td></tr>
<tr class="separator:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#ac0d7217fef84aacf42287c189423e15e">operator delete</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a42a7c29977989c72d78660bd487cc97e">operator delete[]</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab8ae312d9c953045b0d06e91d41c662b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#ab8ae312d9c953045b0d06e91d41c662b">aborting</a></td></tr>
<tr class="separator:ab8ae312d9c953045b0d06e91d41c662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a72cd29d74fa8d3275b19f3096b997a81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a72cd29d74fa8d3275b19f3096b997a81">calculateDirtyLights</a> (const <a class="el" href="structrr_1_1_r_r_solver_1_1_calculate_parameters.html">CalculateParameters</a> *params=nullptr)</td></tr>
<tr class="separator:a72cd29d74fa8d3275b19f3096b997a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html">rr::RRUniformlyAllocatedNonCopyable</a></td></tr>
<tr class="memitem:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a2fb6eae4adda7ad435a7aa482d1005cd">RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a7c05e32bc9c7a711d579fc328cb3392a">~RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a78f6cde638cc3ac087a6424f251eedce"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_solver.html#a78f6cde638cc3ac087a6424f251eedce">PathtracerWorker</a></td></tr>
<tr class="separator:a78f6cde638cc3ac087a6424f251eedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Global illumination solver for interactive applications. </p>
<p>Usage for interactive realtime visualizations and tools: Create one instance at the beginning of interactive session and load it with all static objects in scene. Call <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a> at each frame, it will spend some time by improving illumination. When scene changes, report it using report* methods.</p>
<p>Usage for non interactive tools/precalculators is the same as for interactive applications, with these differences:</p><ul>
<li>call <a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009" title="For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-verte...">updateLightmaps()</a> or <a class="el" href="classrr_1_1_r_r_solver.html#a4aaa9ea4b5f70eb96a3313a5bf1fd592" title="For single static object, calculates and updates lightmap and/or bent normals; in per-pixel or per-ve...">updateLightmap()</a> with higher quality settings for higher quality results</li>
<li>instead of rendering computed illumination, save it to disk using <a class="el" href="classrr_1_1_r_r_buffer.html#aef633298f526aa5c400c323bdba9e05b" title="Saves buffer to disk.">RRBuffer::save()</a> or <a class="el" href="classrr_1_1_r_r_buffer.html#aef633298f526aa5c400c323bdba9e05b" title="Saves buffer to disk.">RRBuffer::save()</a> functions.</li>
</ul>
<p>Custom access to GPU and your renderer is not implemented here. You may implement it in your <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a> subclass or use <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html" title="Implementation of rr::RRSolver generic GPU operations using OpenGL 2.0.">rr_gl::RRSolverGL</a>, that implements GPU access using OpenGL 2.0.</p>
<p><a class="el" href="samples_realtime.html">Sample RealtimeRadiosity</a> shows both typical usage scenarios, rendering with realtime global illumination and precalculations.</p>
<p>It is not allowed to create and use multiple instances at the same time.</p>
<p>Thread safe: Partially, see functions for more details. All updateXxxx() functions automatically use all cores. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a26a8982640b26261d1c061a072b4536a" name="a26a8982640b26261d1c061a072b4536a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a8982640b26261d1c061a072b4536a">&#9670;&#160;</a></span>InternalSolverType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536a">rr::RRSolver::InternalSolverType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of internal solver. For debugging purposes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a26a8982640b26261d1c061a072b4536aae6f8d03db92d29334ed7628e4d5e5bcf" name="a26a8982640b26261d1c061a072b4536aae6f8d03db92d29334ed7628e4d5e5bcf"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26a8982640b26261d1c061a072b4536aa1e1da7e24d239d03457b266f149d9644" name="a26a8982640b26261d1c061a072b4536aa1e1da7e24d239d03457b266f149d9644"></a>ARCHITECT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26a8982640b26261d1c061a072b4536aa9d7657452fe1122d3c397b0ebd1fa12b" name="a26a8982640b26261d1c061a072b4536aa9d7657452fe1122d3c397b0ebd1fa12b"></a>FIREBALL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26a8982640b26261d1c061a072b4536aadcd36f053d3d7e961b8c8dab26f14a05" name="a26a8982640b26261d1c061a072b4536aadcd36f053d3d7e961b8c8dab26f14a05"></a>BOTH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac74be5ed8e45d4c32d1d965744102e81" name="ac74be5ed8e45d4c32d1d965744102e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74be5ed8e45d4c32d1d965744102e81">&#9670;&#160;</a></span>RRSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rr::RRSolver::RRSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0aff709c1764c22dd942c726f595d80" name="aa0aff709c1764c22dd942c726f595d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aff709c1764c22dd942c726f595d80">&#9670;&#160;</a></span>~RRSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rr::RRSolver::~RRSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af31f84d6f426c94293f5a44c63632e22" name="af31f84d6f426c94293f5a44c63632e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31f84d6f426c94293f5a44c63632e22">&#9670;&#160;</a></span>setColorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::setColorSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set colorSpace used by this scene i/o operations. </p>
<p>It switches solver inputs and outputs from physical scale to custom scale defined by colorSpace, e.g. screen colors. See <a class="el" href="classrr_1_1_r_r_color_space.html" title="Interface for custom color space.">RRColorSpace</a> for details.</p>
<p>In 99% of cases you want to set colorSpace before using solver as nearly all existing renderers and datasets use sRGB or other custom scale. Not setting colorSpace is allowed for future rendering pipelines working fully in physical scale. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorSpace</td><td>Color space for converting illumination from/to linear colors. It will be used by all data input and output paths in <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a>, if not specified otherwise. Note that colorSpace is not adopted, you are still responsible for deleting it when it's no longer needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0feb0e28ac3715d7bb175a57508680da" name="a0feb0e28ac3715d7bb175a57508680da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0feb0e28ac3715d7bb175a57508680da">&#9670;&#160;</a></span>getColorSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> * rr::RRSolver::getColorSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns colorSpace used by this scene i/o operations, set by <a class="el" href="classrr_1_1_r_r_solver.html#af31f84d6f426c94293f5a44c63632e22" title="Set colorSpace used by this scene i/o operations.">setColorSpace()</a>. </p>

</div>
</div>
<a id="a978f6d521e8d357966816ea72156022d" name="a978f6d521e8d357966816ea72156022d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978f6d521e8d357966816ea72156022d">&#9670;&#160;</a></span>setEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::setEnvironment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>environment0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>environment1</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td>
          <td class="paramname"><em>angleRad0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td>
          <td class="paramname"><em>angleRad1</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets environment around scene. </p>
<p>This is one of ways for light to enter solver; others are <a class="el" href="classrr_1_1_r_r_solver.html#a86bfd7935c0e55b684828bfb0f5d9bf8" title="Sets lights in scene, all at once.">setLights()</a>, <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a>, emissive materials. Environment is rendered around scene and scene is illuminated by environment.</p>
<p>By default, scene contains no environment, which is the same as black environment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">environment0</td><td>LDR or HDR environment stored in cube map or in 2d texture with 360*180 degree panorama (equirectangular projection). Buffer is not adopted, you are still responsible for deleting it when it's no longer needed. </td></tr>
    <tr><td class="paramname">environment1</td><td>Optional second environment map, solver is able to work with blend of two environments, see <a class="el" href="classrr_1_1_r_r_solver.html#a4e5b7e01b0b3ee24bc7ddd323d616507" title="Sets environment blend factor, specifies how two environments are blended together.">setEnvironmentBlendFactor()</a>. It's ok to mix LDR and HDR maps, 2d and cube maps, all combinations work. Buffer is not adopted, you are still responsible for deleting it when it's no longer needed. </td></tr>
    <tr><td class="paramname">angleRad0</td><td></td></tr>
    <tr><td class="paramname">angleRad1</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af227409f6a04bd904ab235f5fa627d97" name="af227409f6a04bd904ab235f5fa627d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af227409f6a04bd904ab235f5fa627d97">&#9670;&#160;</a></span>getEnvironment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> * rr::RRSolver::getEnvironment </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>environmentIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> *&#160;</td>
          <td class="paramname"><em>angleRad</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns scene environment set by <a class="el" href="classrr_1_1_r_r_solver.html#a978f6d521e8d357966816ea72156022d" title="Sets environment around scene.">setEnvironment()</a>. </p>

</div>
</div>
<a id="a4e5b7e01b0b3ee24bc7ddd323d616507" name="a4e5b7e01b0b3ee24bc7ddd323d616507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5b7e01b0b3ee24bc7ddd323d616507">&#9670;&#160;</a></span>setEnvironmentBlendFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::setEnvironmentBlendFactor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>blendFactor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets environment blend factor, specifies how two environments are blended together. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blendFactor</td><td>Any value between 0 and 1, tells solver how to blend two environments. 0 = use only environment0, this is default. 1 = use only environment1. Lightsprint realtime GI solvers and realtime renderer fully support blending, offline GI solver works as if blendFactor is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d5a73117a3b551ea719ee0964c1f42a" name="a7d5a73117a3b551ea719ee0964c1f42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5a73117a3b551ea719ee0964c1f42a">&#9670;&#160;</a></span>getEnvironmentBlendFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rr::RRSolver::getEnvironmentBlendFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns environment blend factor set by <a class="el" href="classrr_1_1_r_r_solver.html#a978f6d521e8d357966816ea72156022d" title="Sets environment around scene.">setEnvironment()</a>. </p>

</div>
</div>
<a id="a86bfd7935c0e55b684828bfb0f5d9bf8" name="a86bfd7935c0e55b684828bfb0f5d9bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bfd7935c0e55b684828bfb0f5d9bf8">&#9670;&#160;</a></span>setLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::setLights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_lights.html">RRLights</a> &amp;&#160;</td>
          <td class="paramname"><em>lights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets lights in scene, all at once. </p>
<p>This is one of ways how light enters solver, others are <a class="el" href="classrr_1_1_r_r_solver.html#a978f6d521e8d357966816ea72156022d" title="Sets environment around scene.">setEnvironment()</a>, <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a>, emissive materials.</p>
<p>By default, scene contains no lights.</p>
<p>Setting lights is important for offline GI and for direct illumination in realtime renderer. If you integrate Lightsprint realtime GI with third party renderer and you use solver only to calculate realtime indirect illumination, calling <a class="el" href="classrr_1_1_r_r_solver.html#a86bfd7935c0e55b684828bfb0f5d9bf8" title="Sets lights in scene, all at once.">setLights()</a> is not necessary; calling <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a> instead gives solver necessary information. </p>

<p>Reimplemented in <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html#aa3505f8e4ce9e5214aad2b777c6c9891">rr_gl::RRSolverGL</a>.</p>

</div>
</div>
<a id="aa25f95e453d679035273cc378d8b8aed" name="aa25f95e453d679035273cc378d8b8aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25f95e453d679035273cc378d8b8aed">&#9670;&#160;</a></span>getLights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_lights.html">RRLights</a> &amp; rr::RRSolver::getLights </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns lights in scene, set by <a class="el" href="classrr_1_1_r_r_solver.html#a86bfd7935c0e55b684828bfb0f5d9bf8" title="Sets lights in scene, all at once.">setLights()</a>. </p>

</div>
</div>
<a id="a3769d618693b82f168fe3cb8f91b78c8" name="a3769d618693b82f168fe3cb8f91b78c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3769d618693b82f168fe3cb8f91b78c8">&#9670;&#160;</a></span>setDirectIllumination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::setDirectIllumination </td>
          <td>(</td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>perTriangleIrradianceRGBA</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets custom irradiance for all static triangles in scene. </p>
<p>This is one of paths for light to enter solver, others are <a class="el" href="classrr_1_1_r_r_solver.html#a86bfd7935c0e55b684828bfb0f5d9bf8" title="Sets lights in scene, all at once.">setLights()</a>, <a class="el" href="classrr_1_1_r_r_solver.html#a978f6d521e8d357966816ea72156022d" title="Sets environment around scene.">setEnvironment()</a>, emissive materials. Unlike the other paths, this one is usually called many times - whenever lighting changes.</p>
<p>If you use <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html" title="Implementation of rr::RRSolver generic GPU operations using OpenGL 2.0.">rr_gl::RRSolverGL</a>, <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a> is called automatically from <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a>.</p>
<p>If you want to provide your own direct illumination data, for example when integrating Lightsprint realtime GI with third party renderer, use <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a> and call <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a> manually before <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a> whenever lighting changes. Note that functions that reset solver or change its type (<a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">setStaticObjects()</a>, <a class="el" href="classrr_1_1_r_r_solver.html#a5ed01d3ecb9260b56278dda32097bff9" title="Load and start Fireball.">loadFireball()</a> etc) might reset also direct illumination, so you need to set it again after such functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perTriangleIrradianceRGBA</td><td>Array of average per-triangle direct-lighting irradiances in custom scale. In other words, average triangle colors when direct lighting+shadows are applied, but materials are not. Format is RGBA8, i.e. first byte is red, second one is green, third one is blue, fourth one is ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Length of array is <a class="el" href="classrr_1_1_r_r_solver.html#ad39fe361d8f1bef589f6af6d59827e9a" title="Returns multiObject created by merging all static objects in scene, see setStaticObjects().">getMultiObject()</a>-&gt;<a class="el" href="classrr_1_1_r_r_solver.html#a8ecb9d07b25f43603aa5184896c756fa" title="Returns collider for whole scene, both static and dynamic.">getCollider()</a>-&gt;getMesh()-&gt;getNumTriangles(). Order of values in array is defined by order of static triangles in scene, first all triangles from static object 0, then all triangles from static object 1 etc.</p>
<p>Array must stay valid at least until next <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a> call. Array is not adopted+deleted, you are still responsible for deleting it. You are free to set always the same array or each time different one, performace is identical.</p>
<p>Setting nullptr is the same as setting array filled by zeroes, no custom irradiance. </p>

</div>
</div>
<a id="a62684fa032b79bee381927b7d5834e5b" name="a62684fa032b79bee381927b7d5834e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62684fa032b79bee381927b7d5834e5b">&#9670;&#160;</a></span>getDirectIllumination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned * rr::RRSolver::getDirectIllumination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns pointer previously passed to <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a>, or nullptr if it was not set yet. </p>

</div>
</div>
<a id="a4310e713dc21242394e3601303ee8ae9" name="a4310e713dc21242394e3601303ee8ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4310e713dc21242394e3601303ee8ae9">&#9670;&#160;</a></span>setStaticObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::setStaticObjects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp;&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_smoothing_parameters.html">SmoothingParameters</a> *&#160;</td>
          <td class="paramname"><em>smoothing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cacheLocation</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_collider.html#aa5ca8d65491dac68cffc34afcd3dcb0f">RRCollider::IntersectTechnique</a>&#160;</td>
          <td class="paramname"><em>intersectTechnique</em> = <code><a class="el" href="classrr_1_1_r_r_collider.html#aa5ca8d65491dac68cffc34afcd3dcb0fa5644e4efdb73c3e73bde75c9b1cc7cab">RRCollider::IT_BVH_FAST</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_solver.html">RRSolver</a> *&#160;</td>
          <td class="paramname"><em>copyFrom</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets static contents of scene, all static objects at once. Only objects with ! <a class="el" href="classrr_1_1_r_r_object.html#afdc417da52b075c4868fe3ce4cc4c846" title="Is this object dynamic = is it safe to modify it?">RRObject::isDynamic</a> are taken, the rest is ignored. </p>
<p>Solver creates internal set of static objects, by taking only those of your objects with isDynamic=false, you can query accepted objects by <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a>. Solver preserves your order of static objects. Any reference to n-th object in documentation refers to <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a>[n]. If you pass only static objects, then <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a>[n]==objects[n]. Solver reads isDynamic only in this function; if you change it later, it won't have any effect.</p>
<p>Once set, triangles and vertices in static objects must not change (that's the difference from dynamic objects). If you modify static triangles or vertices anyway, call <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">setStaticObjects()</a> again otherwise solver might crash.</p>
<p>Scene must always contain static objects. Major occluders (buildings, large furniture etc) should be part of static scene. Handling major occluders as dynamic objects is safe, but it reduces realism of realtime indirect illumination, so it is not recommended.</p>
<p>If Fireball was enabled, <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">setStaticObjects()</a> disables it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objects</td><td>Static contents of your scene, set of static objects. <br  />
 Objects are passed via <a class="el" href="classrr_1_1_r_r_objects.html" title="Set of objects with interface similar to std::vector.">RRObjects</a>, collection of pointers to objects. Solver creates its own copy of these pointers, but it does not copy actual objects. So while your collection is no longer accessed after this call, actual objects are, you must not deallocate or modify them until next <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">setStaticObjects()</a> call or solver destruction. Changing objects, meshes, positions, colors etc while they are set in solver could crash program. Changing illumiation stored in objects is safe. </td></tr>
    <tr><td class="paramname">smoothing</td><td>Static scene illumination smoothing. Set nullptr for default values. </td></tr>
    <tr><td class="paramname">cacheLocation</td><td>Whether and where to cache colliders (speeds up startup when opening the same geometry next time). It is passed to <a class="el" href="classrr_1_1_r_r_collider.html#a7ff4c935e7f46b318e34f4b155fd30ba" title="Creates and returns collider, acceleration structure for finding ray x mesh intersections.">RRCollider::create()</a>, so default nullptr caches in temp, "*" or any other invalid path disables caching, any valid is path where to cache colliders. </td></tr>
    <tr><td class="paramname">intersectTechnique</td><td>Intersection technique used by solver. Techniques differ by speed and memory requirements. </td></tr>
    <tr><td class="paramname">copyFrom</td><td>Should stay nullptr (used by sceneViewer to reuse multiObject and smoothing from old solver). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf411cdda000cf5d3fc2c1eebacfa754" name="acf411cdda000cf5d3fc2c1eebacfa754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf411cdda000cf5d3fc2c1eebacfa754">&#9670;&#160;</a></span>getStaticObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp; rr::RRSolver::getStaticObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns static contents of scene, all static objects at once. It is very fast, returning reference to existing collection. </p>

</div>
</div>
<a id="a82c672d0e33e98ded005555f735495e1" name="a82c672d0e33e98ded005555f735495e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c672d0e33e98ded005555f735495e1">&#9670;&#160;</a></span>setDynamicObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::setDynamicObjects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp;&#160;</td>
          <td class="paramname"><em>objects</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets dynamic contents of scene, all dynamic objects at once. Only objects with <a class="el" href="classrr_1_1_r_r_object.html#afdc417da52b075c4868fe3ce4cc4c846" title="Is this object dynamic = is it safe to modify it?">RRObject::isDynamic</a> are taken, the rest is ignored. </p>
<p>Solver creates internal set of dynamic objects, by taking only those of your objects with isDynamic=true, you can query accepted objects by <a class="el" href="classrr_1_1_r_r_solver.html#ad55d0db85edda9c25444598a1a892136" title="Returns dynamic contents of scene, all dynamic objects at once. It is very fast, returning reference ...">getDynamicObjects()</a>. Solver preserves your order of dynamic objects. If you pass only dynamic objects, then <a class="el" href="classrr_1_1_r_r_solver.html#ad55d0db85edda9c25444598a1a892136" title="Returns dynamic contents of scene, all dynamic objects at once. It is very fast, returning reference ...">getDynamicObjects()</a>[n]==objects[n]. Solver reads isDynamic only in this function; if you change it later, it won't have any effect.</p>
<p>Unlike static objects, you may freely edit dynamic objects between frames. If you want to add or remove objects, call <a class="el" href="classrr_1_1_r_r_solver.html#a82c672d0e33e98ded005555f735495e1" title="Sets dynamic contents of scene, all dynamic objects at once. Only objects with RRObject::isDynamic ar...">setDynamicObjects()</a> again. If you only edit object properties, there's no need to call it again.</p>
<p>Dynamic objects affect realtime lighting, they are ignored when building static lightmaps. API does not even let you build lightmaps for dynamic objects, as it does not make big sense, dynamic objects are better illuminated by diffuse and specular reflection maps, see <a class="el" href="classrr_1_1_r_r_solver.html#a430bb0184e06c57877d821ea26e02bf3" title="Calculates and updates object&#39;s environment map, stored in given layer of given illumination.">updateEnvironmentMap()</a>. If you really have to bake lightmap for dynamic object, make the object static first; if you also need the object to have no effect on other static objects (no shadows etc), but still receive light/shadows from other static objects, make the object transparent during lightmap baking (via material-&gt;specularTransmittance). </p>

</div>
</div>
<a id="ad55d0db85edda9c25444598a1a892136" name="ad55d0db85edda9c25444598a1a892136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55d0db85edda9c25444598a1a892136">&#9670;&#160;</a></span>getDynamicObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> &amp; rr::RRSolver::getDynamicObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns dynamic contents of scene, all dynamic objects at once. It is very fast, returning reference to existing collection. </p>

</div>
</div>
<a id="af541f652f8386e0f939b2afaa41604a1" name="af541f652f8386e0f939b2afaa41604a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af541f652f8386e0f939b2afaa41604a1">&#9670;&#160;</a></span>getObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> rr::RRSolver::getObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns collection of all objects in scene. It is slower than <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a> and <a class="el" href="classrr_1_1_r_r_solver.html#ad55d0db85edda9c25444598a1a892136" title="Returns dynamic contents of scene, all dynamic objects at once. It is very fast, returning reference ...">getDynamicObjects()</a>, returning newly allocated collection. </p>

</div>
</div>
<a id="a8c49e407ca61d7387f8699edef892db9" name="a8c49e407ca61d7387f8699edef892db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c49e407ca61d7387f8699edef892db9">&#9670;&#160;</a></span>getObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * rr::RRSolver::getObject </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns given object or nullptr for out of range index. Objects are indexed from 0, static objects go first, then dynamic. </p>

</div>
</div>
<a id="a8ecb9d07b25f43603aa5184896c756fa" name="a8ecb9d07b25f43603aa5184896c756fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecb9d07b25f43603aa5184896c756fa">&#9670;&#160;</a></span>getCollider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_collider.html">RRCollider</a> * rr::RRSolver::getCollider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns collider for whole scene, both static and dynamic. </p>
<p>Never returns nullptr, even if scene is empty. Returned collider is valid until next <a class="el" href="classrr_1_1_r_r_solver.html#a8ecb9d07b25f43603aa5184896c756fa" title="Returns collider for whole scene, both static and dynamic.">getCollider()</a> call. It is owned by solver, you don't delete it.</p>
<p>This is slightly heavier operation as it updates acceleration structures. Therefore recommended usage is to call it once, use returned collider many times (ideally until scene changes) rather than getting collider for each ray.</p>
<p>When a dynamic object moves, call reportDirectIlluminationChange(-1,...) to update illumination. As a sideeffect, solver marks collider dirty and builds new one next time you call <a class="el" href="classrr_1_1_r_r_solver.html#a8ecb9d07b25f43603aa5184896c756fa" title="Returns collider for whole scene, both static and dynamic.">getCollider()</a>. If you don't get correct intersections, verify that reportDirectIlluminationChange(-1,...) is called after object movement.</p>
<p>Thread safe: no, you must not use solver or modify objects while <a class="el" href="classrr_1_1_r_r_solver.html#a8ecb9d07b25f43603aa5184896c756fa" title="Returns collider for whole scene, both static and dynamic.">getCollider()</a> executes. Returned collider is thread safe as usual, many threads can calculate intersections at once.</p>
<p>Returned collider does not necessarily know about objects, so ray.hitObjects is not necessarily set after intersection. If you need to know what single object was intersected, follow instructions</p><ul>
<li>before calling intersect() on this collider, do ray.hitObject = solver-&gt;<a class="el" href="classrr_1_1_r_r_solver.html#ad39fe361d8f1bef589f6af6d59827e9a" title="Returns multiObject created by merging all static objects in scene, see setStaticObjects().">getMultiObject()</a>;</li>
<li>when intersect() on this collider returns true, do ray.convertHitFromMultiToSingleObject(solver);</li>
</ul>
<p>If you can afford to ignore dynamic objects, collide with static objects only, it's faster. To collide with static objects only, use <a class="el" href="classrr_1_1_r_r_solver.html#ad39fe361d8f1bef589f6af6d59827e9a" title="Returns multiObject created by merging all static objects in scene, see setStaticObjects().">getMultiObject()</a>-&gt;<a class="el" href="classrr_1_1_r_r_solver.html#a8ecb9d07b25f43603aa5184896c756fa" title="Returns collider for whole scene, both static and dynamic.">getCollider()</a>. </p>

</div>
</div>
<a id="af550c02b32fff5b482ec3191315c3e40" name="af550c02b32fff5b482ec3191315c3e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af550c02b32fff5b482ec3191315c3e40">&#9670;&#160;</a></span>getAABB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * rr::RRSolver::getAABB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *&#160;</td>
          <td class="paramname"><em>_mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *&#160;</td>
          <td class="paramname"><em>_maxi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *&#160;</td>
          <td class="paramname"><em>_center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills bounding box of all objects in solver. </p>
<dl class="section return"><dt>Returns</dt><dd>Some planar dynamic objects (like ocean surface) would make box very large, so we exclude them from calculation. In such case, pointer to one of excluded planes is returned. </dd></dl>

</div>
</div>
<a id="ae73feb78b078b1e760d48841e8d268a3" name="ae73feb78b078b1e760d48841e8d268a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73feb78b078b1e760d48841e8d268a3">&#9670;&#160;</a></span>processBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::processBuffers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; *&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(<a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does something once for each buffer in solver's materials, lights, environment and illumination layers. </p>
<p>Can be used to gather all texture filenames, to pause all videos etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layers</td><td>Illumination from given layers will be processed too. </td></tr>
    <tr><td class="paramname">func</td><td>Code to run for each buffer once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b762b6fab0980d9c976108a339ea398" name="a1b762b6fab0980d9c976108a339ea398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b762b6fab0980d9c976108a339ea398">&#9670;&#160;</a></span>calculate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::calculate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_calculate_parameters.html">CalculateParameters</a> *&#160;</td>
          <td class="paramname"><em>params</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and improves indirect illumination on static objects. </p>
<p>Call this function once per frame while rendering realtime GI. You can call it even when not rendering, to improve GI solution inside solver (so that you have it ready when you render scene later). On the other hand, don't call it when you don't need realtime GI, for example when rendering offline baked lightmaps, it would still spend time calculating realtime GI even if you don't need it.</p>
<p>It helps to improve performance if you don't repeatedly render scene that doesn't change, for example in game editor. Note that user can't see any difference, you only save time and power by not rendering the same image again. <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a> uses these periods for more intense calculations, creating higher quality illumination. It detects these periods from you not calling <a class="el" href="classrr_1_1_r_r_solver.html#ac19431779f0500c3a9ba52a134a406b1" title="Reports that scene has changed and direct or global illumination should be updated.">reportDirectIlluminationChange()</a> and <a class="el" href="classrr_1_1_r_r_solver.html#a2922658d0d2630440bf0f84f29edb645" title="Reports interaction between user and application.">reportInteraction()</a>.</p>
<p>For games, it is recommended to call <a class="el" href="classrr_1_1_r_r_solver.html#a5ed01d3ecb9260b56278dda32097bff9" title="Load and start Fireball.">loadFireball()</a> before first <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a>. Without fireball, first <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a> takes longer, solver internals are initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Optional calculation parameters. Currently used only by Fireball. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html#aa269184b2d91a2c84cc17ffa0bd03d83">rr_gl::RRSolverGL</a>.</p>

</div>
</div>
<a id="a8fa3e175d154100f2b8aa3ac2d7c2a55" name="a8fa3e175d154100f2b8aa3ac2d7c2a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa3e175d154100f2b8aa3ac2d7c2a55">&#9670;&#160;</a></span>getSolutionVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRSolver::getSolutionVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns version of global illumination solution. </p>
<p>You may use this number to avoid unnecessary updates of illumination buffers. Store version together with your illumination buffers and don't update them (<a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009" title="For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-verte...">updateLightmaps()</a>) until this number changes.</p>
<p>Version may be incremented only by <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a>. </p>

</div>
</div>
<a id="a4aaa9ea4b5f70eb96a3313a5bf1fd592" name="a4aaa9ea4b5f70eb96a3313a5bf1fd592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaa9ea4b5f70eb96a3313a5bf1fd592">&#9670;&#160;</a></span>updateLightmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRSolver::updateLightmap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objectNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>lightmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>directionalLightmap</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>bentNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_update_parameters.html">UpdateParameters</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_filtering_parameters.html">FilteringParameters</a> *&#160;</td>
          <td class="paramname"><em>filtering</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For single static object, calculates and updates lightmap and/or bent normals; in per-pixel or per-vertex; with direct, indirect or global illumination. </p>
<p>This is universal update for both per-pixel and per-vertex buffers. Type and format of data produced depends only on type and format of buffer you provide. Combinations like per-pixel colors, per-vertex bent normals are supported too. Format of buffer is preserved.</p>
<p>For 2d texture buffer (lightmap, bentNormalMap), uv channel material-&gt;lightmap.texcoord is used. All uv coordinates must be in 0..1 range and two triangles must not overlap in texture space. If it's not satisfied, contents of created lightmap is undefined.</p>
<p>Thread safe: no, but there's no need to run it from multiple threads at the same time, all cores are used automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectNumber</td><td>Number of object in this scene. Object numbers are defined by order in which you pass objects to <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">setStaticObjects()</a>. In case of vertex buffer, -1 is allowed for multiobject with whole static scene. </td></tr>
    <tr><td class="paramname">lightmap</td><td>Buffer for storing calculated illumination. <br  />
 May be nullptr. <br  />
 Types supported: BT_VERTEX_BUFFER, BT_2D_TEXTURE, however with <a class="el" href="calc_fireball.html">Fireball</a>, only vertex buffer is supported. <br  />
 Formats supported: All color formats, RGB, RGBA, bytes, floats. Data are converted to format of buffer. <br  />
 Lightmap could contain direct, indirect or global illumination, depending on parameters you set in params. </td></tr>
    <tr><td class="paramname">directionalLightmap</td><td>Pointer to array of three lightmaps for storing calculated directional illumination. <br  />
 Compatible with Unreal Engine 3 directional lightmaps. <br  />
 May be nullptr. <br  />
 Supports the same types and formats as parameter 'lightmap'. </td></tr>
    <tr><td class="paramname">bentNormals</td><td>Buffer for storing calculated bent normals, compact representation of directional information. <br  />
 May be nullptr. <br  />
 RGB values (range 0..1) are calculated from XYZ worldspace normalized normals (range -1..1) by this formula: (XYZ+1)/2. <br  />
 Supports the same types and formats as parameter 'lightmap'. </td></tr>
    <tr><td class="paramname">params</td><td>Parameters of the update process. Set nullptr for default parameters that specify very fast realtime/preview update. </td></tr>
    <tr><td class="paramname">filtering</td><td>Parameters of lightmap filtering, set nullptr for default ones. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of lightmaps and bent normal maps updated, 0 1 or 2. If it's lower than you expect, read system messages (<a class="el" href="classrr_1_1_r_r_reporter.html" title="Reporting messages.">RRReporter</a>) for more details on possible failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In comparison with more general <a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009" title="For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-verte...">updateLightmaps()</a> function, this one lacks paramsIndirect. However, you can still include indirect illumination while updating single lightmap, see <a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009" title="For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-verte...">updateLightmaps()</a> remarks. </dd></dl>

</div>
</div>
<a id="a123529338f03195a6233b53e5100a009" name="a123529338f03195a6233b53e5100a009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123529338f03195a6233b53e5100a009">&#9670;&#160;</a></span>updateLightmaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRSolver::updateLightmaps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerLightmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerDirectionalLightmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerBentNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_update_parameters.html">UpdateParameters</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_filtering_parameters.html">FilteringParameters</a> *&#160;</td>
          <td class="paramname"><em>filtering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-vertex; with direct, indirect or global illumination. </p>
<p>This is more powerful full scene version of single object's <a class="el" href="classrr_1_1_r_r_solver.html#a4aaa9ea4b5f70eb96a3313a5bf1fd592" title="For single static object, calculates and updates lightmap and/or bent normals; in per-pixel or per-ve...">updateLightmap()</a>.</p>
<p>Usage:</p><ol type="1">
<li>create buffers of arbitrary types and formats (per-pixel, per-vertex, bytes, floats, rgb, rgba, physical scale, custom scale) and store them to <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a>[objectNumber]-&gt;illumination-&gt;getLayer(layerIndex)</li>
<li>call updatelightmaps()</li>
<li>enjoy buffers with computed lighting, you can do buffer-&gt;save(), buffer-&gt;lock(), renderer-&gt;render()...</li>
</ol>
<p>For 2d texture buffer (lightmap, bentNormalMap), uv channel material-&gt;lightmap.texcoord is used. All uv coordinates must be in 0..1 range and two triangles must not overlap in texture space. If it's not satisfied, contents of created lightmap is undefined.</p>
<p>Lightmap update is one of the most demanding functions in Lightsprint SDK. Its <a class="el" href="calc_offline.html#of_speed">time complexity</a> can be roughly predicted.</p>
<p>Thread safe: no, but there's no need to run it from multiple threads at the same time, all cores are used automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerLightmap</td><td>1 lightmap per object will be computed into existing buffers in this layer, <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a>[objectNumber]-&gt;illumination-&gt;getLayer(layerNumber). <br  />
 Negative number disables update of lightmaps. </td></tr>
    <tr><td class="paramname">layerDirectionalLightmap</td><td>3 directional lightmaps per object will be computed into existing buffers in this layer and two successive layers, <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a>[objectNumber]-&gt;illumination-&gt;getLayer(layerNumber). <br  />
 Negative number disables update of directional lightmaps. </td></tr>
    <tr><td class="paramname">layerBentNormals</td><td>Bent normals will be computed into existing buffers in this layer, <a class="el" href="classrr_1_1_r_r_solver.html#acf411cdda000cf5d3fc2c1eebacfa754" title="Returns static contents of scene, all static objects at once. It is very fast, returning reference to...">getStaticObjects()</a>[objectNumber]-&gt;illumination-&gt;getLayer(layerBentNormals). <br  />
 Negative number disables update of bent normals. </td></tr>
    <tr><td class="paramname">params</td><td>Parameters of the update process. With nullptr or quality=0, update is realtime, but options are limited, only vertex buffers are filed with indirect illumination in physical scale, read from current solution in solver. With quality&gt;0, you get much more flexibility, but update is non-realtime. </td></tr>
    <tr><td class="paramname">filtering</td><td>Parameters of lightmap filtering, set nullptr for default ones. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of lightmaps updated. If it's lower than you expect, read system messages (<a class="el" href="classrr_1_1_r_r_reporter.html" title="Reporting messages.">RRReporter</a>) for more details on possible failure. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>As a byproduct of calculation with indirect ilumination, internal state of solver (current solution) is updated, so that it holds computed indirect illumination for sources and quality specified in params. Internal state is properly updated even when buffers don't exist (so no other output is produced). Following <a class="el" href="classrr_1_1_r_r_solver.html#a4aaa9ea4b5f70eb96a3313a5bf1fd592" title="For single static object, calculates and updates lightmap and/or bent normals; in per-pixel or per-ve...">updateLightmap()</a> will include this indirect lighting into computed buffer if you call it with params-&gt;useCurrentSolution=true. </dd>
<dd>
Update of selected objects (rather than all objects) is supported in multiple ways, use one of them. All three ways produce the same quality, but first one may be faster in some cases.<ul>
<li>create buffers for selected objects, make sure other buffers are nullptr and call <a class="el" href="classrr_1_1_r_r_solver.html#a123529338f03195a6233b53e5100a009" title="For all static objects, calculates and updates lightmap and/or bent normal; in per-pixel or per-verte...">updateLightmaps()</a></li>
<li>if you don't need indirect illumination, simply call <a class="el" href="classrr_1_1_r_r_solver.html#a4aaa9ea4b5f70eb96a3313a5bf1fd592" title="For single static object, calculates and updates lightmap and/or bent normals; in per-pixel or per-ve...">updateLightmap()</a> for all selected objects</li>
<li>call updateLightmaps(-1,-1,params,nullptr) once to update current solution, call updateLightmap(params with useCurrentSolution=true) for all selected objects </li>
</ul>
</dd>
<dd>
Sharing one lightmap by multiple objects is not supported out of the box. Please consult us for possible solutions. </dd></dl>

</div>
</div>
<a id="a430bb0184e06c57877d821ea26e02bf3" name="a430bb0184e06c57877d821ea26e02bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430bb0184e06c57877d821ea26e02bf3">&#9670;&#160;</a></span>updateEnvironmentMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRSolver::updateEnvironmentMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_object_illumination.html">RRObjectIllumination</a> *&#160;</td>
          <td class="paramname"><em>illumination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>layerEnvironment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>layerLightmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>layerAmbientMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates and updates object's environment map, stored in given layer of given illumination. </p>
<p>Function updates existing buffer, it does nothing if buffer does not exist. You can allocate buffers</p><ul>
<li>automatically, by <a class="el" href="classrr_1_1_r_r_solver.html#aaf0703d3ee895467659bbf3ebd9e198c" title="Allocates buffers for realtime GI illumination of objects in solver.">allocateBuffersForRealtimeGI()</a></li>
<li>or manually by illumination-&gt;getLayer() = <a class="el" href="classrr_1_1_r_r_buffer.html#a3e3d651ad26701f619da5017646793c8" title="Creates buffer in system memory. See reset() for parameter details. Returns nullptr when parameters a...">RRBuffer::create()</a></li>
</ul>
<p>Generated environment can be used for illumination of both static and dynamic objects.</p>
<p>Function is fast for low resolution cubemaps, suitable for use in realtime applications. It is safe to call it often, it returns quickly if it detects that illumination is already up to date. For high resolution (more than approximately 32x32x6) envmaps, consider calling RRSolverGL::updateEnvironmentMap() instead, it is faster.</p>
<p>Function reads static scene illumination, so don't call it before <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a>, otherwise dynamic objects will reflect light from previous frame, or no light at all. If you have to update envmaps before <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a>, use RRSolverGL::updateEnvironmentMap().</p>
<p>Thread safe: yes, may be called from multiple threads at the same time (but there's no need as it uses all cores internally)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">illumination</td><td>Object's illumination to be updated. (It's not necessary to have <a class="el" href="classrr_1_1_r_r_object.html" title="Common interface for all proprietary object formats.">RRObject</a> adapter for dynamic object, but its <a class="el" href="classrr_1_1_r_r_object_illumination.html" title="Data structure with object&#39;s illumination and more.">RRObjectIllumination</a> must exist.) </td></tr>
    <tr><td class="paramname">layerEnvironment</td><td>Number of layer with environment maps, they are addressed by illumination-&gt;getLayer(layerEnvironment). </td></tr>
    <tr><td class="paramname">layerLightmap</td><td>Number of layer with lightmaps, they are addressed by illumination-&gt;getLayer(layerLightmap). Unused by default implementation. </td></tr>
    <tr><td class="paramname">layerAmbientMap</td><td>Number of layer with ambient maps, they are addressed by illumination-&gt;getLayer(layerAmbientMap). Unused by default implementation. While default implementation reads illumination directly from solver, access to lightmaps and/or ambient maps allows other implementations (<a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html#a9414bb6c343badaccc7a2e871d3cecbb" title="Calculates and updates object&#39;s environment map, stored in given layer of given illumination.">rr_gl::RRSolverGL::updateEnvironmentMap()</a>) to read illumination from lights and these maps instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of environment maps updated, 0 or 1. </dd></dl>

<p>Reimplemented in <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html#a9414bb6c343badaccc7a2e871d3cecbb">rr_gl::RRSolverGL</a>.</p>

</div>
</div>
<a id="a2cccd12911c638248f22b8143f805d56" name="a2cccd12911c638248f22b8143f805d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cccd12911c638248f22b8143f805d56">&#9670;&#160;</a></span>getTriangleMeasure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRSolver::getTriangleMeasure </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_radiometric_measure.html">RRRadiometricMeasure</a>&#160;</td>
          <td class="paramname"><em>measure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads illumination of triangle's vertex in units given by measure. </p>
<p>Reads results in format suitable for fast vertex based rendering without subdivision. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangle</td><td>Index of triangle in multiobject you want to get results for. </td></tr>
    <tr><td class="paramname">vertex</td><td>Index of triangle's vertex you want to get results for. Valid vertices are 0, 1, 2. For invalid vertex number, average value for whole triangle is taken instead of smoothed value in vertex. </td></tr>
    <tr><td class="paramname">measure</td><td>Specifies what to measure, using what units. </td></tr>
    <tr><td class="paramname">out</td><td>For valid inputs, illumination level is stored here. For invalid inputs, nothing is changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if out was successfully filled. False may be caused by invalid inputs. </dd></dl>

</div>
</div>
<a id="aa969ac391ce322c93a282b960a02a3b7" name="aa969ac391ce322c93a282b960a02a3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa969ac391ce322c93a282b960a02a3b7">&#9670;&#160;</a></span>reportMaterialChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::reportMaterialChange </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dirtyShadows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dirtyGI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports that appearance of one or more materials in static objects has changed. </p>
<p>Call this when you changed material properties of static objects. It is not necessary to report change in dynamic objects (it would only cost time, without affecting GI).</p>
<p>Note that solver creates physically validated copy of all materials in static objects, you can edit both original materials (in custom scale, used for realtime rendering) and validated copies (in physical scale, used for indirect illumination), but you are responsible for keeping them in sync. Complete code sequence to edit original material, synchronize copy in solver and report change could look like </p><div class="fragment"><div class="line">... here you edit material<span class="stringliteral">&#39;s color</span></div>
<div class="line"><span class="stringliteral">material-&gt;convertToLinear(solver-&gt;getColorSpace()); // converts material&#39;</span>s color to colorLinear</div>
<div class="line">solver-&gt;reallocateBuffersForRealtimeGI(); <span class="comment">// allocates specular reflection cubes if you add specular</span></div>
<div class="line">solver-&gt;reportMaterialChange();</div>
</div><!-- fragment --><p> If you make e.g. red color and blue colorLinear, realtime renderer will render red material, but reflected light will be blue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirtyShadows</td><td>Set this if you want shadows updated. Shadows may need update after change in material transparency. </td></tr>
    <tr><td class="paramname">dirtyGI</td><td>Set this if you want GI updated, or keep it false to save time. If you use <a class="el" href="calc_fireball.html">Fireball</a>, changes in emissive textures are recognized automatically, you don't have to report them, however, some other material changes won't affect GI until you rebuild fireball with <a class="el" href="classrr_1_1_r_r_solver.html#a42ce6646e5934547e22aea4e5ea4d98d" title="Build and start Fireball. Optionally save it to file.">buildFireball()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac19431779f0500c3a9ba52a134a406b1" name="ac19431779f0500c3a9ba52a134a406b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19431779f0500c3a9ba52a134a406b1">&#9670;&#160;</a></span>reportDirectIlluminationChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::reportDirectIlluminationChange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lightIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dirtyShadows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dirtyGI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dirtyRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports that scene has changed and direct or global illumination should be updated. </p>
<p>Call this function when light moves, changes color etc.. or when geometry changes, so that shadows and/or GI should be updated. Note that direct illumination changes also when dynamic objects move, call it with lightIndex -1 in such case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>Light number in list of lights, see <a class="el" href="classrr_1_1_r_r_solver.html#a86bfd7935c0e55b684828bfb0f5d9bf8" title="Sets lights in scene, all at once.">setLights()</a>. If geometry changes, pass -1, change will be reported to all lights in solver. </td></tr>
    <tr><td class="paramname">dirtyShadows</td><td>Tells that direct shadows should be updated. Generic <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a> uses it only to invalidate collider returned by <a class="el" href="classrr_1_1_r_r_solver.html#a8ecb9d07b25f43603aa5184896c756fa" title="Returns collider for whole scene, both static and dynamic.">getCollider()</a> (because when shadows need update, it's most likely because geometry did change); subclasses (e.g. <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html" title="Implementation of rr::RRSolver generic GPU operations using OpenGL 2.0.">rr_gl::RRSolverGL</a>) use it also to update light's shadowmaps. </td></tr>
    <tr><td class="paramname">dirtyGI</td><td>Tells that global illumination should be updated. Generic <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a> ignores it, but subclasses (e.g. <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html" title="Implementation of rr::RRSolver generic GPU operations using OpenGL 2.0.">rr_gl::RRSolverGL</a>) use it to redetect appropriate direct irradiances and call <a class="el" href="classrr_1_1_r_r_solver.html#a3769d618693b82f168fe3cb8f91b78c8" title="Sets custom irradiance for all static triangles in scene.">setDirectIllumination()</a>. You can save time by setting false when changes in scene were so small, that change in GI would be hardly visible. This is usually case when objects move, but lights stay static or nearly static - moving objects have much weaker global effects than moving lights. </td></tr>
    <tr><td class="paramname">dirtyRange</td><td>Tells that shadowmapping near/far range should be updated. Near should be small enough to not clip objects, but not smaller (it would increase shadow bias). Solver recalculates it on demand from distance of nearby objects. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html#a150693ee51f20809ba5bf0fdf33cde66">rr_gl::RRSolverGL</a>.</p>

</div>
</div>
<a id="a2922658d0d2630440bf0f84f29edb645" name="a2922658d0d2630440bf0f84f29edb645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2922658d0d2630440bf0f84f29edb645">&#9670;&#160;</a></span>reportInteraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::reportInteraction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports interaction between user and application. </p>
<p>This is useful for better CPU utilization in non-interactive periods of life of your application. Call it each time user hits key, moves mouse etc, or animation frame is played. <br  />
<br  />
 When called often, solver calculates illumination in small batches to preserve realtime performance. This is typical mode for games. <br  />
<br  />
 When not called at all, there's no interaction between user and application and solver increases calculation batches up to 100ms at once to better utilize CPU. This happens for example in game editor, when level designer stops moving mouse. </p>

</div>
</div>
<a id="a42ce6646e5934547e22aea4e5ea4d98d" name="a42ce6646e5934547e22aea4e5ea4d98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ce6646e5934547e22aea4e5ea4d98d">&#9670;&#160;</a></span>buildFireball()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRSolver::buildFireball </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>avgRaysPerTriangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build and start Fireball. Optionally save it to file. </p>
<p>Builds Fireball from scratch, starts it and optionally saves it to file. Later you can load saved file and start Fireball faster, see <a class="el" href="classrr_1_1_r_r_solver.html#a5ed01d3ecb9260b56278dda32097bff9" title="Load and start Fireball.">loadFireball()</a>. This function must be called after <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">setStaticObjects()</a>, because it depends on static objects in scene. It doesn't depend on lights end environment.</p>
<p>Build complexity is O( avgRaysPerTriangle * t * log(t) ) where t is number of triangles in static objects.</p>
<p><a class="el" href="calc_fireball.html">Fireball</a> is faster, higher quality, smaller, realtime only solver; it is highly recommended for games. When used, non-realtime functions like updateLightmaps(some params..) are not supported, but realtime functions like updateLightmaps(other params..) and <a class="el" href="classrr_1_1_r_r_solver.html#a430bb0184e06c57877d821ea26e02bf3" title="Calculates and updates object&#39;s environment map, stored in given layer of given illumination.">updateEnvironmentMap()</a> are faster and produce better results using less memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avgRaysPerTriangle</td><td>Average number of rays per triangle used to compute form factors. Higher number = longer calculation, higher quality results, bigger file. </td></tr>
    <tr><td class="paramname">filename</td><td>Data precomputed for current static scene will be saved to this file. If empty, automatically generated name (in temp directory) is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. For better consistency, if save (disk operation) fails, Fireball is not started. </dd></dl>

</div>
</div>
<a id="a5ed01d3ecb9260b56278dda32097bff9" name="a5ed01d3ecb9260b56278dda32097bff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed01d3ecb9260b56278dda32097bff9">&#9670;&#160;</a></span>loadFireball()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRSolver::loadFireball </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyPerfectMatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load and start Fireball. </p>
<p>Loads and starts Fireball previously saved by <a class="el" href="classrr_1_1_r_r_solver.html#a42ce6646e5934547e22aea4e5ea4d98d" title="Build and start Fireball. Optionally save it to file.">buildFireball()</a>. This function should be called before <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a> to avoid unnecessary operations.</p>
<p><a class="el" href="calc_fireball.html">Fireball</a> is faster, higher quality, smaller, realtime only solver; it is highly recommended for games. When used, non-realtime functions like updateLightmaps(some params..) are not supported, but realtime functions like updateLightmaps(other params..) and <a class="el" href="classrr_1_1_r_r_solver.html#a430bb0184e06c57877d821ea26e02bf3" title="Calculates and updates object&#39;s environment map, stored in given layer of given illumination.">updateEnvironmentMap()</a> are faster and produce better results using less memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>File with data to load, previously created by <a class="el" href="classrr_1_1_r_r_solver.html#a42ce6646e5934547e22aea4e5ea4d98d" title="Build and start Fireball. Optionally save it to file.">buildFireball()</a>. If empty, automatically generated name is used (in your temp directory). </td></tr>
    <tr><td class="paramname">onlyPerfectMatch</td><td>Loads file only if it was built for exactly the same scene on the same CPU architecture. Applications that build fireball on end-user machines should use true. Applications that ship with fireball pre-built by developer should use true during development (so that any change in scene results in rebuild) and false on end-user machines (so that supplied fireball is always loaded even if scene seems different; difference may be caused by different floation point precision on end-user's system). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successful. </dd></dl>

</div>
</div>
<a id="a5426f4aac440ff01111af954f97c88b0" name="a5426f4aac440ff01111af954f97c88b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5426f4aac440ff01111af954f97c88b0">&#9670;&#160;</a></span>leaveFireball()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::leaveFireball </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch to non-Fireball solver that supports offline calculations. </p>

</div>
</div>
<a id="aab9cb70c8d406e62f7f508ad15d3204a" name="aab9cb70c8d406e62f7f508ad15d3204a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9cb70c8d406e62f7f508ad15d3204a">&#9670;&#160;</a></span>getInternalSolverType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_solver.html#a26a8982640b26261d1c061a072b4536a">InternalSolverType</a> rr::RRSolver::getInternalSolverType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns type of active internal solver. </p>

</div>
</div>
<a id="a3eecb326fcb191ad6274bcafef8d14c2" name="a3eecb326fcb191ad6274bcafef8d14c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eecb326fcb191ad6274bcafef8d14c2">&#9670;&#160;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::checkConsistency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks consistency of data in solver and reports problems found using <a class="el" href="classrr_1_1_r_r_reporter.html" title="Reporting messages.">RRReporter</a>. </p>
<p>While all precomputed lighting and cheap-to-detect realtime lighting problems are reported immediately even without <a class="el" href="classrr_1_1_r_r_solver.html#a3eecb326fcb191ad6274bcafef8d14c2" title="Checks consistency of data in solver and reports problems found using RRReporter.">checkConsistency()</a>, more expensive realtime lighting checks are done only on this request. </p>

</div>
</div>
<a id="ae92b97bd386ca7f2f7ae0b16c98feecc" name="ae92b97bd386ca7f2f7ae0b16c98feecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92b97bd386ca7f2f7ae0b16c98feecc">&#9670;&#160;</a></span>containsLightSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRSolver::containsLightSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if solver contains at least one light source. </p>
<p>This could be enabled light, emissive material or environment/skybox. Simple presence of light source is tested, it is not guaranteed that light source actually affects objects in scene. </p>

</div>
</div>
<a id="af76c4e9351f293d3e9b16dc26ee1565f" name="af76c4e9351f293d3e9b16dc26ee1565f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76c4e9351f293d3e9b16dc26ee1565f">&#9670;&#160;</a></span>containsRealtimeGILightSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRSolver::containsRealtimeGILightSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if solver contains at least one realtime GI capable light source. </p>
<p>All light sources are realtime GI capable with Fireball, the only light source ignored by Architect solver is environment/skybox. </p>

</div>
</div>
<a id="aaf0703d3ee895467659bbf3ebd9e198c" name="aaf0703d3ee895467659bbf3ebd9e198c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0703d3ee895467659bbf3ebd9e198c">&#9670;&#160;</a></span>allocateBuffersForRealtimeGI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRSolver::allocateBuffersForRealtimeGI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerLightmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerEnvironment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>diffuseEnvMapSize</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>specularEnvMapSize</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>refractEnvMapSize</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocateNewBuffers</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changeExistingBuffers</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>specularThreshold</em> = <code>0.2f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depthThreshold</em> = <code>0.1f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates buffers for realtime GI illumination of objects in solver. </p>
<p>See <a class="el" href="classrr_1_1_r_r_objects.html#a004a05fee60d5e69f615a79dea754469" title="Allocates buffers for realtime GI illumination.">RRObjects::allocateBuffersForRealtimeGI()</a> for parameters and additional information. </p>

</div>
</div>
<a id="ad39fe361d8f1bef589f6af6d59827e9a" name="ad39fe361d8f1bef589f6af6d59827e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39fe361d8f1bef589f6af6d59827e9a">&#9670;&#160;</a></span>getMultiObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * rr::RRSolver::getMultiObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns multiObject created by merging all static objects in scene, see <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">setStaticObjects()</a>. </p>

</div>
</div>
<a id="ad935aad59faca59309309b18a7d7c306" name="ad935aad59faca59309309b18a7d7c306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad935aad59faca59309309b18a7d7c306">&#9670;&#160;</a></span>pathTraceFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::pathTraceFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_camera.html">RRCamera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_buffer.html">RRBuffer</a> *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>accumulate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_path_tracing_parameters.html">PathTracingParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders scene image into given frame, using pathtracer. </p>
<p>Pathtracing is slower and noisier than rasterization, but it offers higher quality if you give it enough time. Pathtraced images contain random noise, so if you accumulate multiple noisy images, you get smoother one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td>Camera to view scene from. </td></tr>
    <tr><td class="paramname">frame</td><td>Framebuffer to render to. If you accumulate multiple frames into single buffer, format should be BF_RGBF or BF_RGBAF, to avoid color banding. </td></tr>
    <tr><td class="paramname">accumulate</td><td>Number of frames already accumulated in frame. Increase this number each time you call pathTraceFrame, zero it only when camera or scene change. </td></tr>
    <tr><td class="paramname">parameters</td><td>Additional parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72cd29d74fa8d3275b19f3096b997a81" name="a72cd29d74fa8d3275b19f3096b997a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cd29d74fa8d3275b19f3096b997a81">&#9670;&#160;</a></span>calculateDirtyLights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRSolver::calculateDirtyLights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_solver_1_1_calculate_parameters.html">CalculateParameters</a> *&#160;</td>
          <td class="paramname"><em>params</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional extension of <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a>, sets dirty flags in lights when it detects change in transparency texture or video. </p>
<p>Realtime GI implementations (like <a class="el" href="classrr__gl_1_1_r_r_solver_g_l.html" title="Implementation of rr::RRSolver generic GPU operations using OpenGL 2.0.">rr_gl::RRSolverGL</a>) call it from <a class="el" href="classrr_1_1_r_r_solver.html#a1b762b6fab0980d9c976108a339ea398" title="Calculates and improves indirect illumination on static objects.">calculate()</a>, before updating shadowmaps. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a78f6cde638cc3ac087a6424f251eedce" name="a78f6cde638cc3ac087a6424f251eedce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f6cde638cc3ac087a6424f251eedce">&#9670;&#160;</a></span>PathtracerWorker</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class PathtracerWorker</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab8ae312d9c953045b0d06e91d41c662b" name="ab8ae312d9c953045b0d06e91d41c662b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ae312d9c953045b0d06e91d41c662b">&#9670;&#160;</a></span>aborting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRSolver::aborting</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes other solver functions abort, returning quickly with bogus results. </p>
<p>You may set/unset it asynchronously, from other threads. Solver only reads it, never modifies it, so don't forget to clear it after abort. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerr.html">rr</a></li><li class="navelem"><a class="el" href="classrr_1_1_r_r_solver.html">RRSolver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
