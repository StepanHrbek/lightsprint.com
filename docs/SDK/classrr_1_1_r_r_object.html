<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LightsprintSDK: rr::RRObject Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LightsprintSDK<span id="projectnumber">&#160;2021.08.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrr_1_1_r_r_object.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classrr_1_1_r_r_object-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rr::RRObject Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;RRObject.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rr::RRObject:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrr_1_1_r_r_object.png" usemap="#rr::RRObject_map" alt=""/>
  <map id="rr::RRObject_map" name="rr::RRObject_map">
<area href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html" title="When used as base class, object copying is not allowed." alt="rr::RRUniformlyAllocatedNonCopyable" shape="rect" coords="0,56,227,80"/>
<area href="classrr_1_1_r_r_uniformly_allocated.html" title="When used as base class, delete works correctly without regard who calls it." alt="rr::RRUniformlyAllocated" shape="rect" coords="0,0,227,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_object_1_1_face_group.html">FaceGroup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object_1_1_face_groups.html">FaceGroups</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_object_1_1_layer_parameters.html">LayerParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_object_1_1_lod_info.html">LodInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a172494894b8a58526c0921a79900cb8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a172494894b8a58526c0921a79900cb8a">RRObject</a> ()</td></tr>
<tr class="separator:a172494894b8a58526c0921a79900cb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d32525087f891a193fc65ea65b20b69"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a6d32525087f891a193fc65ea65b20b69">~RRObject</a> ()</td></tr>
<tr class="separator:a6d32525087f891a193fc65ea65b20b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426082c903ecccf4ada2a7288d1869c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrr_1_1_r_r_collider.html">RRCollider</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a426082c903ecccf4ada2a7288d1869c1">getCollider</a> () const</td></tr>
<tr class="separator:a426082c903ecccf4ada2a7288d1869c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08efb419accc43c924ab424194c552b4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a08efb419accc43c924ab424194c552b4">setCollider</a> (<a class="el" href="classrr_1_1_r_r_collider.html">RRCollider</a> *collider)</td></tr>
<tr class="separator:a08efb419accc43c924ab424194c552b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb20de4942034442c5d8519933ad8ba5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structrr_1_1_r_r_material.html">RRMaterial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#afb20de4942034442c5d8519933ad8ba5">getTriangleMaterial</a> (unsigned t, const class <a class="el" href="classrr_1_1_r_r_light.html">RRLight</a> *light, const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *receiver) const</td></tr>
<tr class="separator:afb20de4942034442c5d8519933ad8ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6574562e2be602cc78b7be5ce6d2e6dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a6574562e2be602cc78b7be5ce6d2e6dc">getPointMaterial</a> (unsigned t, <a class="el" href="structrr_1_1_r_r_vec2.html">RRVec2</a> uv, const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace, bool interpolated, <a class="el" href="structrr_1_1_r_r_point_material.html">RRPointMaterial</a> &amp;out) const</td></tr>
<tr class="separator:a6574562e2be602cc78b7be5ce6d2e6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf1282e77fcc3662aa99c30ffc4a5c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a2cf1282e77fcc3662aa99c30ffc4a5c7">getTriangleLod</a> (unsigned t, <a class="el" href="structrr_1_1_r_r_object_1_1_lod_info.html">LodInfo</a> &amp;out) const</td></tr>
<tr class="separator:a2cf1282e77fcc3662aa99c30ffc4a5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee3ef669ba8686394573d1986a1fc2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#abee3ef669ba8686394573d1986a1fc2b">setWorldMatrix</a> (const <a class="el" href="structrr_1_1_r_r_matrix3x4.html">RRMatrix3x4</a> *worldMatrix)</td></tr>
<tr class="separator:abee3ef669ba8686394573d1986a1fc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1467c412ae693b56d64ef6674765d8aa"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structrr_1_1_r_r_matrix3x4_ex.html">RRMatrix3x4Ex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a1467c412ae693b56d64ef6674765d8aa">getWorldMatrix</a> () const</td></tr>
<tr class="separator:a1467c412ae693b56d64ef6674765d8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2bba045fa36654ab3207f1b070005"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structrr_1_1_r_r_matrix3x4_ex.html">RRMatrix3x4Ex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a87f2bba045fa36654ab3207f1b070005">getWorldMatrixRef</a> () const</td></tr>
<tr class="separator:a87f2bba045fa36654ab3207f1b070005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765c4a5b1896229111db873cfe2d6a89"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a765c4a5b1896229111db873cfe2d6a89">getCustomData</a> (const char *<a class="el" href="classrr_1_1_r_r_object.html#ae62e11f403732dab321c944e2b32e47c">name</a>) const</td></tr>
<tr class="separator:a765c4a5b1896229111db873cfe2d6a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d64b4571ed8766b012c542afddb1780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a3d64b4571ed8766b012c542afddb1780">updateIlluminationEnvMapCenter</a> ()</td></tr>
<tr class="separator:a3d64b4571ed8766b012c542afddb1780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee59ea5370a7ee56750cd98cb9f38e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#acee59ea5370a7ee56750cd98cb9f38e3">createWorldSpaceMesh</a> () const</td></tr>
<tr class="separator:acee59ea5370a7ee56750cd98cb9f38e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6473be0334a9921ca42370a4796c8dc7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a6473be0334a9921ca42370a4796c8dc7">checkConsistency</a> (const char *objectNumber) const</td></tr>
<tr class="separator:a6473be0334a9921ca42370a4796c8dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa480460a88ebab2c2643f62cd70d0264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_collision_handler.html">RRCollisionHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#aa480460a88ebab2c2643f62cd70d0264">createCollisionHandlerFirstVisible</a> () const</td></tr>
<tr class="separator:aa480460a88ebab2c2643f62cd70d0264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904f6c29c3332a5a29edec82c516707f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrr_1_1_r_r_hash.html">RRHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a904f6c29c3332a5a29edec82c516707f">getHash</a> () const</td></tr>
<tr class="separator:a904f6c29c3332a5a29edec82c516707f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061f5d0225cadd3af16c31139bf78dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a061f5d0225cadd3af16c31139bf78dad">updateFaceGroupsFromTriangleMaterials</a> ()</td></tr>
<tr class="separator:a061f5d0225cadd3af16c31139bf78dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bff2b294f069672894296b3452f1d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a85bff2b294f069672894296b3452f1d4">recommendLayerParameters</a> (<a class="el" href="structrr_1_1_r_r_object_1_1_layer_parameters.html">RRObject::LayerParameters</a> &amp;layerParameters) const</td></tr>
<tr class="separator:a85bff2b294f069672894296b3452f1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrr_1_1_r_r_uniformly_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrr_1_1_r_r_uniformly_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated.html">rr::RRUniformlyAllocated</a></td></tr>
<tr class="memitem:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a073b837b152a4c54b8b581bd2e82ec08">operator new</a> (std::size_t n)</td></tr>
<tr class="separator:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a1f55fa066eee7b98a94c98fbecdbaeef">operator new[]</a> (std::size_t n)</td></tr>
<tr class="separator:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#ac0d7217fef84aacf42287c189423e15e">operator delete</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a42a7c29977989c72d78660bd487cc97e">operator delete[]</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3f8f05ccca8277a28c662bfae455500a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object_1_1_face_groups.html">FaceGroups</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a3f8f05ccca8277a28c662bfae455500a">faceGroups</a></td></tr>
<tr class="separator:a3f8f05ccca8277a28c662bfae455500a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9470dbf788a3ba154ad8507e15dbf3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object_illumination.html">RRObjectIllumination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#a9470dbf788a3ba154ad8507e15dbf3ad">illumination</a></td></tr>
<tr class="separator:a9470dbf788a3ba154ad8507e15dbf3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62e11f403732dab321c944e2b32e47c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_string.html">RRString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#ae62e11f403732dab321c944e2b32e47c">name</a></td></tr>
<tr class="separator:ae62e11f403732dab321c944e2b32e47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5105a2ba819b7b241f59c01546cba77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#aa5105a2ba819b7b241f59c01546cba77">enabled</a></td></tr>
<tr class="separator:aa5105a2ba819b7b241f59c01546cba77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc417da52b075c4868fe3ce4cc4c846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_object.html#afdc417da52b075c4868fe3ce4cc4c846">isDynamic</a></td></tr>
<tr class="separator:afdc417da52b075c4868fe3ce4cc4c846"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html">rr::RRUniformlyAllocatedNonCopyable</a></td></tr>
<tr class="memitem:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a2fb6eae4adda7ad435a7aa482d1005cd">RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a7c05e32bc9c7a711d579fc328cb3392a">~RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common interface for all proprietary object formats. </p>
<h1><a class="anchor" id="so1"></a>
Provided information</h1>
<p>RRObject provides information about</p><ul>
<li>materials and their assignment to faces, see <a class="el" href="classrr_1_1_r_r_object.html#a3f8f05ccca8277a28c662bfae455500a" title="Assignment of materials to triangles.">faceGroups</a></li>
<li>transformation matrix, see <a class="el" href="classrr_1_1_r_r_object.html#a1467c412ae693b56d64ef6674765d8aa" title="Returns object transformation from local to world space.">getWorldMatrix()</a> and <a class="el" href="classrr_1_1_r_r_object.html#abee3ef669ba8686394573d1986a1fc2b" title="Sets object transformation from local to world space.">setWorldMatrix()</a></li>
<li>collider for fast ray-mesh intersections, see <a class="el" href="classrr_1_1_r_r_object.html#a426082c903ecccf4ada2a7288d1869c1">getCollider()</a> and <a class="el" href="classrr_1_1_r_r_object.html#a08efb419accc43c924ab424194c552b4" title="Sets collider and mesh.">setCollider()</a></li>
<li>indirectly also mesh (via <a class="el" href="classrr_1_1_r_r_object.html#a426082c903ecccf4ada2a7288d1869c1">getCollider()</a>-&gt;getMesh())</li>
<li>LODs, see getTriangleLOD()</li>
<li>object illumination, see <a class="el" href="classrr_1_1_r_r_object.html#a9470dbf788a3ba154ad8507e15dbf3ad" title="Illumination of the object.">illumination</a></li>
<li>object name, see <a class="el" href="classrr_1_1_r_r_object.html#ae62e11f403732dab321c944e2b32e47c" title="Optional name of the object.">name</a></li>
</ul>
<h1><a class="anchor" id="so2"></a>
Links between objects</h1>
<p>solver and <a class="el" href="classrr_1_1_r_r_scene.html" title="3d scene.">RRScene</a> -&gt; <a class="el" href="classrr_1_1_r_r_objects.html" title="Set of objects with interface similar to std::vector.">RRObjects</a> -&gt; <a class="el" href="classrr_1_1_r_r_object.html" title="Common interface for all proprietary object formats.">RRObject</a> -&gt; <a class="el" href="classrr_1_1_r_r_collider.html" title="Finds ray - trianglemesh intersections.">RRCollider</a> -&gt; <a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a> <br  />
 where A -&gt; B means that</p><ul>
<li>A has pointer to B</li>
<li>there is no automatic reference counting in B and no automatic destruction of B from A <br  />
 This means that multiple objects may share one collider and mesh, multiple scenes or solvers may share one object etc. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a172494894b8a58526c0921a79900cb8a" name="a172494894b8a58526c0921a79900cb8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172494894b8a58526c0921a79900cb8a">&#9670;&#160;</a></span>RRObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rr::RRObject::RRObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d32525087f891a193fc65ea65b20b69" name="a6d32525087f891a193fc65ea65b20b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d32525087f891a193fc65ea65b20b69">&#9670;&#160;</a></span>~RRObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rr::RRObject::~RRObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a426082c903ecccf4ada2a7288d1869c1" name="a426082c903ecccf4ada2a7288d1869c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426082c903ecccf4ada2a7288d1869c1">&#9670;&#160;</a></span>getCollider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrr_1_1_r_r_collider.html">RRCollider</a> * rr::RRObject::getCollider </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns collider of underlying mesh. It is also access to mesh itself (via <a class="el" href="classrr_1_1_r_r_object.html#a426082c903ecccf4ada2a7288d1869c1">getCollider()</a>-&gt;getMesh()). Must always return valid collider, implementation is not allowed to return nullptr. </p>

</div>
</div>
<a id="a08efb419accc43c924ab424194c552b4" name="a08efb419accc43c924ab424194c552b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08efb419accc43c924ab424194c552b4">&#9670;&#160;</a></span>setCollider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRObject::setCollider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_collider.html">RRCollider</a> *&#160;</td>
          <td class="paramname"><em>collider</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets collider and mesh. </p>
<p>By changing collider, you change also mesh and possibly number of triangles, so make sure to update also faceGroups to have the same number of triangles as mesh. Object does not adopt/delete the collider, it keeps Caller must ensure collider stays alive until object destruction or next <a class="el" href="classrr_1_1_r_r_object.html#a08efb419accc43c924ab424194c552b4" title="Sets collider and mesh.">setCollider()</a> call. </p>

</div>
</div>
<a id="afb20de4942034442c5d8519933ad8ba5" name="afb20de4942034442c5d8519933ad8ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb20de4942034442c5d8519933ad8ba5">&#9670;&#160;</a></span>getTriangleMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structrr_1_1_r_r_material.html">RRMaterial</a> * rr::RRObject::getTriangleMaterial </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="classrr_1_1_r_r_light.html">RRLight</a> *&#160;</td>
          <td class="paramname"><em>light</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns material description for given triangle. </p>
<p>Default implementation is just different way to access data stored in faceGroups. However, this function may provide additional information. If you wish to disable lighting or shadowing for specific light-caster-receiver combinations, reimplement this function to return nullptr for that combination of parameters, fall back to default implementation for others combinations.</p>
<p>Although more precise per-pixel material query is available in <a class="el" href="classrr_1_1_r_r_object.html#a6574562e2be602cc78b7be5ce6d2e6dc" title="Returns material description for point on object&#39;s surface, fills colorLinear with values read from t...">getPointMaterial()</a>, this per-triangle version is often preferred for its speed and simplicity. Returned pointer must stay valid and constant for whole life of object.</p>
<p><b>Editing materials</b> <br  />
 Caller is allowed to modify returned materials including textures (textures are owned and deleted by material, so when changing texture, old one must be deleted). Filtered objects (e.g. objects created by createMultiObject()) share materials, so by modifying base object, filtered one is modified too. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Triangle number. </td></tr>
    <tr><td class="paramname">light</td><td>nullptr or one of lights in scene. With light==nullptr, returned material must be always the same non-nullptr. With light!=nullptr, it is allowed to return nullptr to disable lighting or shadowing, see receiver for details. </td></tr>
    <tr><td class="paramname">receiver</td><td>nullptr or one of static objects in scene. Used only when light!=nullptr, controls properties of given light. When receiver==nullptr, you may return nullptr to make triangle invisible for given light (disables both direct lighting and shadow-casting). When receiver!=nullptr, you may return nullptr to disable direct shadow casting of triangle for given light and receiver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6574562e2be602cc78b7be5ce6d2e6dc" name="a6574562e2be602cc78b7be5ce6d2e6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6574562e2be602cc78b7be5ce6d2e6dc">&#9670;&#160;</a></span>getPointMaterial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRObject::getPointMaterial </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec2.html">RRVec2</a>&#160;</td>
          <td class="paramname"><em>uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interpolated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_point_material.html">RRPointMaterial</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns material description for point on object's surface, fills colorLinear with values read from textures. </p>
<p>This is higher quality but slower per-pixel version of faster per-triangle <a class="el" href="classrr_1_1_r_r_object.html#afb20de4942034442c5d8519933ad8ba5" title="Returns material description for given triangle.">getTriangleMaterial()</a>. <br  />
<br  />
 Default implementation takes point details from optional textures in material returned by <a class="el" href="classrr_1_1_r_r_object.html#afb20de4942034442c5d8519933ad8ba5" title="Returns material description for given triangle.">getTriangleMaterial()</a>. <br  />
<br  />
 Offline GI solver uses <a class="el" href="classrr_1_1_r_r_object.html#a6574562e2be602cc78b7be5ce6d2e6dc" title="Returns material description for point on object&#39;s surface, fills colorLinear with values read from t...">getPointMaterial()</a> only if requested lightmap quality&gt;<a class="el" href="classrr_1_1_r_r_object.html#afb20de4942034442c5d8519933ad8ba5" title="Returns material description for given triangle.">getTriangleMaterial()</a>-&gt;minimalQualityForPointMaterials. Realtime GI solvers never call <a class="el" href="classrr_1_1_r_r_object.html#a6574562e2be602cc78b7be5ce6d2e6dc" title="Returns material description for point on object&#39;s surface, fills colorLinear with values read from t...">getPointMaterial()</a>. <br  />
<br  />
 Thread safe: yes, offline solver calls it from many thread concurrently. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Triangle number. </td></tr>
    <tr><td class="paramname">uv</td><td>2D coordinates of point, in triangle's space. Triangle vertices are in 0,0 1,0 0,1. </td></tr>
    <tr><td class="paramname">colorSpace</td><td>Function reads point details from textures, converts them with colorSpace and writes result to colorLinear. </td></tr>
    <tr><td class="paramname">interpolated</td><td>Makes texture reads interpolated. </td></tr>
    <tr><td class="paramname">out</td><td>Undefined on input, function fills it with material for requested point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cf1282e77fcc3662aa99c30ffc4a5c7" name="a2cf1282e77fcc3662aa99c30ffc4a5c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf1282e77fcc3662aa99c30ffc4a5c7">&#9670;&#160;</a></span>getTriangleLod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRObject::getTriangleLod </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_object_1_1_lod_info.html">LodInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about single object, what LOD it is. </p>
<p>In Lightsprint, LODs are completely separated objects without any pointers linking them. The only information that connects them comes from this function. <br  />
 Default implementation makes all objects unique, they return different bases and level 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Triangle number, relevant only for multiobjects, individual triangles in multiobject may return different results. </td></tr>
    <tr><td class="paramname">out</td><td>Caller provided storage for result. For valid t, requested LOD info is written to out. For invalid t, out stays unmodified. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abee3ef669ba8686394573d1986a1fc2b" name="abee3ef669ba8686394573d1986a1fc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee3ef669ba8686394573d1986a1fc2b">&#9670;&#160;</a></span>setWorldMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRObject::setWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_matrix3x4.html">RRMatrix3x4</a> *&#160;</td>
          <td class="paramname"><em>worldMatrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets object transformation from local to world space. </p>
<p>It copies data from your matrix rather than remembering your pointer. nullptr is accepted as no transformation. If you set identity matrix, <a class="el" href="classrr_1_1_r_r_object.html#a1467c412ae693b56d64ef6674765d8aa" title="Returns object transformation from local to world space.">getWorldMatrix()</a> will return nullptr. </p>

</div>
</div>
<a id="a1467c412ae693b56d64ef6674765d8aa" name="a1467c412ae693b56d64ef6674765d8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1467c412ae693b56d64ef6674765d8aa">&#9670;&#160;</a></span>getWorldMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structrr_1_1_r_r_matrix3x4_ex.html">RRMatrix3x4Ex</a> * rr::RRObject::getWorldMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns object transformation from local to world space. </p>
<p>Returns nullptr for identity, for use in "if (matrix) slow_transform_path; else fast_identity_path;" scenarios. Transformation can be changed by <a class="el" href="classrr_1_1_r_r_object.html#abee3ef669ba8686394573d1986a1fc2b" title="Sets object transformation from local to world space.">setWorldMatrix()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to matrix that transforms object space to world space. May return nullptr for identity/no transformation. Pointer must be constant and stay valid for whole life of object. Matrix may change during object life. </dd></dl>

</div>
</div>
<a id="a87f2bba045fa36654ab3207f1b070005" name="a87f2bba045fa36654ab3207f1b070005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2bba045fa36654ab3207f1b070005">&#9670;&#160;</a></span>getWorldMatrixRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structrr_1_1_r_r_matrix3x4_ex.html">RRMatrix3x4Ex</a> &amp; rr::RRObject::getWorldMatrixRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns object transformation from local to world space. </p>

</div>
</div>
<a id="a765c4a5b1896229111db873cfe2d6a89" name="a765c4a5b1896229111db873cfe2d6a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765c4a5b1896229111db873cfe2d6a89">&#9670;&#160;</a></span>getCustomData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void * rr::RRObject::getCustomData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns arbitrary additional data provided by adapter, or nullptr for unsupported data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Identifier of custom data requested. It is good practise to use names that describe both type and semantic of returned data. You are free to define and support any names in your adapters. Usage example: <code>const char* objectName = (const char*)object-&gt;getCustomData("const char* objectName");</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d64b4571ed8766b012c542afddb1780" name="a3d64b4571ed8766b012c542afddb1780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d64b4571ed8766b012c542afddb1780">&#9670;&#160;</a></span>updateIlluminationEnvMapCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRObject::updateIlluminationEnvMapCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates illumination.envMapWorldCenter and illumination.envMapWorldRadius. </p>
<p>Relevant for realtime GI lighting only. It is called automatically from setStaticObjects() and allocateBuffersForRealtimeGI(), but you should update the values whenever you move or scale object later, otherwise object's illumination environment map used for realtime GI lighting will be inaccurate. </p>

</div>
</div>
<a id="acee59ea5370a7ee56750cd98cb9f38e3" name="acee59ea5370a7ee56750cd98cb9f38e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee59ea5370a7ee56750cd98cb9f38e3">&#9670;&#160;</a></span>createWorldSpaceMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRObject::createWorldSpaceMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns <a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a> that describes mesh after transformation to world space. </p>
<p>Newly created instance allocates no additional memory, but depends on original object, so it is not allowed to let new instance live longer than original object. </p>

</div>
</div>
<a id="a6473be0334a9921ca42370a4796c8dc7" name="a6473be0334a9921ca42370a4796c8dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6473be0334a9921ca42370a4796c8dc7">&#9670;&#160;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRObject::checkConsistency </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>objectNumber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reports inconsistencies found in object. Returns number of problem reported. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectNumber</td><td>Arbitrary string that is inserted into error messages, to identify object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa480460a88ebab2c2643f62cd70d0264" name="aa480460a88ebab2c2643f62cd70d0264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa480460a88ebab2c2643f62cd70d0264">&#9670;&#160;</a></span>createCollisionHandlerFirstVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_collision_handler.html">RRCollisionHandler</a> * rr::RRObject::createCollisionHandlerFirstVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns collision handler, that finds closest visible surface. </p>
<p><br  />
 Finds closest surface with RRMaterial::sideBits::render and specularTransmittance.color!=1. <br  />
 It is suitable e.g for picking objects in rendering window, only visible pixels collide.</p>
<p>Thread safe: this function yes, but created collision handler no. (typical use case: for n threads, use 1 collider, n rays and n handlers.) </p>

</div>
</div>
<a id="a904f6c29c3332a5a29edec82c516707f" name="a904f6c29c3332a5a29edec82c516707f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904f6c29c3332a5a29edec82c516707f">&#9670;&#160;</a></span>getHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrr_1_1_r_r_hash.html">RRHash</a> rr::RRObject::getHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns hash of object data. Slow (not cached). </p>
<p>Hashing covers object properties that affect realtime global illumination: positions, normals, tangents, texcoords, material properties (even extracted from textures), transformation. Hashing doesn't cover: full texture data, names, uv indices. </p>

</div>
</div>
<a id="a061f5d0225cadd3af16c31139bf78dad" name="a061f5d0225cadd3af16c31139bf78dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061f5d0225cadd3af16c31139bf78dad">&#9670;&#160;</a></span>updateFaceGroupsFromTriangleMaterials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRObject::updateFaceGroupsFromTriangleMaterials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills faceGroups according to results provided by <a class="el" href="classrr_1_1_r_r_object.html#afb20de4942034442c5d8519933ad8ba5" title="Returns material description for given triangle.">getTriangleMaterial()</a>. </p>
<p>Fills faceGroups automatically, however, you may call it only if you implemented your own <a class="el" href="classrr_1_1_r_r_object.html" title="Common interface for all proprietary object formats.">RRObject</a> with your own self-contained <a class="el" href="classrr_1_1_r_r_object.html#afb20de4942034442c5d8519933ad8ba5" title="Returns material description for given triangle.">getTriangleMaterial()</a> not reading data from faceGroups. </p>

</div>
</div>
<a id="a85bff2b294f069672894296b3452f1d4" name="a85bff2b294f069672894296b3452f1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bff2b294f069672894296b3452f1d4">&#9670;&#160;</a></span>recommendLayerParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRObject::recommendLayerParameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_object_1_1_layer_parameters.html">RRObject::LayerParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>layerParameters</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recommends layer parameters (resolution, filename etc). </p>
<p>Nearly all tools and samples need to decide what lightmap resolutions to use, what lightmap filenames to use etc. Samples are free to use arbitrary resolutions and filenames and often they do. But for convenience of undecided tools and samples, this function is provided as a central point of their decision making.</p>
<p>Applications often have some opinion, so this function takes their suggections on resolution, path, extension etc, stored in layerParameters (suggestedXxx fields). Recommended new resolution, filename etc are output into the same structure (actualXxx fields).</p>
<p>Custom implementations of this function use different decision making rules. For example adapter of Gamebryo .gsa scene never recommends vertex buffer, because Gamebryo doesn't support lighting in vertex buffers yet. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerParameters</td><td>Structure of both inputs (suggestedXxx) and outputs (actualXxx). Outputs are filled by this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f8f05ccca8277a28c662bfae455500a" name="a3f8f05ccca8277a28c662bfae455500a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8f05ccca8277a28c662bfae455500a">&#9670;&#160;</a></span>faceGroups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_object_1_1_face_groups.html">FaceGroups</a> rr::RRObject::faceGroups</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment of materials to triangles. </p>
<p>First facegroup describes first numTriangles in object, next facegroup next triangles etc. Results are undefined if faceGroups contains nullptr materials or fewer triangles than mesh. </p>

</div>
</div>
<a id="a9470dbf788a3ba154ad8507e15dbf3ad" name="a9470dbf788a3ba154ad8507e15dbf3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9470dbf788a3ba154ad8507e15dbf3ad">&#9670;&#160;</a></span>illumination</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_object_illumination.html">RRObjectIllumination</a> rr::RRObject::illumination</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Illumination of the object. </p>

</div>
</div>
<a id="ae62e11f403732dab321c944e2b32e47c" name="ae62e11f403732dab321c944e2b32e47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62e11f403732dab321c944e2b32e47c">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_string.html">RRString</a> rr::RRObject::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional name of the object. </p>

</div>
</div>
<a id="aa5105a2ba819b7b241f59c01546cba77" name="aa5105a2ba819b7b241f59c01546cba77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5105a2ba819b7b241f59c01546cba77">&#9670;&#160;</a></span>enabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRObject::enabled</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disabled object becomes invisible for renderer. Not fully implemented for static objects, disabled static object might stay visible. </p>

</div>
</div>
<a id="afdc417da52b075c4868fe3ce4cc4c846" name="afdc417da52b075c4868fe3ce4cc4c846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc417da52b075c4868fe3ce4cc4c846">&#9670;&#160;</a></span>isDynamic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rr::RRObject::isDynamic</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this object dynamic = is it safe to modify it? </p>
<p>This flag does not enforce anything, you set it as you wish and you comply with it if you wish. Object does not become static by clearing this flag, it is static if you treat it as static, e.g. by passing it to setStaticObjects() and not moving it. But it's practical to have this bit of information here, it is saved to .rr3 files, scene viewer reads it from .rr3 files etc. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerr.html">rr</a></li><li class="navelem"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
