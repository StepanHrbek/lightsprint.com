<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LightsprintSDK: rr::RRObjects Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LightsprintSDK<span id="projectnumber">&#160;2021.08.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrr_1_1_r_r_objects.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrr_1_1_r_r_objects-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rr::RRObjects Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;RRObject.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rr::RRObjects:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrr_1_1_r_r_objects.png" usemap="#rr::RRObjects_map" alt=""/>
  <map id="rr::RRObjects_map" name="rr::RRObjects_map">
<area href="classrr_1_1_r_r_vector.html" alt="rr::RRVector&lt; RRObject * &gt;" shape="rect" coords="0,0,171,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a199de3a4cb32d24cd4f0d27444d7761e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a199de3a4cb32d24cd4f0d27444d7761e">makeNamesUnique</a> () const</td></tr>
<tr class="separator:a199de3a4cb32d24cd4f0d27444d7761e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a270073723e9379d5ca0a76728c957"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#ad4a270073723e9379d5ca0a76728c957">loadLayer</a> (int layerNumber, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;path, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;ext) const</td></tr>
<tr class="separator:ad4a270073723e9379d5ca0a76728c957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a308e72155825c91cee231cb1cfb92a"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a5a308e72155825c91cee231cb1cfb92a">saveLayer</a> (int layerNumber, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;path, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;ext) const</td></tr>
<tr class="separator:a5a308e72155825c91cee231cb1cfb92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29edca53ad46391c0c1285d215214675"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a29edca53ad46391c0c1285d215214675">layerExistsInMemory</a> (int layerNumber) const</td></tr>
<tr class="separator:a29edca53ad46391c0c1285d215214675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d06814cba99c785fb04845330aae3e2"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a2d06814cba99c785fb04845330aae3e2">layerDeleteFromMemory</a> (int layerNumber) const</td></tr>
<tr class="separator:a2d06814cba99c785fb04845330aae3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32460ac107765a317b366eadbd6ef29b"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a32460ac107765a317b366eadbd6ef29b">layerDeleteFromDisk</a> (const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;path, const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;ext) const</td></tr>
<tr class="separator:a32460ac107765a317b366eadbd6ef29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004a05fee60d5e69f615a79dea754469"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a004a05fee60d5e69f615a79dea754469">allocateBuffersForRealtimeGI</a> (int layerLightmap, int layerEnvironment, unsigned diffuseEnvMapSize, unsigned specularEnvMapSize, unsigned refractEnvMapSize, bool allocateNewBuffers, bool changeExistingBuffers, float specularThreshold, float depthThreshold) const</td></tr>
<tr class="separator:a004a05fee60d5e69f615a79dea754469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a42b2e24492d651d8c96339113c41ab"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a5a42b2e24492d651d8c96339113c41ab">checkConsistency</a> (const char *objectType) const</td></tr>
<tr class="separator:a5a42b2e24492d651d8c96339113c41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1995f293b3e08eaaa283765d37ecd03f"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a1995f293b3e08eaaa283765d37ecd03f">buildUnwrap</a> (unsigned resolution, unsigned minimalUvChannel, unsigned minTrianglesForFastUnwrap, bool &amp;aborting) const</td></tr>
<tr class="separator:a1995f293b3e08eaaa283765d37ecd03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531f4b71cec84414a14df8ca2d08b498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a531f4b71cec84414a14df8ca2d08b498">getAllMaterials</a> (<a class="el" href="classrr_1_1_r_r_materials.html">RRMaterials</a> &amp;materials) const</td></tr>
<tr class="separator:a531f4b71cec84414a14df8ca2d08b498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837daf5402d8727e906adb3230e90093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a837daf5402d8727e906adb3230e90093">updateColorLinear</a> (const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *colorSpace) const</td></tr>
<tr class="separator:a837daf5402d8727e906adb3230e90093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5f39a5c1a258b210aba65507b68575"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#ade5f39a5c1a258b210aba65507b68575">flipFrontBack</a> (unsigned numNormalsThatMustPointBack, bool report) const</td></tr>
<tr class="separator:ade5f39a5c1a258b210aba65507b68575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0a1270f7f733441a41d5d96f31f131"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#aae0a1270f7f733441a41d5d96f31f131">buildTangents</a> (<a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">RRMesh::TangentSpaceState</a> stateThatWarrantsRebuild) const</td></tr>
<tr class="separator:aae0a1270f7f733441a41d5d96f31f131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830ec9231ec6efac6c572f50a7dace91"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a830ec9231ec6efac6c572f50a7dace91">optimizeFaceGroups</a> (<a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *object=nullptr) const</td></tr>
<tr class="separator:a830ec9231ec6efac6c572f50a7dace91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336a933944dc8be5e60f3daad882ea94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a336a933944dc8be5e60f3daad882ea94">mergeObjects</a> (bool splitByMaterial) const</td></tr>
<tr class="separator:a336a933944dc8be5e60f3daad882ea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018abae142ef75236d0778bc313243c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a018abae142ef75236d0778bc313243c7">createMultiObject</a> (<a class="el" href="classrr_1_1_r_r_collider.html#aa5ca8d65491dac68cffc34afcd3dcb0f">RRCollider::IntersectTechnique</a> intersectTechnique, bool &amp;aborting, float maxDistanceBetweenVerticesToStitch, float maxRadiansBetweenNormalsToStitch, bool optimizeTriangles, unsigned speed, const char *cacheLocation) const</td></tr>
<tr class="separator:a018abae142ef75236d0778bc313243c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e1539e0a99884c47e840ce4905c541"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a19e1539e0a99884c47e840ce4905c541">smoothAndStitch</a> (bool splitVertices, bool mergeVertices, bool removeUnusedVertices, bool removeDegeneratedTriangles, bool stitchPositions, bool stitchNormals, bool generateNormals, float maxDistanceBetweenVerticesToStitch, float maxRadiansBetweenNormalsToStitch, float maxDistanceBetweenUvsToStitch, bool report) const</td></tr>
<tr class="separator:a19e1539e0a99884c47e840ce4905c541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366e26eccd49cab8bd36ca390c9408f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a366e26eccd49cab8bd36ca390c9408f0">multiplyEmittance</a> (float emissiveMultiplier) const</td></tr>
<tr class="separator:a366e26eccd49cab8bd36ca390c9408f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb8e0a4ea4472e04fe1d83bc0ce41de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#a7cb8e0a4ea4472e04fe1d83bc0ce41de">deleteComponents</a> (bool deleteTangents, bool deleteUnwrap, bool deleteUnusedUvChannels, bool deleteEmptyFacegroups) const</td></tr>
<tr class="separator:a7cb8e0a4ea4472e04fe1d83bc0ce41de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb3351f812e372ffedae704402c9c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#acbb3351f812e372ffedae704402c9c3a">removeEmptyObjects</a> ()</td></tr>
<tr class="separator:acbb3351f812e372ffedae704402c9c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcad1bc03cfcac3b855af931c529602b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_objects.html#afcad1bc03cfcac3b855af931c529602b">~RRObjects</a> ()</td></tr>
<tr class="separator:afcad1bc03cfcac3b855af931c529602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrr_1_1_r_r_vector"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrr_1_1_r_r_vector')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrr_1_1_r_r_vector.html">rr::RRVector&lt; RRObject * &gt;</a></td></tr>
<tr class="memitem:a4f919e813abadd348ce25bf516bbac94 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a4f919e813abadd348ce25bf516bbac94">RRVector</a> ()</td></tr>
<tr class="separator:a4f919e813abadd348ce25bf516bbac94 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075ed0533cbe71e56b310c63d8227140 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a075ed0533cbe71e56b310c63d8227140">RRVector</a> (const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a> &amp;a)</td></tr>
<tr class="separator:a075ed0533cbe71e56b310c63d8227140 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe884723e9a5d544419ff8411f085ae2 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#abe884723e9a5d544419ff8411f085ae2">operator=</a> (const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a> &amp;a)</td></tr>
<tr class="separator:abe884723e9a5d544419ff8411f085ae2 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3334335339fc9b463c621d81cec938d inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#ad3334335339fc9b463c621d81cec938d">resize</a> (unsigned newSize, <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * initial=<a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *())</td></tr>
<tr class="separator:ad3334335339fc9b463c621d81cec938d inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcea770ad8232df503534623c815cf3 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a9dcea770ad8232df503534623c815cf3">push_back</a> (<a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * a)</td></tr>
<tr class="separator:a9dcea770ad8232df503534623c815cf3 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dd18c40b6ea61c8c36e401d35188b8 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#ab4dd18c40b6ea61c8c36e401d35188b8">pop_back</a> ()</td></tr>
<tr class="separator:ab4dd18c40b6ea61c8c36e401d35188b8 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689f4dc7416ab84f895200f4dad7b646 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a689f4dc7416ab84f895200f4dad7b646">erase</a> (<a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *e)</td></tr>
<tr class="separator:a689f4dc7416ab84f895200f4dad7b646 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d47666893a87094476caf5222b9d9b1 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a6d47666893a87094476caf5222b9d9b1">size</a> () const</td></tr>
<tr class="separator:a6d47666893a87094476caf5222b9d9b1 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3d94a1900d03049a128900f9985082 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a4e3d94a1900d03049a128900f9985082">operator[]</a> (unsigned i)</td></tr>
<tr class="separator:a4e3d94a1900d03049a128900f9985082 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4458c01ba892d169fedd72fda6e57f4d inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a4458c01ba892d169fedd72fda6e57f4d">operator[]</a> (unsigned i) const</td></tr>
<tr class="separator:a4458c01ba892d169fedd72fda6e57f4d inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a59a91165afc342455f9e31a97df5d8 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a1a59a91165afc342455f9e31a97df5d8">clear</a> ()</td></tr>
<tr class="separator:a1a59a91165afc342455f9e31a97df5d8 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53df0e3fa4a4d1368792131501768905 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a53df0e3fa4a4d1368792131501768905">begin</a> ()</td></tr>
<tr class="separator:a53df0e3fa4a4d1368792131501768905 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fb956dfbf70afb7c005cc556f7f06e inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a81fb956dfbf70afb7c005cc556f7f06e">begin</a> () const</td></tr>
<tr class="separator:a81fb956dfbf70afb7c005cc556f7f06e inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9ca64bba04e1062ce46fd39adbab3f inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a7f9ca64bba04e1062ce46fd39adbab3f">end</a> ()</td></tr>
<tr class="separator:a7f9ca64bba04e1062ce46fd39adbab3f inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57418d2d1fca748a529002e3c0759ffa inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a57418d2d1fca748a529002e3c0759ffa">end</a> () const</td></tr>
<tr class="separator:a57418d2d1fca748a529002e3c0759ffa inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7499b591559e01eb51311944cb656c33 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a7499b591559e01eb51311944cb656c33">insert</a> (<a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *_where, const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *_first, const <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *_last)</td></tr>
<tr class="separator:a7499b591559e01eb51311944cb656c33 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68009478c74ed5ca6e379e01c39cb53a inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a68009478c74ed5ca6e379e01c39cb53a">operator==</a> (const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * &gt; &amp;a) const</td></tr>
<tr class="separator:a68009478c74ed5ca6e379e01c39cb53a inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d42e10d43c3c8400a558fb23e538c21 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a7d42e10d43c3c8400a558fb23e538c21">operator!=</a> (const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; <a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * &gt; &amp;a) const</td></tr>
<tr class="separator:a7d42e10d43c3c8400a558fb23e538c21 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee93aa1ff468a6af53b23baf25222d96 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#aee93aa1ff468a6af53b23baf25222d96">~RRVector</a> ()</td></tr>
<tr class="separator:aee93aa1ff468a6af53b23baf25222d96 inherit pub_methods_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classrr_1_1_r_r_vector"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classrr_1_1_r_r_vector')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classrr_1_1_r_r_vector.html">rr::RRVector&lt; RRObject * &gt;</a></td></tr>
<tr class="memitem:a0ae96aac1ff5d33412cd34960fb85847 inherit pro_attribs_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a0ae96aac1ff5d33412cd34960fb85847">c</a></td></tr>
<tr class="separator:a0ae96aac1ff5d33412cd34960fb85847 inherit pro_attribs_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7aabbc7e928b00e26f4a4faa64fb20 inherit pro_attribs_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a4a7aabbc7e928b00e26f4a4faa64fb20">numAllocated</a></td></tr>
<tr class="separator:a4a7aabbc7e928b00e26f4a4faa64fb20 inherit pro_attribs_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3c180e5ab2befa6ce4a181f50eb579 inherit pro_attribs_classrr_1_1_r_r_vector"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_vector.html#a3e3c180e5ab2befa6ce4a181f50eb579">numUsed</a></td></tr>
<tr class="separator:a3e3c180e5ab2befa6ce4a181f50eb579 inherit pro_attribs_classrr_1_1_r_r_vector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set of objects with interface similar to std::vector. </p>
<p>GI solver uses this class to set all static or dynamic objects at once. You can adapt content from memory or load content from files to <a class="el" href="classrr_1_1_r_r_objects.html" title="Set of objects with interface similar to std::vector.">RRObjects</a>, see scene adapters in LightsprintIO library; or you can fill <a class="el" href="classrr_1_1_r_r_objects.html" title="Set of objects with interface similar to std::vector.">RRObjects</a> instance manually, using push_back(object). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afcad1bc03cfcac3b855af931c529602b" name="afcad1bc03cfcac3b855af931c529602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcad1bc03cfcac3b855af931c529602b">&#9670;&#160;</a></span>~RRObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rr::RRObjects::~RRObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor does not delete objects in collection (but individual adapters may do). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a199de3a4cb32d24cd4f0d27444d7761e" name="a199de3a4cb32d24cd4f0d27444d7761e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199de3a4cb32d24cd4f0d27444d7761e">&#9670;&#160;</a></span>makeNamesUnique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRObjects::makeNamesUnique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies non-unique object names to make them unique. </p>
<p>When multiple objects with the same name "name" are found, they are renamed to "name", "name.2", "name.3" etc. Function ensures that filenames derived from object names are also unique (when comparing names, function thinks of all non-filename characters as '_'). Such extended uniqueness is necessary when loading/saving layers, because e.g. default lightmap filenames are constructed from object names. If you don't ensure uniqueness, multiple lightmaps may end up with the same filename and with incorrect illumination. </p>

</div>
</div>
<a id="ad4a270073723e9379d5ca0a76728c957" name="ad4a270073723e9379d5ca0a76728c957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a270073723e9379d5ca0a76728c957">&#9670;&#160;</a></span>loadLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::loadLayer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads illumination layer from disk. </p>
<p>It is shortcut for calling illumination-&gt;getLayer() = <a class="el" href="classrr_1_1_r_r_buffer.html#abaf747f374a421d9f44b33aed8d201f1" title="Loads buffer from disk to system memory.">RRBuffer::load()</a> on all elements in this container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerNumber</td><td>Layer to load, nothing is done for negative number. </td></tr>
    <tr><td class="paramname">path</td><td>Where to read files, should have trailing slash. </td></tr>
    <tr><td class="paramname">ext</td><td>File format of maps to load, e.g. "png". Vertex buffers are always loaded from .rrbuffer, without regard to ext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="namespacerr__io.html#ac58cf19a99df1b94dfd405336a2ca1e5" title="Registers callbacks for loading and saving scenes, textures and videos in ~75 fileformats (Supported ...">rr_io::registerIO()</a> must be called for image saves/loads to work. </dd></dl>

</div>
</div>
<a id="a5a308e72155825c91cee231cb1cfb92a" name="a5a308e72155825c91cee231cb1cfb92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a308e72155825c91cee231cb1cfb92a">&#9670;&#160;</a></span>saveLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::saveLayer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves illumination layer to disk. </p>
<p>It is shortcut for calling illumination-&gt;getLayer()-&gt;save() on all elements in this container. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerNumber</td><td>Layer to save, nothing is done for negative number. </td></tr>
    <tr><td class="paramname">path</td><td>Where to store files, should have trailing slash. Subdirectories are not created. </td></tr>
    <tr><td class="paramname">ext</td><td>File format of maps to save, e.g. "png". Vertex buffers are always saved to .rrbuffer, without regard to ext. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="namespacerr__io.html#ac58cf19a99df1b94dfd405336a2ca1e5" title="Registers callbacks for loading and saving scenes, textures and videos in ~75 fileformats (Supported ...">rr_io::registerIO()</a> must be called for image saves/loads to work. </dd></dl>

</div>
</div>
<a id="a29edca53ad46391c0c1285d215214675" name="a29edca53ad46391c0c1285d215214675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29edca53ad46391c0c1285d215214675">&#9670;&#160;</a></span>layerExistsInMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::layerExistsInMemory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerNumber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of buffers in memory. </p>

</div>
</div>
<a id="a2d06814cba99c785fb04845330aae3e2" name="a2d06814cba99c785fb04845330aae3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d06814cba99c785fb04845330aae3e2">&#9670;&#160;</a></span>layerDeleteFromMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::layerDeleteFromMemory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerNumber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes buffers from memory. </p>

</div>
</div>
<a id="a32460ac107765a317b366eadbd6ef29b" name="a32460ac107765a317b366eadbd6ef29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32460ac107765a317b366eadbd6ef29b">&#9670;&#160;</a></span>layerDeleteFromDisk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::layerDeleteFromDisk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_string.html">RRString</a> &amp;&#160;</td>
          <td class="paramname"><em>ext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes buffers from disk. </p>

</div>
</div>
<a id="a004a05fee60d5e69f615a79dea754469" name="a004a05fee60d5e69f615a79dea754469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004a05fee60d5e69f615a79dea754469">&#9670;&#160;</a></span>allocateBuffersForRealtimeGI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::allocateBuffersForRealtimeGI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerLightmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerEnvironment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>diffuseEnvMapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>specularEnvMapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>refractEnvMapSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allocateNewBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>changeExistingBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>specularThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depthThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates buffers for realtime GI illumination. </p>
<p>Before rendering realtime GI, you need buffers for illumination to be calculated into.</p>
<p>For the best control, you can allocate these buffers manually, using code like <code> for (all static objects) illumination.getLayer(layerLightmap) = RRBuffer::create(BT_VERTEX_BUFFER,getNumVertices(),1,1,BF_RGBF,false,nullptr); for (all objects that need environment map) illumination.getLayer(layerEnvironment) = RRBuffer::create(BT_CUBE_TEXTURE,16,16,6,BF_RGBA,true,nullptr); </code></p>
<p>However, you can save time by calling this helper function, once for solver's static objects, once for dynamic ones.</p>
<p>Well, you can save even more by calling <a class="el" href="classrr_1_1_r_r_solver.html#aaf0703d3ee895467659bbf3ebd9e198c" title="Allocates buffers for realtime GI illumination of objects in solver.">RRSolver::allocateBuffersForRealtimeGI()</a>, it handles both static ond dynamic objects at once. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerLightmap</td><td>Arbitrary layer number for storing realtime calculated per-vertex indirect illumination. If &gt;=0, vertex buffers in illumination-&gt;getLayer(layerLightmap) are allocated, resized or deleted according to other parameters. You should pass the same layer number to renderer, so it can use buffers you just allocated. Pass &lt;0 if you don't want to touch vertex buffers. Vertex buffers are suitable (=we can realtime update them) only for static objects. </td></tr>
    <tr><td class="paramname">layerEnvironment</td><td>Arbitrary layer number for storing realtime calculated environment maps. If &gt;=0, cubemaps in illumination-&gt;getLayer(layerEnvironment) are allocated, resized or deleted according to other parameters. You should pass the same layer number to renderer, so it can use buffers you just allocated. Pass &lt;0 if you don't want to touch environment maps. Environment maps are suitable (=we can realtime update them) for both static and dynamic objects. </td></tr>
    <tr><td class="paramname">diffuseEnvMapSize</td><td>If materials have diffuse reflection, reflection map of at least this size will be allocated in illumination. Size 4 is usually good enough. </td></tr>
    <tr><td class="paramname">specularEnvMapSize</td><td>If materials have specular reflection, reflection map of at least this size will be allocated in illumination. Size 16 is usually sufficient, not very sharp, but makes GI calculation fast. </td></tr>
    <tr><td class="paramname">refractEnvMapSize</td><td>If materials refract light using cubemap, cubemap of at least this size will be allocated in illumination. Size 16 is very lowres, but it makes GI calculation fast. </td></tr>
    <tr><td class="paramname">allocateNewBuffers</td><td>If buffer does not exist yet, true = it will be allocated, false = no action. </td></tr>
    <tr><td class="paramname">changeExistingBuffers</td><td>If buffer already exists, true = it will be resized or deleted accordingly, false = no action. </td></tr>
    <tr><td class="paramname">specularThreshold</td><td>Only objects with specular color above threshold apply for specular cube reflection, -1=all objects apply, 0=all objects with specular apply, 0.2=only objects with spec color above 0.2 apply. </td></tr>
    <tr><td class="paramname">depthThreshold</td><td>Only objects with depth above threshold apply for specular cube reflection, 0=all objects apply, 0.1=all but near planar objects apply, 1=none apply. Depth is number between 0 and 1, calculated as ratio between min and mid size of axis aligned bounding box. Purpose of depthThreshold is to exclude very flat objects from processing, environment reflections produce visible inaccuracies on such objects. For absolutely flat objects, see <a class="el" href="structrr__gl_1_1_uber_program_setup.html#ab481482558ca8697d913ea35cccfe27f" title="Illuminates material&#39;s specular component by realtime rasterized highres mirror reflection....">rr_gl::UberProgramSetup::LIGHT_INDIRECT_MIRROR_SPECULAR</a>, it produces reflections of high quality and accuracy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of buffers allocated or reallocated. </dd></dl>

</div>
</div>
<a id="a5a42b2e24492d651d8c96339113c41ab" name="a5a42b2e24492d651d8c96339113c41ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a42b2e24492d651d8c96339113c41ab">&#9670;&#160;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRObjects::checkConsistency </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>objectType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports inconsistencies found in objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectType</td><td>Optional identifier of collection, e.g "static", "dynamic". May be nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of problem reported. </dd></dl>

</div>
</div>
<a id="a1995f293b3e08eaaa283765d37ecd03f" name="a1995f293b3e08eaaa283765d37ecd03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1995f293b3e08eaaa283765d37ecd03f">&#9670;&#160;</a></span>buildUnwrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::buildUnwrap </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minimalUvChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minTrianglesForFastUnwrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>aborting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebuilds unwrap in all meshes of <a class="el" href="classrr_1_1_r_r_mesh_arrays.html" title="Mesh that exposes internal structures for direct read-write access.">RRMeshArrays</a> type. </p>
<p>New unwrap is created into the lowest unused uv channel, the same channel in all meshes. All materials are updated to use new unwrap. All successfully unwrapped meshes have <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#a40c1f5d2913fa394b4328d0c7ec47025">RRMeshArrays::unwrapChannel</a>/unwrapWidth/unwrapHeight set, failed and aborted meshes stay completely unchanged.</p>
<p>Unwrapper doesn't modify pointers to objects, colliders, materials or meshes, but it can add new vertices in mesh, if unwrap contains seams. Therefore structures that depend on exact number of vertices may need update after unwrapping. This is case of solver; if you build unwrap in solver <code>solver-&gt;getStaticObjects().buildUnwrap(...)</code>, you have to resend modified objects to solver <code>solver-&gt;setStaticObjects(solver-&gt;getStaticObjects(),...)</code>.</p>
<p>Currently it is implemented only for Windows platform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>Expected lightmap resolution, e.g. 1024 for 1024x1024. </td></tr>
    <tr><td class="paramname">minimalUvChannel</td><td>New unwrap is created into the lowest unused uv channel, but at least minimalUvChannel. So if minimalUvChannel=2, unwrap is never created to channel 0 or 1. </td></tr>
    <tr><td class="paramname">minTrianglesForFastUnwrap</td><td>Higher quality but slower technique is used for meshes with lower number of triangles. It is too slow for large meshes, so reasonable threshold could be 25000. </td></tr>
    <tr><td class="paramname">aborting</td><td>May be set asynchronously, aborts build. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of new unwrap uv channel, it's the same for all meshes. UINT_MAX in case of failure/no unwrapping. </dd></dl>

</div>
</div>
<a id="a531f4b71cec84414a14df8ca2d08b498" name="a531f4b71cec84414a14df8ca2d08b498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531f4b71cec84414a14df8ca2d08b498">&#9670;&#160;</a></span>getAllMaterials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRObjects::getAllMaterials </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_materials.html">RRMaterials</a> &amp;&#160;</td>
          <td class="paramname"><em>materials</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts all materials found in objects into collection. </p>
<p>May shuffle elements that were already present in collection. Removes duplicates, the same material is never listed twice. </p>

</div>
</div>
<a id="a837daf5402d8727e906adb3230e90093" name="a837daf5402d8727e906adb3230e90093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837daf5402d8727e906adb3230e90093">&#9670;&#160;</a></span>updateColorLinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRObjects::updateColorLinear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_color_space.html">RRColorSpace</a> *&#160;</td>
          <td class="paramname"><em>colorSpace</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts color to colorLinear in all materials. </p>
<p>Solver calls it automatically from <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">RRSolver::setStaticObjects()</a> and setDynamicObjects(). </p>

</div>
</div>
<a id="ade5f39a5c1a258b210aba65507b68575" name="ade5f39a5c1a258b210aba65507b68575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5f39a5c1a258b210aba65507b68575">&#9670;&#160;</a></span>flipFrontBack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::flipFrontBack </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numNormalsThatMustPointBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flips front/back if at least this number of normals in triangle points to back side. </p>
<p>So all triangles are flipped if numNormalsThatMustPointBack==0. </p><dl class="section return"><dt>Returns</dt><dd>Number of triangles flipped. </dd></dl>

</div>
</div>
<a id="aae0a1270f7f733441a41d5d96f31f131" name="aae0a1270f7f733441a41d5d96f31f131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0a1270f7f733441a41d5d96f31f131">&#9670;&#160;</a></span>buildTangents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::buildTangents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">RRMesh::TangentSpaceState</a>&#160;</td>
          <td class="paramname"><em>stateThatWarrantsRebuild</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds tangents in selected meshes. Returns number of meshes modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stateThatWarrantsRebuild</td><td>Pass TSS_MISSING to build only missing tangents, TSS_INVALID to rebuild also invalid ones etc. TSS_PERFECT rebuilds all tangents, even perfect ones. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a830ec9231ec6efac6c572f50a7dace91" name="a830ec9231ec6efac6c572f50a7dace91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830ec9231ec6efac6c572f50a7dace91">&#9670;&#160;</a></span>optimizeFaceGroups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRObjects::optimizeFaceGroups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> *&#160;</td>
          <td class="paramname"><em>object</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges facegroups with the same material. Reorders triangles in mesh if necessary. </p>
<p>Object is silently skipped in two special cases: if either its mesh is not of <a class="el" href="classrr_1_1_r_r_mesh_arrays.html" title="Mesh that exposes internal structures for direct read-write access.">RRMeshArrays</a> type or the mesh appears multiple times in this collection.</p>
<p>Note that objects alone don't have a way to find out what other objects use the same mesh, therefore you should call this function on collection of all objects (or at least all potential instances of the same mesh). Collection is scanned for instances of the same mesh, and if found, optimization is skipped to avoid breaking materials in other object. If you know that no other instance with the same mesh exists, you can safely use any collection, even empty. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Object to be optimized. If it is nullptr, all objects in this collection are optimized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of objects modified. </dd></dl>

</div>
</div>
<a id="a336a933944dc8be5e60f3daad882ea94" name="a336a933944dc8be5e60f3daad882ea94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336a933944dc8be5e60f3daad882ea94">&#9670;&#160;</a></span>mergeObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a> rr::RRObjects::mergeObjects </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitByMaterial</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges objects from collection, and optionally splits them by materials. </p>
<p>Returns newly created object or collection of objects that doesn't depend on old objects, colliders and meshes. New structures contain copy of all triangle and vertex data in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html" title="Mesh that exposes internal structures for direct read-write access.">RRMeshArrays</a> format. Only materials are shared between old and new objects. </p>

</div>
</div>
<a id="a018abae142ef75236d0778bc313243c7" name="a018abae142ef75236d0778bc313243c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018abae142ef75236d0778bc313243c7">&#9670;&#160;</a></span>createMultiObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_object.html">RRObject</a> * rr::RRObjects::createMultiObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_collider.html#aa5ca8d65491dac68cffc34afcd3dcb0f">RRCollider::IntersectTechnique</a>&#160;</td>
          <td class="paramname"><em>intersectTechnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>aborting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistanceBetweenVerticesToStitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxRadiansBetweenNormalsToStitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimizeTriangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cacheLocation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns union of multiple objects (contains geometry and materials from all objects), in world space. </p>
<p>In contrast to <a class="el" href="classrr_1_1_r_r_objects.html#a336a933944dc8be5e60f3daad882ea94" title="Merges objects from collection, and optionally splits them by materials.">mergeObjects()</a>, <a class="el" href="classrr_1_1_r_r_objects.html#a018abae142ef75236d0778bc313243c7" title="Creates and returns union of multiple objects (contains geometry and materials from all objects),...">createMultiObject()</a> doesn't allocate additional memory, but it depends on original objects, they must stay alive for whole life of MultiObject. <br  />
 Merging can be used to accelerate calculations, as one big object is nearly always faster than multiple small objects. <br  />
 Merging can be used to simplify calculations, as processing one object may be simpler than processing array of objects. <br  />
<br  />
 For description how to access original triangles and vertices in MultiObject, see <a class="el" href="classrr_1_1_r_r_mesh.html#a0861c036c587f1f39da82edb169423bb" title="Creates and returns union of multiple meshes (contains vertices and triangles of all meshes).">RRMesh::createMultiMesh()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intersectTechnique</td><td>Technique used for collider construction. </td></tr>
    <tr><td class="paramname">aborting</td><td>May be set asynchronously, aborts creation. </td></tr>
    <tr><td class="paramname">maxDistanceBetweenVerticesToStitch</td><td>Distance in world units. Vertices with lower or equal distance may be stitched into one vertex (if they satisfy also maxRadiansBetweenNormalsToStitch). Zero may stitch only identical vertices, negative value means no action. <br  />
 Vertices are stitched even if uv coordinates differ. Therefore stitchig is safe for offline calculation, but it could break mapping in relatime renderer. </td></tr>
    <tr><td class="paramname">maxRadiansBetweenNormalsToStitch</td><td>Vertices with lower or equal angle between normals may be stitched into one vertex (if they satisfy also maxDistanceBetweenVerticesToStitch). Zero may stitch only identical normals, negative value means no action. </td></tr>
    <tr><td class="paramname">optimizeTriangles</td><td>True removes degenerated triangles. It is always good to get rid of degenerated triangles (true), but sometimes you know there are no degenerated triangles at all and you can save few cycles by setting false. </td></tr>
    <tr><td class="paramname">speed</td><td>Could make object faster, but needs additional memory. <br  />
 0 = normal speed, 0bytes/triangle overhead <br  />
 1 = +speed, 12bytes/triangle overhead <br  />
 2 = ++speed, 156bytes/triangle overhead </td></tr>
    <tr><td class="paramname">cacheLocation</td><td>Directory for caching intermediate files used by <a class="el" href="classrr_1_1_r_r_collider.html" title="Finds ray - trianglemesh intersections.">RRCollider</a>. It is passed to <a class="el" href="classrr_1_1_r_r_collider.html#a7ff4c935e7f46b318e34f4b155fd30ba" title="Creates and returns collider, acceleration structure for finding ray x mesh intersections.">RRCollider::create()</a>, so default nullptr caches in temp, "*" or any other invalid path disables caching, any valid is path where to cache colliders. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19e1539e0a99884c47e840ce4905c541" name="a19e1539e0a99884c47e840ce4905c541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e1539e0a99884c47e840ce4905c541">&#9670;&#160;</a></span>smoothAndStitch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRObjects::smoothAndStitch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mergeVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeUnusedVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>removeDegeneratedTriangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stitchPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stitchNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generateNormals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistanceBetweenVerticesToStitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxRadiansBetweenNormalsToStitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistanceBetweenUvsToStitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>report</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rebuilds objects to make them smooth (possibly changing numbers of triangles, vertices, facegroups). </p>
<p>If there are multiple objects sharing one mesh, all objects must be smoothed at once (because smoothing can remove triangles and object facegroups must reflect that).</p>
<p>Smoothing doesn't modify pointers to objects, colliders, materials or meshes, but it can add/remove triangles/vertices in mesh, depending on parameters. Therefore structures that depend on exact number of triangles/vertices may need update after smoothing. This is case of solver; if you smooth in solver <code>solver-&gt;getStaticObjects().smoothAndStitch(...)</code>, you have to resend modified objects to solver <code>solver-&gt;setStaticObjects(solver-&gt;getStaticObjects(),...)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">splitVertices</td><td>Allows splitting vertices shared by multiple triangles (increases number of vertices), can make mesh less smooth. </td></tr>
    <tr><td class="paramname">mergeVertices</td><td>Allows merging similar vertices (reduces number of vertices), can make mesh smoother. </td></tr>
    <tr><td class="paramname">removeUnusedVertices</td><td>Removes unused vertices (reduces number of vertices). </td></tr>
    <tr><td class="paramname">removeDegeneratedTriangles</td><td>Removes degenerated triangles possibly created by merging/stitching (reduces number of triangles). There might be unused vertices after removal of degenerated triangles, use removeUnusedVertices to remove them. Note that number of triangles may drop to zero, you can use <a class="el" href="classrr_1_1_r_r_objects.html#acbb3351f812e372ffedae704402c9c3a" title="Removes objects with zero triangles or vertices. Does not delete them.">removeEmptyObjects()</a> to remove such objects. </td></tr>
    <tr><td class="paramname">stitchPositions</td><td>Allows stitching positions of nearby vertices (doesn't change number of vertices). </td></tr>
    <tr><td class="paramname">stitchNormals</td><td>Allows stitching normals of nearby vertices (doesn't change number of vertices). </td></tr>
    <tr><td class="paramname">generateNormals</td><td>True = generates new normals from mesh geometry, completely ignoring old normals (but keeps existing tangents). False = keeps existing normals (and tangents). </td></tr>
    <tr><td class="paramname">maxDistanceBetweenVerticesToStitch</td><td>When merging and/or stitching, controls maximal distance between vertices to merge and/or stitch. </td></tr>
    <tr><td class="paramname">maxRadiansBetweenNormalsToStitch</td><td>When merging and/or stitching, controls maximal angle between face normals to stitch and smooth. </td></tr>
    <tr><td class="paramname">maxDistanceBetweenUvsToStitch</td><td>When merging, controls maximal distance between uvs to merge. </td></tr>
    <tr><td class="paramname">report</td><td>Allows reporting warnings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366e26eccd49cab8bd36ca390c9408f0" name="a366e26eccd49cab8bd36ca390c9408f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366e26eccd49cab8bd36ca390c9408f0">&#9670;&#160;</a></span>multiplyEmittance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRObjects::multiplyEmittance </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>emissiveMultiplier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies emittance in all materials, both colors and textures. </p>

</div>
</div>
<a id="a7cb8e0a4ea4472e04fe1d83bc0ce41de" name="a7cb8e0a4ea4472e04fe1d83bc0ce41de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb8e0a4ea4472e04fe1d83bc0ce41de">&#9670;&#160;</a></span>deleteComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRObjects::deleteComponents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteTangents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteUnwrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteUnusedUvChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteEmptyFacegroups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes selected object components: tangents, unwrap, uv channels not referenced by materials. </p>

</div>
</div>
<a id="acbb3351f812e372ffedae704402c9c3a" name="acbb3351f812e372ffedae704402c9c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb3351f812e372ffedae704402c9c3a">&#9670;&#160;</a></span>removeEmptyObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rr::RRObjects::removeEmptyObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes objects with zero triangles or vertices. Does not delete them. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerr.html">rr</a></li><li class="navelem"><a class="el" href="classrr_1_1_r_r_objects.html">RRObjects</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
