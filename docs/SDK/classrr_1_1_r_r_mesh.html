<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LightsprintSDK: rr::RRMesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LightsprintSDK<span id="projectnumber">&#160;2021.08.08</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrr_1_1_r_r_mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrr_1_1_r_r_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rr::RRMesh Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;RRMesh.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for rr::RRMesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrr_1_1_r_r_mesh.png" usemap="#rr::RRMesh_map" alt=""/>
  <map id="rr::RRMesh_map" name="rr::RRMesh_map">
<area href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html" title="When used as base class, object copying is not allowed." alt="rr::RRUniformlyAllocatedNonCopyable" shape="rect" coords="0,56,227,80"/>
<area href="classrr_1_1_r_r_uniformly_allocated.html" title="When used as base class, delete works correctly without regard who calls it." alt="rr::RRUniformlyAllocated" shape="rect" coords="0,0,227,24"/>
<area href="classrr_1_1_r_r_mesh_arrays.html" title="Mesh that exposes internal structures for direct read-write access." alt="rr::RRMeshArrays" shape="rect" coords="0,168,227,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_mesh_1_1_tangent_basis.html">TangentBasis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle.html">Triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_body.html">TriangleBody</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_mapping.html">TriangleMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_normals.html">TriangleNormals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aafca80a7040dab7f61cabf1fd72dd5c8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classrr_1_1_r_r_mesh.html#aafca80a7040dab7f61cabf1fd72dd5c8a779c8c3cdd42d1f67aaba24e96928c25">UNDEFINED</a> = UINT_MAX
 }</td></tr>
<tr class="separator:aafca80a7040dab7f61cabf1fd72dd5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dd33c0cc1c283e433caaff876e9cea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">TangentSpaceState</a> { <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9ceaac65b6930468def97d343e8104a069c64">TSS_PERFECT</a>
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9ceaaef8ff4b73022603720c7dc256c37c69d">TSS_NOT_ORTHOGONAL</a>
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9ceaac020ff946cff634bca7b20ee638c9895">TSS_DENORMALIZED</a>
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9ceaacf9cde63f3d16a9820eb93e61d16a938">TSS_INVALID</a>
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9ceaadb10342cdd217edd61f07f4f4607bfe1">TSS_MISSING</a>
<br />
 }</td></tr>
<tr class="separator:a15dd33c0cc1c283e433caaff876e9cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb75f4b0c8c9b6bdb7d9488c9937327d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">Format</a> { <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327da60c52d08613cd44934e3c1cf9613d0ad">UINT8</a> = 0
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327daf7ef520c255a75707c4045d840722ff9">UINT16</a> = 1
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327dad64238a4e5fbee94af991f693aff55f3">UINT32</a> = 2
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327da8825fdd8b5e3bcf102bf6bd3f9a28e78">FLOAT32</a> = 4
<br />
 }</td></tr>
<tr class="separator:aeb75f4b0c8c9b6bdb7d9488c9937327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9131b274feb544b72e4cec5969426a8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8d">Flags</a> { <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8da4d337a865dee4ddd6f09abca39b2d43c">TRI_LIST</a> = 0
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8dafe9ac67fefe656c66f827999f361c63e">TRI_STRIP</a> = (1&lt;&lt;0)
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8da504ceabd3454658b5e77b82367e962bc">OPTIMIZED_VERTICES</a> = (1&lt;&lt;1)
, <br />
&#160;&#160;<a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8daea01ea86603a026983a000cb508f276a">OPTIMIZED_TRIANGLES</a> = (1&lt;&lt;2)
<br />
 }</td></tr>
<tr class="separator:a9131b274feb544b72e4cec5969426a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e66d58dd20cecff08521d48053b97e1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a2e66d58dd20cecff08521d48053b97e1">Vertex</a></td></tr>
<tr class="separator:a2e66d58dd20cecff08521d48053b97e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a027a7f51f517ececd0498ca41671e438"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a027a7f51f517ececd0498ca41671e438">RRMesh</a> ()</td></tr>
<tr class="separator:a027a7f51f517ececd0498ca41671e438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab888ea5c441e8c1adc1e05472907557"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#aab888ea5c441e8c1adc1e05472907557">~RRMesh</a> ()</td></tr>
<tr class="separator:aab888ea5c441e8c1adc1e05472907557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae005913efba418b039035cf63f1461fa"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#ae005913efba418b039035cf63f1461fa">getNumVertices</a> () const =0</td></tr>
<tr class="separator:ae005913efba418b039035cf63f1461fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1727afab9859b3024d96286a0e0c17a8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a1727afab9859b3024d96286a0e0c17a8">getVertex</a> (unsigned v, <a class="el" href="classrr_1_1_r_r_mesh.html#a2e66d58dd20cecff08521d48053b97e1">Vertex</a> &amp;out) const =0</td></tr>
<tr class="separator:a1727afab9859b3024d96286a0e0c17a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add094a6ba686624261bb9149c9e114ff"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#add094a6ba686624261bb9149c9e114ff">getNumTriangles</a> () const =0</td></tr>
<tr class="separator:add094a6ba686624261bb9149c9e114ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443e1c6250ebf1d9137c63d5521fbf23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a443e1c6250ebf1d9137c63d5521fbf23">getTriangle</a> (unsigned t, <a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle.html">Triangle</a> &amp;out) const =0</td></tr>
<tr class="separator:a443e1c6250ebf1d9137c63d5521fbf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf95a0baae6570ebb40119c4d82f6b61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#adf95a0baae6570ebb40119c4d82f6b61">getTriangleBody</a> (unsigned t, <a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_body.html">TriangleBody</a> &amp;out) const</td></tr>
<tr class="separator:adf95a0baae6570ebb40119c4d82f6b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6357a40699a6b9f199cff6694ebee819"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a6357a40699a6b9f199cff6694ebee819">getTrianglePlane</a> (unsigned t, <a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;out) const</td></tr>
<tr class="separator:a6357a40699a6b9f199cff6694ebee819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5615ac354089eaa87e5cb9f68343fc28"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a5615ac354089eaa87e5cb9f68343fc28">getTriangleArea</a> (unsigned t) const</td></tr>
<tr class="separator:a5615ac354089eaa87e5cb9f68343fc28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aa9408e0dd66d9d2fc08d5ce4f0a09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#ad9aa9408e0dd66d9d2fc08d5ce4f0a09">getTriangleNormals</a> (unsigned t, <a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_normals.html">TriangleNormals</a> &amp;out) const</td></tr>
<tr class="separator:ad9aa9408e0dd66d9d2fc08d5ce4f0a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf8219ae3df7e34f39f5827134697ea"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#acdf8219ae3df7e34f39f5827134697ea">getTriangleMapping</a> (unsigned t, <a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_mapping.html">TriangleMapping</a> &amp;out, unsigned channel) const</td></tr>
<tr class="separator:acdf8219ae3df7e34f39f5827134697ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1552d5aec248ea60aa77fb47623f9af"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#aa1552d5aec248ea60aa77fb47623f9af">getPreImportVertex</a> (unsigned postImportVertex, unsigned postImportTriangle) const</td></tr>
<tr class="separator:aa1552d5aec248ea60aa77fb47623f9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089156c85c6c56950f8cc1c598f63a8f"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a089156c85c6c56950f8cc1c598f63a8f">getPostImportVertex</a> (<a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a> preImportVertex, <a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a> preImportTriangle) const</td></tr>
<tr class="separator:a089156c85c6c56950f8cc1c598f63a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde6e3b46f5c5da023e4f521137a9756"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#acde6e3b46f5c5da023e4f521137a9756">getPreImportTriangle</a> (unsigned postImportTriangle) const</td></tr>
<tr class="separator:acde6e3b46f5c5da023e4f521137a9756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79639e38e86a8797688333b8b3e53237"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a79639e38e86a8797688333b8b3e53237">getPostImportTriangle</a> (<a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a> preImportTriangle) const</td></tr>
<tr class="separator:a79639e38e86a8797688333b8b3e53237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad26eff04f577997e5df75b08a4cb12"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a6ad26eff04f577997e5df75b08a4cb12">getNumPreImportVertices</a> () const</td></tr>
<tr class="separator:a6ad26eff04f577997e5df75b08a4cb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254b4a8e5734d5b28febf8f027f9e56a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a254b4a8e5734d5b28febf8f027f9e56a">getUvChannels</a> (<a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; &amp;out) const</td></tr>
<tr class="separator:a254b4a8e5734d5b28febf8f027f9e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcf14481aea82eb29c2d9a557e5d9c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a4dcf14481aea82eb29c2d9a557e5d9c0">getAABB</a> (<a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *mini, <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *maxi, <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *center) const</td></tr>
<tr class="separator:a4dcf14481aea82eb29c2d9a557e5d9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148434402c8c3e1f6cef35610c74c4b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a148434402c8c3e1f6cef35610c74c4b6">getAverageVertexDistance</a> () const</td></tr>
<tr class="separator:a148434402c8c3e1f6cef35610c74c4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eadb845475d80d24f9ca3b110e20419"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a5eadb845475d80d24f9ca3b110e20419">getMappingDensity</a> (unsigned channel) const</td></tr>
<tr class="separator:a5eadb845475d80d24f9ca3b110e20419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb54c658789eea4d939c75e62bfa2f8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#aacb54c658789eea4d939c75e62bfa2f8">findGroundLevel</a> () const</td></tr>
<tr class="separator:aacb54c658789eea4d939c75e62bfa2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf4e9987eab44feb7d1cef272ba9940"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classrr_1_1_r_r_hash.html">RRHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#aeaf4e9987eab44feb7d1cef272ba9940">getHash</a> () const</td></tr>
<tr class="separator:aeaf4e9987eab44feb7d1cef272ba9940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857eeefb21b0d567e7600051f08bddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">TangentSpaceState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a4857eeefb21b0d567e7600051f08bddd">checkNormals</a> () const</td></tr>
<tr class="separator:a4857eeefb21b0d567e7600051f08bddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1074bb8d9e799eb4cebb52dcb3490b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">TangentSpaceState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a1074bb8d9e799eb4cebb52dcb3490b45">checkTangents</a> () const</td></tr>
<tr class="separator:a1074bb8d9e799eb4cebb52dcb3490b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535a1d05d06800d3d34645bd208730ea"><td class="memItemLeft" align="right" valign="top">virtual unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a535a1d05d06800d3d34645bd208730ea">checkConsistency</a> (unsigned lightmapTexcoord, const char *meshName, class NumReports *numReports=nullptr) const</td></tr>
<tr class="separator:a535a1d05d06800d3d34645bd208730ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85d7cf36813f53c4fe710eaf078594a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#af85d7cf36813f53c4fe710eaf078594a">createTransformed</a> (const <a class="el" href="structrr_1_1_r_r_matrix3x4_ex.html">RRMatrix3x4Ex</a> *transform) const</td></tr>
<tr class="separator:af85d7cf36813f53c4fe710eaf078594a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fce73ac52d1d65cd7ab15a365fdd833"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a4fce73ac52d1d65cd7ab15a365fdd833">createOptimizedVertices</a> (float maxDistanceBetweenVerticesToMerge, float maxRadiansBetweenNormalsToMerge, float maxDistanceBetweenUvsToMerge, const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; *texcoords) const</td></tr>
<tr class="separator:a4fce73ac52d1d65cd7ab15a365fdd833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c07a77b8514259772dd73df4930f9d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a8c07a77b8514259772dd73df4930f9d2">createOptimizedTriangles</a> () const</td></tr>
<tr class="separator:a8c07a77b8514259772dd73df4930f9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af55bf6f6fe99167def007726115920"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a9af55bf6f6fe99167def007726115920">createAccelerated</a> () const</td></tr>
<tr class="separator:a9af55bf6f6fe99167def007726115920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e51872d720417ac8a7c1f8a1ed6e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#ac2e51872d720417ac8a7c1f8a1ed6e53">createVertexBufferRuler</a> () const</td></tr>
<tr class="separator:ac2e51872d720417ac8a7c1f8a1ed6e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfc7ca590cfe3553d16a08d3122f827"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classrr_1_1_r_r_mesh_arrays.html">RRMeshArrays</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a4dfc7ca590cfe3553d16a08d3122f827">createArrays</a> (bool indexed, const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; &amp;texcoords, bool tangents) const</td></tr>
<tr class="separator:a4dfc7ca590cfe3553d16a08d3122f827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrr_1_1_r_r_uniformly_allocated"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrr_1_1_r_r_uniformly_allocated')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated.html">rr::RRUniformlyAllocated</a></td></tr>
<tr class="memitem:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a073b837b152a4c54b8b581bd2e82ec08">operator new</a> (std::size_t n)</td></tr>
<tr class="separator:a073b837b152a4c54b8b581bd2e82ec08 inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a1f55fa066eee7b98a94c98fbecdbaeef">operator new[]</a> (std::size_t n)</td></tr>
<tr class="separator:a1f55fa066eee7b98a94c98fbecdbaeef inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#ac0d7217fef84aacf42287c189423e15e">operator delete</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:ac0d7217fef84aacf42287c189423e15e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated.html#a42a7c29977989c72d78660bd487cc97e">operator delete[]</a> (void *p, std::size_t n)</td></tr>
<tr class="separator:a42a7c29977989c72d78660bd487cc97e inherit pub_methods_classrr_1_1_r_r_uniformly_allocated"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae9328e59ac68ab2d85063b69f3b82bfb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#ae9328e59ac68ab2d85063b69f3b82bfb">create</a> (unsigned flags, <a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">Format</a> vertexFormat, void *vertexBuffer, unsigned vertexCount, unsigned vertexStride)</td></tr>
<tr class="separator:ae9328e59ac68ab2d85063b69f3b82bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9021dbb7cb04689d219d884fccf84b96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a9021dbb7cb04689d219d884fccf84b96">createIndexed</a> (unsigned flags, <a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">Format</a> vertexFormat, void *vertexBuffer, unsigned vertexCount, unsigned vertexStride, <a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">Format</a> indexFormat, void *indexBuffer, unsigned indexCount, float vertexStitchMaxDistance=0)</td></tr>
<tr class="separator:a9021dbb7cb04689d219d884fccf84b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0861c036c587f1f39da82edb169423bb"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a0861c036c587f1f39da82edb169423bb">createMultiMesh</a> (const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *const *meshes, unsigned numMeshes, bool fast)</td></tr>
<tr class="separator:a0861c036c587f1f39da82edb169423bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a68abd4137b3c58c6b72e0d698f6d346c"><td class="memItemLeft" align="right" valign="top">struct AABBCache *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_mesh.html#a68abd4137b3c58c6b72e0d698f6d346c">aabbCache</a></td></tr>
<tr class="separator:a68abd4137b3c58c6b72e0d698f6d346c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html">rr::RRUniformlyAllocatedNonCopyable</a></td></tr>
<tr class="memitem:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a2fb6eae4adda7ad435a7aa482d1005cd">RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a2fb6eae4adda7ad435a7aa482d1005cd inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrr_1_1_r_r_uniformly_allocated_non_copyable.html#a7c05e32bc9c7a711d579fc328cb3392a">~RRUniformlyAllocatedNonCopyable</a> ()</td></tr>
<tr class="separator:a7c05e32bc9c7a711d579fc328cb3392a inherit pro_methods_classrr_1_1_r_r_uniformly_allocated_non_copyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common interface for any standard or proprietary triangle mesh structure. </p>
<p><a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a> is typically only several bytes big adaptor, it provides unified interface to your mesh, but it uses your mesh data, no data need to be duplicated.</p>
<p>Thread safe: yes, may be accessed by any number of threads simultaneously.</p>
<h1><a class="anchor" id="sm1"></a>
Creating instances</h1>
<p>RRMesh has built-in support for standard mesh formats used by rendering APIs - vertex and index buffers using triangle lists or triangle strips. See <a class="el" href="classrr_1_1_r_r_mesh.html#ae9328e59ac68ab2d85063b69f3b82bfb" title="Creates RRMesh from your vertex buffer.">create()</a> and <a class="el" href="classrr_1_1_r_r_mesh.html#a9021dbb7cb04689d219d884fccf84b96" title="Creates RRMesh from your vertex and index buffers.">createIndexed()</a>.</p>
<p>RRMesh has built-in support for baking multiple meshes into one mesh (without need for additional memory). This may simplify mesh oprations or improve performance in some situations. See <a class="el" href="classrr_1_1_r_r_mesh.html#a0861c036c587f1f39da82edb169423bb" title="Creates and returns union of multiple meshes (contains vertices and triangles of all meshes).">createMultiMesh()</a>.</p>
<p>RRMesh has built-in support for creating self-contained mesh copies. See createCopy(). While importers created from vertex buffer doesn't allocate more memory and depend on vertex buffer, self-contained copy contains all mesh data and doesn't depend on any other objects.</p>
<p>For other mesh formats (heightfield, realtime generated etc), you may easily derive from RRMesh and create your own mesh adaptor.</p>
<h1><a class="anchor" id="sm2"></a>
Optimizations</h1>
<p>RRMesh may help you with mesh optimizations if requested, for example by removing duplicate vertices or degenerated triangles.</p>
<h1><a class="anchor" id="sm3"></a>
Constancy</h1>
<p>All data provided by RRMesh must be constant in time. Built-in importers guarantee constancy if you don't change their vertex/index buffers. Constancy of mesh copy is guaranteed always.</p>
<h1><a class="anchor" id="sm4"></a>
Indexing</h1>
<p>RRMesh operates with two types of vertex and triangle indices.</p><ol type="1">
<li>PostImport indices, always 0..num-1 (where num=getNumTriangles or getNumVertices), these are used in most calls. When not stated otherwise, index is PostImport. <br  />
 Example: with 100-triangle mesh, triangle indices are 0..99.</li>
<li>PreImport indices, optional, arbitrary numbers provided by importer for your convenience. <br  />
 Example: could be offsets into your vertex buffer. <br  />
 Pre&lt;-&gt;Post mapping is defined by <a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a> implementation and is arbitrary, but constant.</li>
</ol>
<p>All Pre-Post conversion functions must accept all unsigned values. When query makes no sense, they return UNDEFINED. This is because</p><ol type="1">
<li>valid PreImport numbers may be spread across whole unsigned range and caller could be unaware of their validity.</li>
<li>such queries are rare and not performance critical.</li>
</ol>
<p>All other function use PostImport numbers and may support only their 0..num-1 range. When called with out of range value, result is undefined. Debug version may return arbitrary number or throw assert. Release version may return arbitrary number or crash. This is because</p><ol type="1">
<li>valid PostImport numbers are easy to ensure on caller side.</li>
<li>such queries are very critical for performance.</li>
</ol>
<h1><a class="anchor" id="sm5_frontback"></a>
Front/back side</h1>
<p>For correct lighting, it's important to know where front and back sides of triangle are. Materials (see <a class="el" href="structrr_1_1_r_r_material.html" title="Description of material properties of a surface.">RRMaterial</a>) define some properties separately for both sides of triangle. Renderers render both sides of triangle differently.</p>
<p>When you see triangle vertices in CCW order, you see triangle's front side. In this situation triangle's normal must point to your (front) hemisphere.</p>
<p>Some applications are known to define front/back differently:</p><ul>
<li>3DS MAX</li>
<li>Quake3</li>
</ul>
<p>How to swap front/back sides, when importing data from such applications?</p><ul>
<li>Negate positions and normals in any 1 axis. If you don't provide normals in your mesh, negate positions only. See example in RRObjectBSP.cpp, getVertex.</li>
<li>Or swap any 2 vertices in triangle. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e66d58dd20cecff08521d48053b97e1" name="a2e66d58dd20cecff08521d48053b97e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e66d58dd20cecff08521d48053b97e1">&#9670;&#160;</a></span>Vertex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> <a class="el" href="classrr_1_1_r_r_mesh.html#a2e66d58dd20cecff08521d48053b97e1">rr::RRMesh::Vertex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One vertex 3d space. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aafca80a7040dab7f61cabf1fd72dd5c8" name="aafca80a7040dab7f61cabf1fd72dd5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafca80a7040dab7f61cabf1fd72dd5c8">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aafca80a7040dab7f61cabf1fd72dd5c8a779c8c3cdd42d1f67aaba24e96928c25" name="aafca80a7040dab7f61cabf1fd72dd5c8a779c8c3cdd42d1f67aaba24e96928c25"></a>UNDEFINED&#160;</td><td class="fielddoc"><p>Index value reserved for situations where result is undefined, for example because of invalid inputs. </p>
</td></tr>
</table>

</div>
</div>
<a id="a15dd33c0cc1c283e433caaff876e9cea" name="a15dd33c0cc1c283e433caaff876e9cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dd33c0cc1c283e433caaff876e9cea">&#9670;&#160;</a></span>TangentSpaceState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">rr::RRMesh::TangentSpaceState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tangent space issues sorted by seriousness. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a15dd33c0cc1c283e433caaff876e9ceaac65b6930468def97d343e8104a069c64" name="a15dd33c0cc1c283e433caaff876e9ceaac65b6930468def97d343e8104a069c64"></a>TSS_PERFECT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a15dd33c0cc1c283e433caaff876e9ceaaef8ff4b73022603720c7dc256c37c69d" name="a15dd33c0cc1c283e433caaff876e9ceaaef8ff4b73022603720c7dc256c37c69d"></a>TSS_NOT_ORTHOGONAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a15dd33c0cc1c283e433caaff876e9ceaac020ff946cff634bca7b20ee638c9895" name="a15dd33c0cc1c283e433caaff876e9ceaac020ff946cff634bca7b20ee638c9895"></a>TSS_DENORMALIZED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a15dd33c0cc1c283e433caaff876e9ceaacf9cde63f3d16a9820eb93e61d16a938" name="a15dd33c0cc1c283e433caaff876e9ceaacf9cde63f3d16a9820eb93e61d16a938"></a>TSS_INVALID&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a15dd33c0cc1c283e433caaff876e9ceaadb10342cdd217edd61f07f4f4607bfe1" name="a15dd33c0cc1c283e433caaff876e9ceaadb10342cdd217edd61f07f4f4607bfe1"></a>TSS_MISSING&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aeb75f4b0c8c9b6bdb7d9488c9937327d" name="aeb75f4b0c8c9b6bdb7d9488c9937327d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb75f4b0c8c9b6bdb7d9488c9937327d">&#9670;&#160;</a></span>Format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">rr::RRMesh::Format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifiers of data formats. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aeb75f4b0c8c9b6bdb7d9488c9937327da60c52d08613cd44934e3c1cf9613d0ad" name="aeb75f4b0c8c9b6bdb7d9488c9937327da60c52d08613cd44934e3c1cf9613d0ad"></a>UINT8&#160;</td><td class="fielddoc"><p>Id of uint8_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb75f4b0c8c9b6bdb7d9488c9937327daf7ef520c255a75707c4045d840722ff9" name="aeb75f4b0c8c9b6bdb7d9488c9937327daf7ef520c255a75707c4045d840722ff9"></a>UINT16&#160;</td><td class="fielddoc"><p>Id of uint16_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb75f4b0c8c9b6bdb7d9488c9937327dad64238a4e5fbee94af991f693aff55f3" name="aeb75f4b0c8c9b6bdb7d9488c9937327dad64238a4e5fbee94af991f693aff55f3"></a>UINT32&#160;</td><td class="fielddoc"><p>Id of uint32_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="aeb75f4b0c8c9b6bdb7d9488c9937327da8825fdd8b5e3bcf102bf6bd3f9a28e78" name="aeb75f4b0c8c9b6bdb7d9488c9937327da8825fdd8b5e3bcf102bf6bd3f9a28e78"></a>FLOAT32&#160;</td><td class="fielddoc"><p>Id of float. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9131b274feb544b72e4cec5969426a8d" name="a9131b274feb544b72e4cec5969426a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9131b274feb544b72e4cec5969426a8d">&#9670;&#160;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8d">rr::RRMesh::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags that help to specify your <a class="el" href="classrr_1_1_r_r_mesh.html#ae9328e59ac68ab2d85063b69f3b82bfb" title="Creates RRMesh from your vertex buffer.">create()</a> or <a class="el" href="classrr_1_1_r_r_mesh.html#a9021dbb7cb04689d219d884fccf84b96" title="Creates RRMesh from your vertex and index buffers.">createIndexed()</a> request. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9131b274feb544b72e4cec5969426a8da4d337a865dee4ddd6f09abca39b2d43c" name="a9131b274feb544b72e4cec5969426a8da4d337a865dee4ddd6f09abca39b2d43c"></a>TRI_LIST&#160;</td><td class="fielddoc"><p>Interpret data as triangle list. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9131b274feb544b72e4cec5969426a8dafe9ac67fefe656c66f827999f361c63e" name="a9131b274feb544b72e4cec5969426a8dafe9ac67fefe656c66f827999f361c63e"></a>TRI_STRIP&#160;</td><td class="fielddoc"><p>Interpret data as triangle strip. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9131b274feb544b72e4cec5969426a8da504ceabd3454658b5e77b82367e962bc" name="a9131b274feb544b72e4cec5969426a8da504ceabd3454658b5e77b82367e962bc"></a>OPTIMIZED_VERTICES&#160;</td><td class="fielddoc"><p>Remove identical and unused vertices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9131b274feb544b72e4cec5969426a8daea01ea86603a026983a000cb508f276a" name="a9131b274feb544b72e4cec5969426a8daea01ea86603a026983a000cb508f276a"></a>OPTIMIZED_TRIANGLES&#160;</td><td class="fielddoc"><p>Remove degenerated triangles. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a027a7f51f517ececd0498ca41671e438" name="a027a7f51f517ececd0498ca41671e438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027a7f51f517ececd0498ca41671e438">&#9670;&#160;</a></span>RRMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rr::RRMesh::RRMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab888ea5c441e8c1adc1e05472907557" name="aab888ea5c441e8c1adc1e05472907557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab888ea5c441e8c1adc1e05472907557">&#9670;&#160;</a></span>~RRMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual rr::RRMesh::~RRMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae005913efba418b039035cf63f1461fa" name="ae005913efba418b039035cf63f1461fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae005913efba418b039035cf63f1461fa">&#9670;&#160;</a></span>getNumVertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRMesh::getNumVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of vertices in mesh. </p>

<p>Implemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#a985a97c5460d163bd2c07ceafc223328">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="a1727afab9859b3024d96286a0e0c17a8" name="a1727afab9859b3024d96286a0e0c17a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1727afab9859b3024d96286a0e0c17a8">&#9670;&#160;</a></span>getVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRMesh::getVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_mesh.html#a2e66d58dd20cecff08521d48053b97e1">Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes position of v-th vertex in mesh to out. </p>
<p>Make sure you provide valid v is in range &lt;0..<a class="el" href="classrr_1_1_r_r_mesh.html#ae005913efba418b039035cf63f1461fa" title="Returns number of vertices in mesh.">getNumVertices()</a>-1&gt;. Implementations are allowed to expect valid v, result is undefined for invalid v (possible assert in debug, crash in release).</p>
<p>What exactly is vertex, do boxes have 8 or 24 vertices? <br  />
 <a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a>, <a class="el" href="classrr_1_1_r_r_collider.html" title="Finds ray - trianglemesh intersections.">RRCollider</a> and <a class="el" href="classrr_1_1_r_r_object.html" title="Common interface for all proprietary object formats.">RRObject</a> create no constraints, you are free to use your favorite approach - create box with 8 or 24 or any other number of vertices greater than 8, collisions and illumination will be computed correctly. (24 because each one of 8 vertices is used by 3 sides with different normal) <br  />
 <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a> depends on vertex list defined here. If you request vertex buffer with per-vertex illumination, vertex buffer will have <a class="el" href="classrr_1_1_r_r_mesh.html#ae005913efba418b039035cf63f1461fa" title="Returns number of vertices in mesh.">getNumVertices()</a> items. So when writing new <a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a> implementations, create vertex list so that vertex buffers with the same size and vertex order are compatible with your renderer. </p>

<p>Implemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#ae85d86d2207bd34c1cf3e91a55a5bd09">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="add094a6ba686624261bb9149c9e114ff" name="add094a6ba686624261bb9149c9e114ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add094a6ba686624261bb9149c9e114ff">&#9670;&#160;</a></span>getNumTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRMesh::getNumTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of triangles in mesh. </p>

<p>Implemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#a341c879198e06097f61fef2563941e7a">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="a443e1c6250ebf1d9137c63d5521fbf23" name="a443e1c6250ebf1d9137c63d5521fbf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443e1c6250ebf1d9137c63d5521fbf23">&#9670;&#160;</a></span>getTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRMesh::getTriangle </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle.html">Triangle</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes t-th triangle in mesh to out. </p>
<p>Make sure you provide valid t in range &lt;0..<a class="el" href="classrr_1_1_r_r_mesh.html#add094a6ba686624261bb9149c9e114ff" title="Returns number of triangles in mesh.">getNumTriangles()</a>-1&gt;. Implementators are allowed to expect valid t (performance reasons, may be called very often), so result is completely undefined for invalid t (possible crash).</p>
<p>Order of vertices in triangle has influence on what side of triangle is front, which is important for lighting. See more details in <a class="el" href="classrr_1_1_r_r_mesh.html#sm5_frontback">Front/back side</a>. </p>

<p>Implemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#aa79d67629903bc24ee6c82bc5afe06d5">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="adf95a0baae6570ebb40119c4d82f6b61" name="adf95a0baae6570ebb40119c4d82f6b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf95a0baae6570ebb40119c4d82f6b61">&#9670;&#160;</a></span>getTriangleBody()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRMesh::getTriangleBody </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_body.html">TriangleBody</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes t-th triangle in mesh to out. </p>
<p>Make sure you provide valid t in range &lt;0..<a class="el" href="classrr_1_1_r_r_mesh.html#add094a6ba686624261bb9149c9e114ff" title="Returns number of triangles in mesh.">getNumTriangles()</a>-1&gt;. Implementators are allowed to expect valid t, so result is completely undefined for invalid t (possible crash). <br  />
 There is default implementation, but if you know format of your data well, you may provide faster one. <br  />
 Speed of this function is important for intersection tests performance. </p>

<p>Reimplemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#a113f3539d2beddfb6f599fb8dec00f83">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="a6357a40699a6b9f199cff6694ebee819" name="a6357a40699a6b9f199cff6694ebee819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6357a40699a6b9f199cff6694ebee819">&#9670;&#160;</a></span>getTrianglePlane()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRMesh::getTrianglePlane </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec4.html">RRVec4</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes t-th triangle plane to out. </p>
<p>Be sure to provide valid t is in range &lt;0..<a class="el" href="classrr_1_1_r_r_mesh.html#add094a6ba686624261bb9149c9e114ff" title="Returns number of triangles in mesh.">getNumTriangles()</a>-1&gt;. Implementators are allowed to expect valid t, so result is completely undefined for invalid t (possible crash). <br  />
 There is default implementation, but if you know format of your data well, you may provide faster one. </p>

</div>
</div>
<a id="a5615ac354089eaa87e5cb9f68343fc28" name="a5615ac354089eaa87e5cb9f68343fc28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5615ac354089eaa87e5cb9f68343fc28">&#9670;&#160;</a></span>getTriangleArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> rr::RRMesh::getTriangleArea </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns area of t-th triangle. </p>
<p>Be sure to provide valid t is in range &lt;0..<a class="el" href="classrr_1_1_r_r_mesh.html#add094a6ba686624261bb9149c9e114ff" title="Returns number of triangles in mesh.">getNumTriangles()</a>-1&gt;. Implementators are allowed to expect valid t, so result is completely undefined for invalid t (possible crash). <br  />
 There is default implementation, but if you know format of your data well, you may provide faster one. </p>

</div>
</div>
<a id="ad9aa9408e0dd66d9d2fc08d5ce4f0a09" name="ad9aa9408e0dd66d9d2fc08d5ce4f0a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aa9408e0dd66d9d2fc08d5ce4f0a09">&#9670;&#160;</a></span>getTriangleNormals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRMesh::getTriangleNormals </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_normals.html">TriangleNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes tangent bases in triangle vertices to out. Normals are part of bases. </p>
<p>Tangent bases are used by global illumination solver and renderer. Normals should point to front side hemisphere, see <a class="el" href="classrr_1_1_r_r_mesh.html#sm5_frontback">Front/back side</a>. <br  />
 Default implementation writes all vertex normals equal to triangle plane normal and constructs appropriate tangent space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Index of triangle. Valid t is in range &lt;0..<a class="el" href="classrr_1_1_r_r_mesh.html#add094a6ba686624261bb9149c9e114ff" title="Returns number of triangles in mesh.">getNumTriangles()</a>-1&gt;. </td></tr>
    <tr><td class="paramname">out</td><td>Caller provided storage for result. For valid t, requested normals are written to out. For invalid t, out stays unmodified. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#ac2f98479100f47600de78c5d5166c886">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="acdf8219ae3df7e34f39f5827134697ea" name="acdf8219ae3df7e34f39f5827134697ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf8219ae3df7e34f39f5827134697ea">&#9670;&#160;</a></span>getTriangleMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool rr::RRMesh::getTriangleMapping </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_mapping.html">TriangleMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes t-th triangle's uv mapping to out. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Index of triangle. Valid t is in range &lt;0..<a class="el" href="classrr_1_1_r_r_mesh.html#add094a6ba686624261bb9149c9e114ff" title="Returns number of triangles in mesh.">getNumTriangles()</a>-1&gt;. </td></tr>
    <tr><td class="paramname">out</td><td>Caller provided storage for result. For valid t, requested mapping is written to out. For invalid t, out stays unmodified. </td></tr>
    <tr><td class="paramname">channel</td><td>Texcoord channel to use, RRMaterial::diffuseReflectance.texcoord for diffuse texture mapping, RRMaterial::lightmap.texcoord for unwrap used by lightmaps etc. <br  />
 Note that for proper lighting, unwrap must have all coordinates in &lt;0..1&gt; range and triangles must not overlap. Unwrap may be imported or automatically generated by <a class="el" href="classrr_1_1_r_r_objects.html#a1995f293b3e08eaaa283765d37ecd03f" title="Rebuilds unwrap in all meshes of RRMeshArrays type.">RRObjects::buildUnwrap()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True for valid t and supported channel, result was written to out. False for invalid t or unsupported channel, out stays unmodified. </dd></dl>

<p>Reimplemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#ab9c6311406bb477706284ad43764c4cd">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="aa1552d5aec248ea60aa77fb47623f9af" name="aa1552d5aec248ea60aa77fb47623f9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1552d5aec248ea60aa77fb47623f9af">&#9670;&#160;</a></span>getPreImportVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a> rr::RRMesh::getPreImportVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>postImportVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>postImportTriangle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns PreImport index of given vertex or UNDEFINED for invalid inputs. </p>

</div>
</div>
<a id="a089156c85c6c56950f8cc1c598f63a8f" name="a089156c85c6c56950f8cc1c598f63a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089156c85c6c56950f8cc1c598f63a8f">&#9670;&#160;</a></span>getPostImportVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRMesh::getPostImportVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a>&#160;</td>
          <td class="paramname"><em>preImportVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a>&#160;</td>
          <td class="paramname"><em>preImportTriangle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns PostImport index of given vertex or UNDEFINED for invalid inputs. </p>

</div>
</div>
<a id="acde6e3b46f5c5da023e4f521137a9756" name="acde6e3b46f5c5da023e4f521137a9756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde6e3b46f5c5da023e4f521137a9756">&#9670;&#160;</a></span>getPreImportTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a> rr::RRMesh::getPreImportTriangle </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>postImportTriangle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns PreImport index of given triangle or UNDEFINED for invalid inputs. </p>

</div>
</div>
<a id="a79639e38e86a8797688333b8b3e53237" name="a79639e38e86a8797688333b8b3e53237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79639e38e86a8797688333b8b3e53237">&#9670;&#160;</a></span>getPostImportTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRMesh::getPostImportTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html">PreImportNumber</a>&#160;</td>
          <td class="paramname"><em>preImportTriangle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns PostImport index of given triangle or UNDEFINED for invalid inputs. </p>

</div>
</div>
<a id="a6ad26eff04f577997e5df75b08a4cb12" name="a6ad26eff04f577997e5df75b08a4cb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad26eff04f577997e5df75b08a4cb12">&#9670;&#160;</a></span>getNumPreImportVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rr::RRMesh::getNumPreImportVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns highest PreImport vertex number+1. </p>
<p>PreImport numbers are used as positions of vertices in vertex buffer, so returned number is also size of vertex buffer. Very slow (checks all vertices). </p>

</div>
</div>
<a id="a254b4a8e5734d5b28febf8f027f9e56a" name="a254b4a8e5734d5b28febf8f027f9e56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254b4a8e5734d5b28febf8f027f9e56a">&#9670;&#160;</a></span>getUvChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRMesh::getUvChannels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills out with uv channels provided by mesh, in ascending order. Default implementation queries presence of channels 0 to 100, ignores higher channels. </p>

<p>Reimplemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#ac8e1450cf7bd499dad95e61021604e0b">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="a4dcf14481aea82eb29c2d9a557e5d9c0" name="a4dcf14481aea82eb29c2d9a557e5d9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcf14481aea82eb29c2d9a557e5d9c0">&#9670;&#160;</a></span>getAABB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void rr::RRMesh::getAABB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *&#160;</td>
          <td class="paramname"><em>mini</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *&#160;</td>
          <td class="paramname"><em>maxi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrr_1_1_r_r_vec3.html">RRVec3</a> *&#160;</td>
          <td class="paramname"><em>center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns axis aligned bounding box and center of mesh. Fast (cached). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mini</td><td>nullptr or pointer to vec3 to be filled with minimum of computed AABB. </td></tr>
    <tr><td class="paramname">maxi</td><td>nullptr or pointer to vec3 to be filled with maximum of computed AABB. </td></tr>
    <tr><td class="paramname">center</td><td>nullptr or pointer to vec3 to be filled with average vertex position. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrr_1_1_r_r_mesh_arrays.html#a6eafaa0c7246c3f58f063ab7a4d9ff75">rr::RRMeshArrays</a>.</p>

</div>
</div>
<a id="a148434402c8c3e1f6cef35610c74c4b6" name="a148434402c8c3e1f6cef35610c74c4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148434402c8c3e1f6cef35610c74c4b6">&#9670;&#160;</a></span>getAverageVertexDistance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> rr::RRMesh::getAverageVertexDistance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns average distance between two vertices. Slow (not cached). </p>

</div>
</div>
<a id="a5eadb845475d80d24f9ca3b110e20419" name="a5eadb845475d80d24f9ca3b110e20419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eadb845475d80d24f9ca3b110e20419">&#9670;&#160;</a></span>getMappingDensity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> rr::RRMesh::getMappingDensity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns median of (edge_length / edge_length_in_texture_space). Slow (not cached). </p>

</div>
</div>
<a id="aacb54c658789eea4d939c75e62bfa2f8" name="aacb54c658789eea4d939c75e62bfa2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb54c658789eea4d939c75e62bfa2f8">&#9670;&#160;</a></span>findGroundLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacerr.html#a8c3ad836b176dd33045b4682306bb6ae">RRReal</a> rr::RRMesh::findGroundLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns y coordinate of plane where triangles facing straight up have the biggest total area. In CG scenes, this is usually flat ground. Slow (not cached). </p>

</div>
</div>
<a id="aeaf4e9987eab44feb7d1cef272ba9940" name="aeaf4e9987eab44feb7d1cef272ba9940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf4e9987eab44feb7d1cef272ba9940">&#9670;&#160;</a></span>getHash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classrr_1_1_r_r_hash.html">RRHash</a> rr::RRMesh::getHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns hash of mesh geometry (positions, not normals and uvs). Slow (not cached). </p>

</div>
</div>
<a id="a4857eeefb21b0d567e7600051f08bddd" name="a4857eeefb21b0d567e7600051f08bddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4857eeefb21b0d567e7600051f08bddd">&#9670;&#160;</a></span>checkNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">TangentSpaceState</a> rr::RRMesh::checkNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1074bb8d9e799eb4cebb52dcb3490b45" name="a1074bb8d9e799eb4cebb52dcb3490b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1074bb8d9e799eb4cebb52dcb3490b45">&#9670;&#160;</a></span>checkTangents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_mesh.html#a15dd33c0cc1c283e433caaff876e9cea">TangentSpaceState</a> rr::RRMesh::checkTangents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a535a1d05d06800d3d34645bd208730ea" name="a535a1d05d06800d3d34645bd208730ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535a1d05d06800d3d34645bd208730ea">&#9670;&#160;</a></span>checkConsistency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned rr::RRMesh::checkConsistency </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>lightmapTexcoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>meshName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class NumReports *&#160;</td>
          <td class="paramname"><em>numReports</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports inconsistencies found in mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightmapTexcoord</td><td>Optional lightmap texcoord channel (it is stored in RRMaterial::lightmap.texcoord). UINT_MAX disables unwrap check. </td></tr>
    <tr><td class="paramname">meshName</td><td>Optional mesh name included in report if inconsistency is found. May be nullptr. </td></tr>
    <tr><td class="paramname">numReports</td><td>Reserved, keep it nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of problem reported, 0 for valid mesh. </dd></dl>

</div>
</div>
<a id="ae9328e59ac68ab2d85063b69f3b82bfb" name="ae9328e59ac68ab2d85063b69f3b82bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9328e59ac68ab2d85063b69f3b82bfb">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::create </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">Format</a>&#160;</td>
          <td class="paramname"><em>vertexFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vertexStride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates RRMesh from your vertex buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>See <a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8d" title="Flags that help to specify your create() or createIndexed() request.">Flags</a>. Note that optimizations are not implemented for triangle lists, OPTIMIZE_XXX flags will be silently ignored. </td></tr>
    <tr><td class="paramname">vertexFormat</td><td>Format of data in your vertex buffer. See <a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d" title="Identifiers of data formats.">Format</a>. Currently only FLOAT32 is supported. </td></tr>
    <tr><td class="paramname">vertexBuffer</td><td>Your vertex buffer. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices in your vertex buffer. </td></tr>
    <tr><td class="paramname">vertexStride</td><td>Distance (in bytes) between n-th and (n+1)th vertex in your vertex buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly created instance of <a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a> or nullptr in case of unsupported or invalid inputs. </dd></dl>

</div>
</div>
<a id="a9021dbb7cb04689d219d884fccf84b96" name="a9021dbb7cb04689d219d884fccf84b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9021dbb7cb04689d219d884fccf84b96">&#9670;&#160;</a></span>createIndexed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::createIndexed </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">Format</a>&#160;</td>
          <td class="paramname"><em>vertexFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vertexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vertexStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d">Format</a>&#160;</td>
          <td class="paramname"><em>indexFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>indexBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vertexStitchMaxDistance</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates RRMesh from your vertex and index buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>See <a class="el" href="classrr_1_1_r_r_mesh.html#a9131b274feb544b72e4cec5969426a8d" title="Flags that help to specify your create() or createIndexed() request.">Flags</a>. </td></tr>
    <tr><td class="paramname">vertexFormat</td><td>Format of data in your your vertex buffer. See <a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d" title="Identifiers of data formats.">Format</a>. Currently only FLOAT32 is supported. </td></tr>
    <tr><td class="paramname">vertexBuffer</td><td>Your vertex buffer. </td></tr>
    <tr><td class="paramname">vertexCount</td><td>Number of vertices in your vertex buffer. </td></tr>
    <tr><td class="paramname">vertexStride</td><td>Distance (in bytes) between n-th and (n+1)th vertex in your vertex buffer. </td></tr>
    <tr><td class="paramname">indexFormat</td><td>Format of data in your index buffer. See <a class="el" href="classrr_1_1_r_r_mesh.html#aeb75f4b0c8c9b6bdb7d9488c9937327d" title="Identifiers of data formats.">Format</a>. Only UINT8, UINT16 and UINT32 is supported. </td></tr>
    <tr><td class="paramname">indexBuffer</td><td>Your index buffer. </td></tr>
    <tr><td class="paramname">indexCount</td><td>Number of indices in your index buffer. </td></tr>
    <tr><td class="paramname">vertexStitchMaxDistance</td><td>Max distance for vertex stitching. For default 0, vertices with equal coordinates are stitched and get equal vertex index (number of vertices returned by <a class="el" href="classrr_1_1_r_r_mesh.html#ae005913efba418b039035cf63f1461fa" title="Returns number of vertices in mesh.">getNumVertices()</a> is then lower). For negative value, no stitching is performed. For positive value, also vertices in lower or equal distance will be stitched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Newly created instance of <a class="el" href="classrr_1_1_r_r_mesh.html" title="Common interface for any standard or proprietary triangle mesh structure.">RRMesh</a> or nullptr in case of unsupported or invalid inputs. </dd></dl>

</div>
</div>
<a id="af85d7cf36813f53c4fe710eaf078594a" name="af85d7cf36813f53c4fe710eaf078594a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85d7cf36813f53c4fe710eaf078594a">&#9670;&#160;</a></span>createTransformed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::createTransformed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrr_1_1_r_r_matrix3x4_ex.html">RRMatrix3x4Ex</a> *&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns transformed mesh. </p>
<p>Created instance doesn't require additional memory, but it depends on 'this' mesh and 'transform' matrix, both must stay alive for whole life of created instance. You can even modify 'this' and 'transform' later and created mesh gets modified too.</p>
<p>Usually used when mesh in world space is needed and we have mesh in local space. In this case, world space matrix (the one that transforms from local to world) should be passed in transform.</p>
<p>Only positions/normals/tangent space are transformed, custom channels are left untouched.</p>
<p>Non-uniform transformations break tangent space orthogonality. </p>

</div>
</div>
<a id="a0861c036c587f1f39da82edb169423bb" name="a0861c036c587f1f39da82edb169423bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0861c036c587f1f39da82edb169423bb">&#9670;&#160;</a></span>createMultiMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::createMultiMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> *const *&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numMeshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fast</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns union of multiple meshes (contains vertices and triangles of all meshes). </p>
<p>Created instance (MultiMesh) doesn't require additional memory, but it depends on all meshes from array, they must stay alive for whole life of MultiMesh. <br  />
 This can be used to accelerate calculations, as one big object is nearly always faster than multiple small objects. <br  />
 This can be used to simplify calculations, as processing one object may be simpler than processing array of objects. <br  />
 For array with 1 element, pointer to that element may be returned. <br  />
<br  />
 If you need to locate original triangles and vertices in MultiMesh, you have two choices:</p><ol type="1">
<li>Use PreImpport&lt;-&gt;PostImport conversions. PreImport number for MultiMesh is defined as <a class="el" href="structrr_1_1_r_r_mesh_1_1_pre_import_number.html" title="PreImport number, index of vertex or triangle before import.">PreImportNumber</a>. If you want to access triangle 2 in meshes[1], calculate index of triangle in MultiMesh as indexOfTriangle = multiMesh-&gt;getPostImportTriangle(PreImportNumber(1,2)).</li>
<li>Convert indices yourself. It is granted, that both indices and vertices preserve order of meshes in array: lowest indices belong to meshes[0], meshes[1] follow etc. If you create MultiMesh from 2 meshes, first with 3 vertices and second with 5 vertices, they will transform into 0,1,2 and 3,4,5,6,7 vertices in MultiMesh. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshes</td><td>Array of meshes, source data for MultiMesh. </td></tr>
    <tr><td class="paramname">numMeshes</td><td>Length of 'meshes' array. </td></tr>
    <tr><td class="paramname">fast</td><td>With false, multimesh has fixed size of several bytes. With true, multimesh allocates 8 bytes per triangle, but it is faster, especially in scenes made of hundreds of small meshes. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="a4fce73ac52d1d65cd7ab15a365fdd833" name="a4fce73ac52d1d65cd7ab15a365fdd833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fce73ac52d1d65cd7ab15a365fdd833">&#9670;&#160;</a></span>createOptimizedVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::createOptimizedVertices </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistanceBetweenVerticesToMerge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxRadiansBetweenNormalsToMerge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>maxDistanceBetweenUvsToMerge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; *&#160;</td>
          <td class="paramname"><em>texcoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns nearly identical mesh with optimized set of vertices (removes unused and redundant ones). </p>
<p>Merges identical or similar vertices so that number of vertices in returned mesh decreases. Only vertex positions, normals and uvs are tested, so vertices with completely different tangents may be merged.</p>
<p>Created instance requires only small amount of additional memory, but it depends on 'this' mesh, 'this' must stay alive for whole life of created instance. If no vertex can be removed, 'this' is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDistanceBetweenVerticesToMerge</td><td>Vertices are not merged if their positions differ more. If negative, vertices are never merged, but unused ones can still be removed. </td></tr>
    <tr><td class="paramname">maxRadiansBetweenNormalsToMerge</td><td>Vertices are not merged if their normals differ more. If negative, vertices are never merged, but unused ones can still be removed. </td></tr>
    <tr><td class="paramname">maxDistanceBetweenUvsToMerge</td><td>Vertices are not merged if their uvs from texcoords differ more. </td></tr>
    <tr><td class="paramname">texcoords</td><td>Vertices are not merged if their uvs from texcoords differ more than maxDistanceBetweenUvsToMerge. May be nullptr. Uvs not listed in texcoords are ignored, differences in such channels don't prevent merging. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c07a77b8514259772dd73df4930f9d2" name="a8c07a77b8514259772dd73df4930f9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c07a77b8514259772dd73df4930f9d2">&#9670;&#160;</a></span>createOptimizedTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::createOptimizedTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns identical mesh with optimized set of triangles (removes degenerated triangles). </p>
<p>Created instance requires only small amount of additional memory, but it depends on 'this' mesh, 'this' must stay alive for whole life of created instance. If 'this' is already optimal, 'this' is returned. Note that after removal of degenrated triangles, there might be unused vertices in mesh; you can use <a class="el" href="classrr_1_1_r_r_mesh.html#a4fce73ac52d1d65cd7ab15a365fdd833" title="Creates and returns nearly identical mesh with optimized set of vertices (removes unused and redundan...">createOptimizedVertices()</a> to remove them. </p>

</div>
</div>
<a id="a9af55bf6f6fe99167def007726115920" name="a9af55bf6f6fe99167def007726115920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af55bf6f6fe99167def007726115920">&#9670;&#160;</a></span>createAccelerated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::createAccelerated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns accelerated mesh. </p>
<p>Created instance caches all TriangleBase and <a class="el" href="structrr_1_1_r_r_mesh_1_1_triangle_normals.html" title="Tangent bases in object space, for three vertices in triangle.">TriangleNormals</a> for whole mesh, so it allocates 144 bytes per triangle. It still depends on 'this' mesh, 'this' must stay alive for whole life of created instance.</p>
<p>It is very efficient when applied on multimesh made of hundreds of smaller meshes. It accelerates getTriangleBase() and <a class="el" href="classrr_1_1_r_r_mesh.html#ad9aa9408e0dd66d9d2fc08d5ce4f0a09" title="Writes tangent bases in triangle vertices to out. Normals are part of bases.">getTriangleNormals()</a>. These functions are critical for performance of BSP_COMPACT and BSP_FAST colliders. Colliders are critical for performance of lightmap building.</p>
<p>In practice, this function is not needed for lightmap building, use collider types BSP_COMPACT, BSP_FAST, BSP_FASTER, BSP_FASTEST in <a class="el" href="classrr_1_1_r_r_solver.html#a4310e713dc21242394e3601303ee8ae9" title="Sets static contents of scene, all static objects at once. Only objects with ! RRObject::isDynamic ar...">RRSolver::setStaticObjects()</a> to trade performance / memory. </p>

</div>
</div>
<a id="ac2e51872d720417ac8a7c1f8a1ed6e53" name="ac2e51872d720417ac8a7c1f8a1ed6e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e51872d720417ac8a7c1f8a1ed6e53">&#9670;&#160;</a></span>createVertexBufferRuler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a> * rr::RRMesh::createVertexBufferRuler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns identical mesh with all optimizations and filters previously applied baked. </p>
<p>Created instance doesn't require additional memory, but it depends on 'this' mesh, 'this' must stay alive for whole life of created instance.</p>
<p>All other mesh filters and optimizers let you convert between original and new triangle and vertex numbers using <a class="el" href="classrr_1_1_r_r_mesh.html#aa1552d5aec248ea60aa77fb47623f9af" title="Returns PreImport index of given vertex or UNDEFINED for invalid inputs.">getPreImportVertex()</a> and <a class="el" href="classrr_1_1_r_r_mesh.html#acde6e3b46f5c5da023e4f521137a9756" title="Returns PreImport index of given triangle or UNDEFINED for invalid inputs.">getPreImportTriangle()</a>. This filter only erases original (preImport) numbers and sets them equal to current (postImport) numbers. PreImport numbers are used by <a class="el" href="classrr_1_1_r_r_solver.html" title="Global illumination solver for interactive applications.">RRSolver</a> for vertex buffer layout, so this filter adjusts layout of generated vertex buffers to use current vertex numbers. </p>

</div>
</div>
<a id="a4dfc7ca590cfe3553d16a08d3122f827" name="a4dfc7ca590cfe3553d16a08d3122f827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfc7ca590cfe3553d16a08d3122f827">&#9670;&#160;</a></span>createArrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="classrr_1_1_r_r_mesh_arrays.html">RRMeshArrays</a> * rr::RRMesh::createArrays </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>indexed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classrr_1_1_r_r_vector.html">RRVector</a>&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>texcoords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tangents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates mesh with direct read-write access to internal data arrays. </p>
<p>Created mesh does not depend on the old one, it's safe to delete the old one. <br  />
 Note that created mesh contains reduced set of data</p><ul>
<li>only selected texcoords</li>
<li>if indexed=true, shared vertex can't have different normal/tangents/mappings in different triangles</li>
<li>Pre/PostImportNumbers are lost </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a68abd4137b3c58c6b72e0d698f6d346c" name="a68abd4137b3c58c6b72e0d698f6d346c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68abd4137b3c58c6b72e0d698f6d346c">&#9670;&#160;</a></span>aabbCache</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct AABBCache* rr::RRMesh::aabbCache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerr.html">rr</a></li><li class="navelem"><a class="el" href="classrr_1_1_r_r_mesh.html">RRMesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
